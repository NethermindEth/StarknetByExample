msgid ""
msgstr ""
"Project-Id-Version: Starknet by Example\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-12-01 22:05+0900\n"
"Last-Translator: StarknetAstro <cryptonerdcn@gmail.com>\n"
"Language-Team: Language zh-cn\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.1\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "介绍"

#: src/SUMMARY.md:6
msgid "Getting Started"
msgstr "入门"

#: src/SUMMARY.md:8
msgid "Basics of a Starknet contract"
msgstr "Starknet合约的基本内容"

#: src/SUMMARY.md:9
msgid "Storage"
msgstr "存储"

#: src/SUMMARY.md:10
msgid "Constructor"
msgstr "构造函数"

#: src/SUMMARY.md:11
msgid "Variables"
msgstr "变量"

#: src/SUMMARY.md:12
msgid "Visibility and Mutability"
msgstr "可见性和可变性"

#: src/SUMMARY.md:13
msgid "Counter Example"
msgstr "计数器示例"

#: src/SUMMARY.md:14
msgid "Mappings"
msgstr "映射"

#: src/SUMMARY.md:15
msgid "Errors"
msgstr "错误"

#: src/SUMMARY.md:16
msgid "Events"
msgstr "事件"

#: src/SUMMARY.md:17
msgid "Storing Custom Types"
msgstr "存储自定义类型"

#: src/SUMMARY.md:18
msgid "Custom types in entrypoints"
msgstr "入口点中的自定义类型"

#: src/SUMMARY.md:19
msgid "Documentation"
msgstr "文档"

#: src/SUMMARY.md:20
msgid "Deploy and interact with contracts"
msgstr "部署合约并与合约交互"

#: src/SUMMARY.md:21
msgid "Contract interfaces and Traits generation"
msgstr "合约接口和Trait生成"

#: src/SUMMARY.md:22
msgid "Calling other contracts"
msgstr "调用其他合约"

#: src/SUMMARY.md:23
msgid "Factory pattern"
msgstr "工厂模式"

#: src/SUMMARY.md:24
msgid "Testing contracts"
msgstr "测试合约"

#: src/SUMMARY.md:25
msgid "Cairo cheatsheet"
msgstr "Cairo cheatsheet"

#: src/SUMMARY.md:26
msgid "Felt"
msgstr "Felt"

#: src/SUMMARY.md:27
msgid "LegacyMap"
msgstr "LegacyMap"

#: src/SUMMARY.md:28
msgid "Arrays"
msgstr "数组"

#: src/SUMMARY.md:29
msgid "Loop"
msgstr "循环"

#: src/SUMMARY.md:30
msgid "Match"
msgstr "匹配"

#: src/SUMMARY.md:31
msgid "Tuples"
msgstr "元组"

#: src/SUMMARY.md:32
msgid "Struct"
msgstr "结构体"

#: src/SUMMARY.md:33
msgid "Type casting"
msgstr "类型转换"

#: src/SUMMARY.md:36
msgid "Applications examples"
msgstr "应用实例"

#: src/SUMMARY.md:37
msgid "Upgradeable Contract"
msgstr "可升级合约"

#: src/SUMMARY.md:38
msgid "Defi Vault"
msgstr "Defi Vault"

#: src/SUMMARY.md:39
msgid "ERC20 Token"
msgstr "ERC20 代币"

#: src/SUMMARY.md:40
msgid "Constant Product AMM"
msgstr ""

#: src/SUMMARY.md:43
msgid "Advanced concepts"
msgstr ""

#: src/SUMMARY.md:44
msgid "Writing to any storage slot"
msgstr ""

#: src/SUMMARY.md:45
msgid "Storing Arrays"
msgstr ""

#: src/SUMMARY.md:46
msgid "Struct as mapping key"
msgstr ""

#: src/SUMMARY.md:47
msgid "Hash Solidity Compatible"
msgstr ""

#: src/SUMMARY.md:48
msgid "Optimisations"
msgstr ""

#: src/SUMMARY.md:49
msgid "Storage Optimisations"
msgstr ""

#: src/SUMMARY.md:50
msgid "List"
msgstr "列表"

#: src/starknet-by-example.md:1
msgid "# Starknet by Example"
msgstr "# Starknet by Example"

#: src/starknet-by-example.md:3
msgid ""
"Starknet By Example is a collection of examples of how to use the Cairo "
"programming language to create smart contracts on Starknet."
msgstr ""
"Starknet By Example是如何使用Cairo编程语言在Starknet上创建智能合约的范例集。"

#: src/starknet-by-example.md:5
msgid ""
"Starknet is a permissionless Validity-Rollup that supports general "
"computation. It is currently used as an Ethereum layer-2. Starknet use the "
"STARK cryptographic proof system to ensure high safety and scalability."
msgstr ""
"Starknet是一种支持通用计算的无权限Validity-Rollup。它目前被用作以太坊的第二"
"层。Starknet 使用 STARK 加密证明系统来确保高安全性和可扩展性。"

#: src/starknet-by-example.md:7
msgid ""
"Starknet smart contracts are written in the Cairo language. Cairo is a "
"Turing-complete programming language designed to write provable programs, "
"abstracting the zk-STARK proof system away from the programmer."
msgstr ""
"Starknet智能合约是用Cairo语言编写的。Cairo语言是一种图灵完备的编程语言，旨在"
"编写可证明的程序，将 zk-STARK 证明系统从程序员手中抽象出来。"

#: src/starknet-by-example.md:9
msgid "The current version of this book use `scarb 2.3.0`"
msgstr "本书当前版本使用 `scarb 2.3.0`"

#: src/starknet-by-example.md:11
msgid "## For whom is this for?"
msgstr "## 谁该读这本书？"

#: src/starknet-by-example.md:13
msgid ""
"Starknet By Example is for anyone who wants to quickly learn how to write "
"smart contracts on Starknet using Cairo with some technical background in "
"programming and blockchain."
msgstr ""
"Starknet By Example适合想要快速学习如何使用 Cairo 在 Starknet 上编写智能合"
"约，并具有一定编程和区块链技术背景的人。"

#: src/starknet-by-example.md:15
msgid ""
"The first chapters will give you a basic understanding of the Cairo "
"programming language and how to write, deploy and use smart contracts on "
"Starknet.\n"
"The later chapters will cover more advanced topics and show you how to write "
"more complex smart contracts."
msgstr ""
"前几章将让你基本了解Cairo编程语言，以及如何在Starknet编写、部署和使用智能合"
"约。\n"
"后面的章节将涉及更高级的主题，并向你展示如何编写更复杂的智能合约。"

#: src/starknet-by-example.md:18
msgid "## Further reading"
msgstr "## 进一步阅读"

#: src/starknet-by-example.md:20
msgid ""
"If you want to learn more about the Cairo programming language, you can read "
"the [Cairo Book](https://book.cairo-lang.org).\n"
"If you want to learn more about Starknet, you can read the [Starknet "
"documentation](https://docs.starknet.io/) and the [Starknet Book](https://"
"book.starknet.io)."
msgstr ""
"如果你想进一步了解 Cairo 编程语言，可以阅读[Cairo Book](https://book.cairo-"
"lang.org/zh-cn/index.html)。\n"
"如果你想进一步了解星网，可以阅读[Starknet documentation](https://docs."
"starknet.io/) 和[Starknet Book](https://book.starknet.io/zh-cn/index.html)。"

#: src/starknet-by-example.md:23
msgid "Here's a list of other resources that you might find useful:"
msgstr "以下是您可能会用到的其他资源清单："

#: src/starknet-by-example.md:24
msgid ""
"- [Starklings](https://github.com/shramee/starklings-cairo1): An interactive "
"tutorial to get you up and running with Cairo v1 and Starknet \n"
"- [Cairopractice](https://cairopractice.com/): A blog with a series of "
"articles about Cairo and Starknet\n"
"- [Cairo by example](https://cairo-by-example.com/): An introduction to "
"Cairo, with simple examples"
msgstr ""

#: src/starknet-by-example.md:28 src/ch00/basics/documentation.md:35
#: src/ch00/interacting/calling_other_contracts.md:69
#: src/ch00/cairo_cheatsheet/felt.md:15 src/ch00/cairo_cheatsheet/loop.md:23
#: src/ch00/cairo_cheatsheet/tuples.md:18
#: src/ch00/cairo_cheatsheet/type_casting.md:33
msgid "<footer id=\"last-change\">Last change: 2023-11-30</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-11-30</footer>"

#: src/ch00/basics/introduction.md:1
msgid "# Basics of Smart Contracts in Cairo"
msgstr "# Cairo的智能合约基础知识"

#: src/ch00/basics/introduction.md:3
msgid ""
"The following chapters will introduce you to Starknet smart contracts and "
"how to write them in Cairo."
msgstr "以下章节将向你介绍Starknet智能合约以及如何用Cairo编写这些合约。"

#: src/ch00/basics/introduction.md:5 src/ch00/basics/constructor.md:27
#: src/ch00/basics/mappings.md:46 src/ch00/basics/errors.md:139
#: src/ch00/basics/events.md:68 src/ch00/basics/storing-custom-types.md:39
#: src/ch00/basics/custom-types-in-entrypoints.md:39
#: src/ch00/testing/contract-testing.md:176
#: src/ch01/upgradeable_contract.md:117 src/ch01/simple_vault.md:114
#: src/ch02/write_to_any_slot.md:58 src/ch02/storing_arrays.md:105
#: src/ch02/struct-mapping-key.md:46 src/ch02/optimisations/optimisations.md:5
#: src/ch02/optimisations/store_using_packing.md:90
msgid "<footer id=\"last-change\">Last change: 2023-10-12</footer>"
msgstr "<footer id=\"last-change\">Last change: 2023-10-12</footer>"

#: src/ch00/basics/storage.md:1
msgid "# Storage"
msgstr "# 存储"

#: src/ch00/basics/storage.md:3
msgid "Here's the most minimal contract you can write in Cairo:"
msgstr ""

#: src/ch00/basics/storage.md:5
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"}\n"
"```"

#: src/ch00/basics/storage.md:13
msgid ""
"Storage is a struct annoted with `#[storage]`. Every contract must have one "
"and only one storage.\n"
"It's a key-value store, where each key will be mapped to a storage address "
"of the contract's storage space."
msgstr ""
"存储是一个结构体，用 `#[storage]`标注。每个合约必须有且仅有一个存储空间。\n"
"它是一个键值存储空间，其中每个键都将映射到合约存储空间的存储地址。"

#: src/ch00/basics/storage.md:16
msgid ""
"You can define [storage variables](./variables.md#storage-variables) in your "
"contract, and then use them to store and retrieve data."
msgstr ""
"您可以在合约中定义 [存储变量]（./variables.md#storage-variables），然后使用它"
"们来存储和检索数据。"

#: src/ch00/basics/storage.md:17
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        a: u128,\n"
"        b: u8,\n"
"        c: u256\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        a: u128,\n"
"        b: u8,\n"
"        c: u256\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/storage.md:29
msgid ""
"> Actually these two contracts have the same underlying sierra program.\n"
"> From the compiler's perspective, the storage variables don't exist until "
"they are used."
msgstr ""

#: src/ch00/basics/storage.md:32
msgid ""
"You can also read about [storing custom types](./storing-custom-types.md)"
msgstr ""

#: src/ch00/basics/storage.md:34 src/ch00/basics/variables.md:126
#: src/ch01/constant-product-amm.md:275
msgid "<footer id=\"last-change\">Last change: 2023-11-20</footer>"
msgstr ""

#: src/ch00/basics/constructor.md:1
msgid "# Constructor"
msgstr "# 构造函数"

#: src/ch00/basics/constructor.md:3
msgid ""
"Constructors are a special type of function that runs only once when "
"deploying a contract, and can be used to initialize the state of the "
"contract. Your contract must not have more than one constructor, and that "
"constructor function must be annotated with the `#[constructor]` attribute. "
"Also, a good practice consists in naming that function `constructor`."
msgstr ""

#: src/ch00/basics/constructor.md:5
msgid ""
"Here's a simple example that demonstrates how to initialize the state of a "
"contract on deployment by defining logic inside a constructor."
msgstr ""

#: src/ch00/basics/constructor.md:7
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod ExampleConstructor {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"\n"
"    // The constructor is decorated with a `#[constructor]` attribute.\n"
"    // It is not inside an `impl` block.\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252, address: "
"ContractAddress) {\n"
"        self.names.write(address, name);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/constructor.md:25
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x017fd6558e67451dA583d123D77F4e2651E91502D08F8F8432355293b11e1f8F) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/constructor/src/constructor.cairo)."
msgstr ""

#: src/ch00/basics/variables.md:1
msgid "# Variables"
msgstr "# 变量"

#: src/ch00/basics/variables.md:3
msgid "There are 3 types of variables in Cairo contracts:"
msgstr ""

#: src/ch00/basics/variables.md:5
msgid ""
"- Local\n"
"  - declared inside a function\n"
"  - not stored on the blockchain\n"
"- Storage\n"
"  - declared in the [Storage](./storage.md) of a contract\n"
"  - can be accessed from one execution to another\n"
"- Global\n"
"  - provides information about the blockchain\n"
"  - accessed anywhere, even within library functions"
msgstr ""

#: src/ch00/basics/variables.md:15
msgid "## Local Variables"
msgstr ""

#: src/ch00/basics/variables.md:17
msgid ""
"Local variables are used and accessed within the scope of a specific "
"function or block of code. They are temporary and exist only for the "
"duration of that particular function or block execution."
msgstr ""

#: src/ch00/basics/variables.md:19
msgid ""
"Local variables are stored in memory and are not stored on the blockchain. "
"This means they cannot be accessed from one execution to another. Local "
"variables are useful for storing temporary data that is relevant only within "
"a specific context. They also make the code more readable by giving names to "
"intermediate values."
msgstr ""

#: src/ch00/basics/variables.md:21
msgid "Here's a simple example of a contract with only local variables:"
msgstr ""

#: src/ch00/basics/variables.md:23
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ILocalVariablesExample<TContractState> {\n"
"    fn do_something(self: @TContractState, value: u32) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod LocalVariablesExample {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl LocalVariablesExample of super::"
"ILocalVariablesExample<ContractState> {\n"
"        fn do_something(self: @ContractState, value: u32) -> u32 {\n"
"            // This variable is local to the current block. It can't be "
"accessed once it goes out of scope.\n"
"            let increment = 10;\n"
"\n"
"            {\n"
"                // The scope of a code block allows for local variable "
"declaration\n"
"                // We can access variables defined in higher scopes.\n"
"                let sum = value + increment;\n"
"                sum\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/variables.md:50
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x015B3a10F9689BeD741Ca3C210017BC097122CeF76f3cAA191A20ff8b9b56b96) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/variables/src/local_variables.cairo)."
msgstr ""

#: src/ch00/basics/variables.md:52
msgid "## Storage Variables"
msgstr "## 存储用变量"

#: src/ch00/basics/variables.md:54
msgid ""
"Storage variables are persistent data stored on the blockchain. They can be "
"accessed from one execution to another, allowing the contract to remember "
"and update information over time."
msgstr ""

#: src/ch00/basics/variables.md:56
msgid ""
"To write or update a storage variable, you need to interact with the "
"contract through an external entrypoint by sending a transaction."
msgstr ""

#: src/ch00/basics/variables.md:58
msgid ""
"On the other hand, you can read state variables, for free, without any "
"transaction, simply by interacting with a node."
msgstr ""

#: src/ch00/basics/variables.md:60
msgid "Here's a simple example of a contract with one storage variable:"
msgstr ""

#: src/ch00/basics/variables.md:62
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStorageVariableExample<TContractState> {\n"
"    fn set(ref self: TContractState, value: u32);\n"
"    fn get(self: @TContractState) -> u32;\n"
"}\n"
"#[starknet::contract]\n"
"mod StorageVariablesExample {\n"
"    // All storage variables are contained in a struct called Storage\n"
"    // annotated with the `#[storage]` attribute\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Storage variable holding a number\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StorageVariablesExample of super::"
"IStorageVariableExample<ContractState> {\n"
"        // Write to storage variables by sending a transaction that calls an "
"external function\n"
"        fn set(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"\n"
"        // Read from storage variables without sending transactions\n"
"        fn get(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/variables.md:92
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x06eA827B32875483709b785A7F9e846a52776Cd8D42C3fE696218c2624b0DCCa) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/variables/src/storage_variables."
"cairo)."
msgstr ""

#: src/ch00/basics/variables.md:94
msgid "## Global Variables"
msgstr ""

#: src/ch00/basics/variables.md:96
msgid ""
"Global variables are predefined variables that provide information about the "
"blockchain and the current execution environment. They can be accessed at "
"any time and from anywhere!"
msgstr ""

#: src/ch00/basics/variables.md:98
msgid ""
"In Starknet, you can access global variables by using specific functions "
"contained in the starknet core libraries."
msgstr ""

#: src/ch00/basics/variables.md:100
msgid ""
"For example, the `get_caller_address` function returns the address of the "
"caller of the current transaction, and the `get_contract_address` function "
"returns the address of the current contract."
msgstr ""

#: src/ch00/basics/variables.md:102
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IGlobalExample<TContractState> {\n"
"    fn foo(ref self: TContractState);\n"
"}\n"
"#[starknet::contract]\n"
"mod GlobalExample {\n"
"    // import the required functions from the starknet core library\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl GlobalExampleImpl of super::IGlobalExample<ContractState> {\n"
"        fn foo(ref self: ContractState) {\n"
"            // Call the get_caller_address function to get the sender "
"address\n"
"            let caller = get_caller_address();\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/variables.md:125
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x05bD2F3943bd4e030f85678b55b2EC2C1be939e32388530FB20ED967B3Be433F) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/variables/src/global_variables."
"cairo)."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:1
msgid "# Visibility and Mutability"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:3
msgid "## Visibility"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:5
msgid "There are two types of functions in Starknet contracts:"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:7
msgid ""
"- Functions that are accessible externally and can be called by anyone.\n"
"- Functions that are only accessible internally and can only be called by "
"other functions in the contract."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:10
msgid ""
"These functions are also typically divided into two different "
"implementations blocks. The first `impl` block for externally accessible "
"functions is explicitly annotated with an `#[abi(embed_v0)]` attribute. This "
"indicates that all the functions inside this block can be called either as a "
"transaction or as a view function. The second `impl` block for internally "
"accessible functions is not annotated with any attribute, which means that "
"all the functions inside this block are private by default."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:12
msgid "## State Mutability"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:14
msgid ""
"Regardless of whether a function is internal or external, it can either "
"modify the contract's state or not. When we declare functions that interact "
"with storage variables inside a smart contract,\n"
"we need to explicitly state that we are accessing the `ContractState` by "
"adding it as the first parameter of the function. This can be done in two "
"different ways:"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:17
msgid ""
"- If we want our function to be able to mutate the state of the contract, we "
"pass it by reference like this: `ref self: ContractState`.\n"
"- If we want our function to be read-only and not mutate the state of the "
"contract, we pass it by snapshot like this: `self: @ContractState`."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:20
msgid ""
"Read-only functions, also called view functions, can be directly called "
"without making a transaction. You can interact with them directly through a "
"RPC node to read the contract's state, and they're free to call!\n"
"External functions, that modify the contract's state, on the other side can "
"only be called by making a transaction."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:23
msgid ""
"Internal functions can't be called externally, but the same principle "
"applies regarding state mutability."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:25
msgid "Let's take a look at a simple example contract to see these in action:"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:27
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IExampleContract<TContractState> {\n"
"    fn set(ref self: TContractState, value: u32);\n"
"    fn get(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ExampleContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"\n"
"    // The `abi(embed_v0)` attribute indicates that all the functions in "
"this implementation can be called externally.\n"
"    // Omitting this attribute would make all the functions in this "
"implementation internal.\n"
"    #[abi(embed_v0)]\n"
"    impl ExampleContract of super::IExampleContract<ContractState> {\n"
"        // The `set` function can be called externally because it is written "
"inside an implementation marked as `#[external]`.\n"
"        // It can modify the contract's state as it is passed as a "
"reference.\n"
"        fn set(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"\n"
"        // The `get` function can be called externally because it is written "
"inside an implementation marked as `#[external]`.\n"
"        // However, it can't modify the contract's state is passed as a "
"snapshot: it is only a \"view\" function.\n"
"        fn get(self: @ContractState) -> u32 {\n"
"            // We can call an internal function from any functions within "
"the contract\n"
"            PrivateFunctionsTrait::_read_value(self)\n"
"        }\n"
"    }\n"
"\n"
"    // The lack of the `external` attribute indicates that all the functions "
"in this implementation can only be called internally.\n"
"    // We name the trait `PrivateFunctionsTrait` to indicate that it is an "
"internal trait allowing us to call internal functions.\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        // The `_read_value` function is outside the implementation that is "
"marked as `#[abi(embed_v0)]`, so it's an _internal_ function\n"
"        // and can only be called from within the contract.\n"
"        // It can modify the contract's state as it is passed as a "
"reference.\n"
"        fn _read_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/visibility-mutability.md:73
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x0071dE3093AB58053b0292C225aa0eED40293e7694A0042685FF6D813d39889F) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/visibility/src/visibility.cairo)."
msgstr ""

#: src/ch00/basics/visibility-mutability.md:75
#: src/ch00/interacting/interacting.md:4
msgid "<footer id=\"last-change\">Last change: 2023-10-19</footer>"
msgstr ""

#: src/ch00/basics/counter.md:1
msgid "# Simple Counter"
msgstr ""

#: src/ch00/basics/counter.md:3
msgid "This is a simple counter contract."
msgstr ""

#: src/ch00/basics/counter.md:5
msgid "Here's how it works:"
msgstr ""

#: src/ch00/basics/counter.md:7
msgid ""
"- The contract has a state variable called 'counter' that is initialized to "
"0.\n"
"\n"
"- When a user calls 'increment', the contract increments the counter by 1.\n"
"\n"
"- When a user calls 'decrement', the contract decrements the counter by 1."
msgstr ""

#: src/ch00/basics/counter.md:13
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISimpleCounter<TContractState> {\n"
"    fn get_current_count(self: @TContractState) -> u128;\n"
"    fn increment(ref self: TContractState);\n"
"    fn decrement(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleCounter {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Counter variable\n"
"        counter: u128,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_value: u128) {\n"
"        // Store initial value\n"
"        self.counter.write(init_value);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleCounter of super::ISimpleCounter<ContractState> {\n"
"        fn get_current_count(self: @ContractState) -> u128 {\n"
"            return self.counter.read();\n"
"        }\n"
"\n"
"        fn increment(ref self: ContractState) {\n"
"            // Store counter value + 1\n"
"            let counter = self.counter.read() + 1;\n"
"            self.counter.write(counter);\n"
"        }\n"
"        fn decrement(ref self: ContractState) {\n"
"            // Store counter value - 1\n"
"            let counter = self.counter.read() - 1;\n"
"            self.counter.write(counter);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/counter.md:54
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x01664a69Fe701a1df7Bb0ae4A353792d0cf4E27146ee860075cbf6108b1D5718) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/counter/src/contracts.cairo)."
msgstr ""

#: src/ch00/basics/counter.md:56
msgid "<footer id=\"last-change\">Last change: 2023-11-04</footer>"
msgstr ""

#: src/ch00/basics/mappings.md:1
msgid "# Mappings"
msgstr ""

#: src/ch00/basics/mappings.md:3
msgid ""
"Maps are a key-value data structure used to store data within a smart "
"contract. In Cairo they are implemented using the `LegacyMap` type. It's "
"important to note that the `LegacyMap` type can only be used inside the "
"`Storage` struct of a contract and that it can't be used elsewhere."
msgstr ""

#: src/ch00/basics/mappings.md:5
msgid ""
"Here we demonstrate how to use the `LegacyMap` type within a Cairo contract, "
"to map between a key of type `ContractAddress` and value of type `felt252`. "
"The key-value types are specified within angular brackets <>. We write to "
"the map by calling the `write()` method, passing in both the key and value. "
"Similarly, we can read the value associated with a given key by calling the "
"`read()` method and passing in the relevant key."
msgstr ""

#: src/ch00/basics/mappings.md:7
msgid "Some additional notes:"
msgstr ""

#: src/ch00/basics/mappings.md:9
msgid ""
"- More complex key-value mappings are possible, for example we could use "
"`LegacyMap::<(ContractAddress, ContractAddress), felt252>` to create an "
"allowance on an ERC20 token contract.\n"
"\n"
"- In mappings, the address of the value at key `k_1,...,k_n` is `h(..."
"h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where `ℎ` is the Pedersen "
"hash and the final value is taken `mod2251−256`. You can learn more about "
"the contract storage layout in the [Starknet Documentation](https://docs."
"starknet.io/documentation/architecture_and_concepts/Contracts/contract-"
"storage/#storage_variables)"
msgstr ""

#: src/ch00/basics/mappings.md:13
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IMapContract<TContractState> {\n"
"    fn set(ref self: TContractState, key: ContractAddress, value: felt252);\n"
"    fn get(self: @TContractState, key: ContractAddress) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod MapContract {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // The `LegacyMap` type is only available inside the `Storage` "
"struct.\n"
"        map: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl MapContractImpl of super::IMapContract<ContractState> {\n"
"        fn set(ref self: ContractState, key: ContractAddress, value: "
"felt252) {\n"
"            self.map.write(key, value);\n"
"        }\n"
"\n"
"        fn get(self: @ContractState, key: ContractAddress) -> felt252 {\n"
"            self.map.read(key)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/mappings.md:44
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x06214AB4c23Cc545bf2221D465eB83aFb7412779AD498BD48a724B3F645E3505) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/mappings/src/mappings.cairo)."
msgstr ""

#: src/ch00/basics/errors.md:1
msgid "# Errors"
msgstr ""

#: src/ch00/basics/errors.md:3
msgid ""
"Errors can be used to handle validation and other conditions that may occur "
"during the execution of a smart contract.\n"
"If an error is thrown during the execution of a smart contract call, the "
"execution is stopped and any changes made during the transaction are "
"reverted."
msgstr ""

#: src/ch00/basics/errors.md:6
msgid "To throw an error, use the `assert` or `panic` functions:"
msgstr ""

#: src/ch00/basics/errors.md:8
msgid ""
"- `assert` is used to validate conditions.\n"
"  If the check fails, an error is thrown along with a specified value, often "
"a message.\n"
"  It's similar to the `require` statement in Solidity.\n"
"\n"
"- `panic` immediately halt the execution with the given error value.\n"
"  It should be used when the condition to check is complex and for internal "
"errors. It's similar to the `revert` statement in Solidity.\n"
"  (Use `panic_with_felt252` to be able to directly pass a felt252 as the "
"error value)"
msgstr ""

#: src/ch00/basics/errors.md:16
msgid "Here's a simple example that demonstrates the use of these functions:"
msgstr ""

#: src/ch00/basics/errors.md:18
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IErrorsExample<TContractState> {\n"
"    fn test_assert(self: @TContractState, i: u256);\n"
"    fn test_panic(self: @TContractState, i: u256);\n"
"}\n"
"#[starknet::contract]\n"
"mod ErrorsExample {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ErrorsExample of super::IErrorsExample<ContractState> {\n"
"        fn test_assert(self: @ContractState, i: u256) {\n"
"            // Assert used to validate a condition\n"
"            // and abort execution if the condition is not met\n"
"            assert(i > 0, 'i must be greater than 0');\n"
"        }\n"
"\n"
"        fn test_panic(self: @ContractState, i: u256) {\n"
"            if (i == 0) {\n"
"                // Panic used to abort execution directly\n"
"                panic_with_felt252('i must not be 0');\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/errors.md:46
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x0022664463FF0b711CC9B549a9E87d65A0882bB1D29338C4108696B8F2216a40) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/errors/src/simple_errors.cairo)."
msgstr ""

#: src/ch00/basics/errors.md:48
msgid "## Custom errors"
msgstr ""

#: src/ch00/basics/errors.md:50
msgid ""
"You can make error handling easier by defining your error codes in a "
"specific module."
msgstr ""

#: src/ch00/basics/errors.md:52
msgid ""
"```rust\n"
"mod Errors {\n"
"    const NOT_POSITIVE: felt252 = 'must be greater than 0';\n"
"    const NOT_NULL: felt252 = 'must not be null';\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ICustomErrorsExample<TContractState> {\n"
"    fn test_assert(self: @TContractState, i: u256);\n"
"    fn test_panic(self: @TContractState, i: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod CustomErrorsExample {\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CustomErrorsExample of super::ICustomErrorsExample<ContractState> "
"{\n"
"        fn test_assert(self: @ContractState, i: u256) {\n"
"            assert(i > 0, Errors::NOT_POSITIVE);\n"
"        }\n"
"\n"
"        fn test_panic(self: @ContractState, i: u256) {\n"
"            if (i == 0) {\n"
"                panic_with_felt252(Errors::NOT_NULL);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/errors.md:85
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x0501CD5da5B453a18515B5A20b8029bd7583DFE7a399ad9f79c284F7829e4A57) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/errors/src/custom_errors.cairo)."
msgstr ""

#: src/ch00/basics/errors.md:87
msgid "## Vault example"
msgstr ""

#: src/ch00/basics/errors.md:89
msgid ""
"Here's another example that demonstrates the use of errors in a more complex "
"contract:"
msgstr ""

#: src/ch00/basics/errors.md:91
msgid ""
"```rust\n"
"mod VaultErrors {\n"
"    const INSUFFICIENT_BALANCE: felt252 = 'insufficient_balance';\n"
"// you can define more errors here\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IVaultErrorsExample<TContractState> {\n"
"    fn deposit(ref self: TContractState, amount: u256);\n"
"    fn withdraw(ref self: TContractState, amount: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod VaultErrorsExample {\n"
"    use super::VaultErrors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: u256,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl VaultErrorsExample of super::IVaultErrorsExample<ContractState> {\n"
"        fn deposit(ref self: ContractState, amount: u256) {\n"
"            let mut balance = self.balance.read();\n"
"            balance = balance + amount;\n"
"            self.balance.write(balance);\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, amount: u256) {\n"
"            let mut balance = self.balance.read();\n"
"\n"
"            assert(balance >= amount, VaultErrors::INSUFFICIENT_BALANCE);\n"
"\n"
"            // Or using panic:\n"
"            if (balance >= amount) {\n"
"                panic_with_felt252(VaultErrors::INSUFFICIENT_BALANCE);\n"
"            }\n"
"\n"
"            let balance = balance - amount;\n"
"\n"
"            self.balance.write(balance);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/errors.md:137
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x020C2da26F42A28Ef54ED428eF1810FE433784b055f9bF315C5d992b1579C268) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/errors/src/vault_errors.cairo)."
msgstr ""

#: src/ch00/basics/events.md:1
msgid "# Events"
msgstr "# 事件"

#: src/ch00/basics/events.md:3
msgid ""
"Events are a way to emit data from a contract. All events must be defined in "
"the `Event` enum, which must be annotated with the `#[event]` attribute.\n"
"An event is defined as struct that derives the `#[starknet::Event]` trait. "
"The fields of that struct correspond to the data that will be emitted. An "
"event can be indexed for easy and fast access when querying the data at a "
"later time. Events data can be indexed by adding a `#[key]` attribute to a "
"field member."
msgstr ""

#: src/ch00/basics/events.md:6
msgid ""
"Here's a simple example of a contract using events that emit an event each "
"time a counter is incremented by the \"increment\" function:"
msgstr ""

#: src/ch00/basics/events.md:8
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IEventCounter<TContractState> {\n"
"    fn increment(ref self: TContractState);\n"
"}\n"
"#[starknet::contract]\n"
"mod EventCounter {\n"
"    use starknet::{get_caller_address, ContractAddress};\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Counter value\n"
"        counter: u128,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    // The event enum must be annotated with the `#[event]` attribute.\n"
"    // It must also derive the `Drop` and `starknet::Event` traits.\n"
"    enum Event {\n"
"        CounterIncreased: CounterIncreased,\n"
"        UserIncreaseCounter: UserIncreaseCounter\n"
"    }\n"
"\n"
"    // By deriving the `starknet::Event` trait, we indicate to the compiler "
"that\n"
"    // this struct will be used when emitting events.\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct CounterIncreased {\n"
"        amount: u128\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct UserIncreaseCounter {\n"
"        // The `#[key]` attribute indicates that this event will be "
"indexed.\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        new_value: u128,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl EventCounter of super::IEventCounter<ContractState> {\n"
"        fn increment(ref self: ContractState) {\n"
"            let mut counter = self.counter.read();\n"
"            counter += 1;\n"
"            self.counter.write(counter);\n"
"            // Emit event\n"
"            self.emit(Event::CounterIncreased(CounterIncreased { amount: "
"1 }));\n"
"            self\n"
"                .emit(\n"
"                    Event::UserIncreaseCounter(\n"
"                        UserIncreaseCounter {\n"
"                            user: get_caller_address(), new_value: self."
"counter.read()\n"
"                        }\n"
"                    )\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/events.md:66
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x022e3B59518EA04aBb5da671ea04ecC3a154400f226d2Df38eFE146741b9E2F6) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/events/src/counter.cairo)."
msgstr ""

#: src/ch00/basics/storing-custom-types.md:1
msgid "# Storing Custom Types"
msgstr ""

#: src/ch00/basics/storing-custom-types.md:3
msgid ""
"While native types can be stored in a contract's storage without any "
"additional work, custom types require a bit more work. This is because at "
"compile time, the compiler does not know how to store custom types in "
"storage. To solve this, we need to implement the `Store` trait for our "
"custom type. Hopefully, we can just derive this trait for our custom type - "
"unless it contains arrays or dictionaries."
msgstr ""

#: src/ch00/basics/storing-custom-types.md:5
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStoringCustomType<TContractState> {\n"
"    fn set_person(ref self: TContractState, person: Person);\n"
"}\n"
"\n"
"// Deriving the starknet::Store trait\n"
"// allows us to store the `Person` struct in the contract's storage.\n"
"#[derive(Drop, Serde, Copy, starknet::Store)]\n"
"struct Person {\n"
"    age: u8,\n"
"    name: felt252\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod StoringCustomType {\n"
"    use super::Person;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        person: Person\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StoringCustomType of super::IStoringCustomType<ContractState> {\n"
"        fn set_person(ref self: ContractState, person: Person) {\n"
"            self.person.write(person);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/storing-custom-types.md:37
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/storing_custom_types/src/contract."
"cairo)."
msgstr ""

#: src/ch00/basics/custom-types-in-entrypoints.md:1
msgid "# Custom types in entrypoints"
msgstr ""

#: src/ch00/basics/custom-types-in-entrypoints.md:3
msgid ""
"Using custom types in entrypoints requires our type to implement the `Serde` "
"trait. This is because when calling an entrypoint, the input is sent as an "
"array of `felt252` to the entrypoint, and we need to be able to deserialize "
"it into our custom type. Similarly, when returning a custom type from an "
"entrypoint, we need to be able to serialize it into an array of `felt252`.\n"
"Thankfully, we can just derive the `Serde` trait for our custom type."
msgstr ""

#: src/ch00/basics/custom-types-in-entrypoints.md:6
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISerdeCustomType<TContractState> {\n"
"    fn person_input(ref self: TContractState, person: SerdeCustomType::"
"Person);\n"
"    fn person_output(self: @TContractState) -> SerdeCustomType::Person;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SerdeCustomType {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    // Deriving the `Serde` trait allows us to use\n"
"    // the Person type as an entrypoint parameter and return value\n"
"    #[derive(Drop, Serde)]\n"
"    struct Person {\n"
"        age: u8,\n"
"        name: felt252\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SerdeCustomType of super::ISerdeCustomType<ContractState> {\n"
"        fn person_input(ref self: ContractState, person: Person) {}\n"
"\n"
"        fn person_output(self: @ContractState) -> Person {\n"
"            Person { age: 10, name: 'Joe' }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/custom-types-in-entrypoints.md:37
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/custom_type_serde/src/contract."
"cairo)."
msgstr ""

#: src/ch00/basics/documentation.md:1
msgid "# Documentation"
msgstr "# 文档"

#: src/ch00/basics/documentation.md:3
msgid ""
"It's important to take the time to document your code. It will helps "
"developers and users to understand the contract and its functionalities."
msgstr ""

#: src/ch00/basics/documentation.md:5
msgid "In Cairo, you can add comments with `//`."
msgstr ""

#: src/ch00/basics/documentation.md:7
msgid "### Contract Interface:"
msgstr ""

#: src/ch00/basics/documentation.md:9
msgid ""
"In smart contracts, you will often have a trait that defines the contract's "
"interface (with `#[starknet::interface]`).\n"
"This is the perfect place to include detailed documentation explaining the "
"purpose and functionality of the contract entry points. You can follow this "
"template:"
msgstr ""

#: src/ch00/basics/documentation.md:12
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IContract<TContractState> {\n"
"    /// High-level description of the function\n"
"    ///\n"
"    /// # Arguments\n"
"    /// * `arg_1` - Description of the argument\n"
"    /// * `arg_n` - ...\n"
"    ///\n"
"    /// # Returns\n"
"    /// High-level description of the return value\n"
"    fn do_something(ref self: TContractState, arg_1: T_arg_1) -> T_return;\n"
"}\n"
"```"
msgstr ""

#: src/ch00/basics/documentation.md:27
msgid ""
"Keep in mind that this should not describe the implementation details of the "
"function, but rather the high-level purpose and functionality of the "
"contract from the perspective of a user."
msgstr ""

#: src/ch00/basics/documentation.md:29
msgid "### Implementation Details:"
msgstr "### 实装细节："

#: src/ch00/basics/documentation.md:31
msgid ""
"When writing the logic of the contract, you can add comments to describe the "
"technical implementation details of the functions."
msgstr ""

#: src/ch00/basics/documentation.md:33
msgid ""
"> Avoid over-commenting: Comments should provide additional value and "
"clarity."
msgstr ""

#: src/ch00/interacting/interacting.md:1
msgid "# Deploy and interact with contracts"
msgstr "# 部署合约并与合约交互"

#: src/ch00/interacting/interacting.md:3
msgid "In this chapter, we will see how to deploy and interact with contracts."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:1
msgid "# Contract interfaces and Traits generation"
msgstr "# 合约接口和Trait生成"

#: src/ch00/interacting/interfaces-traits.md:3
msgid ""
"Contract interfaces define the structure and behavior of a contract, serving "
"as the contract's public ABI. They list all the function signatures that a "
"contract exposes. For a detailed explanation of interfaces, you can refer to "
"the [Cairo Book](https://book.cairo-lang.org/ch99-01-02-a-simple-contract."
"html)."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:5
msgid ""
"In cairo, to specify the interface you need to define a trait annotated with "
"`#[starknet::interface]` and then implement that trait in the contract."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:7
msgid ""
"When a function needs to access the contract state, it must have a `self` "
"parameter of type `ContractState`. This implies that the corresponding "
"function signature in the interface trait must also take a `TContractState` "
"type as a parameter. It's important to note that every function in the "
"contract interface must have this `self` parameter of type `TContractState`."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:9
msgid ""
"You can use the `#[generate_trait]` attribute to implicitly generate the "
"trait for a specific implementation block. This attribute automatically "
"generates a trait with the same functions as the ones in the implemented "
"block, replacing the `self` parameter with a generic `TContractState` "
"parameter. However, you will need to annotate the block with the "
"`#[abi(per_item)]` attribute, and each function with the appropriate "
"attribute depending on whether it's an external function, a constructor or a "
"l1 handler."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:11
msgid "In summary, there's two ways to handle interfaces:"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:13
msgid ""
"- Explicitly, by defining a trait annoted with `#[starknet::interface]`\n"
"- Implicitly, by using `#[generate_trait]` combined with the "
"#[abi(per_item)]` attributes, and annotating each function inside the "
"implementation block with the appropriate attribute."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:16
msgid "## Explicit interface"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:18
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IExplicitInterfaceContract<TContractState> {\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn set_value(ref self: TContractState, value: u32);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ExplicitInterfaceContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ExplicitInterfaceContract of super::"
"IExplicitInterfaceContract<ContractState> {\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:45
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/interfaces_traits/src/explicit."
"cairo)."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:47
msgid "## Implicit interface"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:49
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod ImplicitInterfaceContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(per_item)]\n"
"    #[generate_trait]\n"
"    impl ImplicitInterfaceContract of IImplicitInterfaceContract {\n"
"        #[external(v0)]\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        #[external(v0)]\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:73
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/interfaces_traits/src/implicit."
"cairo)."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:75
msgid ""
"> Note: You can import an implicitly generated contract interface with `use "
"contract::{GeneratedContractInterface}`. However, the `Dispatcher` will not "
"be generated automatically."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:77
msgid "## Internal functions"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:79
msgid ""
"You can also use `#[generate_trait]` for your internal functions.\n"
"Since this trait is generated in the context of the contract, you can define "
"pure functions as well (functions without the `self` parameter)."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:82
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IImplicitInternalContract<TContractState> {\n"
"    fn add(ref self: TContractState, nb: u32);\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn get_const(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ImplicitInternalContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"        fn get_const() -> u32 {\n"
"            42\n"
"        }\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.set_value(0);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ImplicitInternalContract of super::"
"IImplicitInternalContract<ContractState> {\n"
"        fn add(ref self: ContractState, nb: u32) {\n"
"            self.set_value(self.value.read() + nb);\n"
"        }\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"        fn get_const(self: @ContractState) -> u32 {\n"
"            self.get_const()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:127
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/interfaces_traits/src/"
"implicit_internal.cairo)."
msgstr ""

#: src/ch00/interacting/interfaces-traits.md:129
msgid "<footer id=\"last-change\">Last change: 2023-11-26</footer>"
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:1
msgid "# Calling other contracts"
msgstr "# 调用其他合约"

#: src/ch00/interacting/calling_other_contracts.md:3
msgid "There are two different ways to call other contracts in Cairo."
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:5
msgid ""
"The easiest way to call other contracts is by using the dispatcher of the "
"contract you want to call.\n"
"You can read more about Dispatchers in the [Cairo Book](https://book.cairo-"
"lang.org/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls."
"html#contract-dispatcher)"
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:8
msgid ""
"The other way is to use the `starknet::call_contract_syscall` syscall "
"yourself. However, this method is not recommended."
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:10
msgid ""
"In order to call other contracts using dispatchers, you will need to define "
"the called contract's interface as a trait annotated with the `#[starknet::"
"interface]` attribute, and then import the `IContractDispatcher` and "
"`IContractDispatcherTrait` items in your contract."
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:12
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ICallee<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Callee {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u128,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ICalleeImpl of super::ICallee<ContractState> {\n"
"        fn set_value(ref self: ContractState, value: u128) -> u128 {\n"
"            self.value.write(value);\n"
"            value\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:34
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x015c3Bb6D0DE26b64FEAF9A8f4655CfADb5c128bF4510398972704ee12775DB1) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/calling_other_contracts/src/callee."
"cairo)."
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:36
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"// We need to have the interface of the callee contract defined\n"
"// so that we can import the Dispatcher.\n"
"#[starknet::interface]\n"
"trait ICallee<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128) -> u128;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ICaller<TContractState> {\n"
"    fn set_value_from_address(ref self: TContractState, addr: "
"ContractAddress, value: u128);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Caller {\n"
"    // We import the Dispatcher of the called contract\n"
"    use super::{ICalleeDispatcher, ICalleeDispatcherTrait};\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ICallerImpl of super::ICaller<ContractState> {\n"
"        fn set_value_from_address(ref self: ContractState, addr: "
"ContractAddress, value: u128) {\n"
"            ICalleeDispatcher { contract_address: addr }.set_value(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/interacting/calling_other_contracts.md:68
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x05fa8aF796343d2f22c53C17149386b67B7AC4aB52D9e308Aa507C185aA44778) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/calling_other_contracts/src/caller."
"cairo)."
msgstr ""

#: src/ch00/interacting/factory.md:1
msgid "# Factory Pattern"
msgstr ""

#: src/ch00/interacting/factory.md:3
msgid ""
"The factory pattern is a well known pattern in object oriented programming. "
"It provides an abstraction on how to instantiate a class. "
msgstr ""

#: src/ch00/interacting/factory.md:5
msgid ""
"In the case of smart contracts, we can use this pattern by defining a "
"factory contract that have the sole responsibility of creating and managing "
"other contracts."
msgstr ""

#: src/ch00/interacting/factory.md:7
msgid "## Class hash and contract instance"
msgstr ""

#: src/ch00/interacting/factory.md:9
msgid ""
"In Starknet, there's a separation between contract's classes and instances. "
"A contract class serves as a blueprint, defined by the underling Cairo "
"bytecode, contract's entrypoints, ABI and Sierra program hash. The contract "
"class is identified by a class hash. When you want to add a new class to the "
"network, you first need to declare it."
msgstr ""

#: src/ch00/interacting/factory.md:11
msgid ""
"When deploying a contract, you need to specify the class hash of the "
"contract you want to deploy. Each instance of a contract has their own "
"storage regardless of the class hash."
msgstr ""

#: src/ch00/interacting/factory.md:13
msgid ""
"Using the factory pattern, we can deploy multiple instances of the same "
"contract class and handle upgrades easily."
msgstr ""

#: src/ch00/interacting/factory.md:15
msgid "## Minimal example"
msgstr ""

#: src/ch00/interacting/factory.md:17
msgid ""
"Here's a minimal example of a factory contract that deploy the "
"`SimpleCounter` contract:"
msgstr ""

#: src/ch00/interacting/factory.md:19
msgid ""
"```rust\n"
"use starknet::{ContractAddress, ClassHash};\n"
"\n"
"#[starknet::interface]\n"
"trait ICounterFactory<TContractState> {\n"
"    /// Create a new counter contract from stored arguments\n"
"    fn create_counter(ref self: TContractState) -> ContractAddress;\n"
"\n"
"    /// Create a new counter contract from the given arguments\n"
"    fn create_counter_at(ref self: TContractState, init_value: u128) -> "
"ContractAddress;\n"
"\n"
"    /// Update the argument\n"
"    fn update_init_value(ref self: TContractState, init_value: u128);\n"
"\n"
"    /// Update the class hash of the Counter contract to deploy when "
"creating a new counter\n"
"    fn update_counter_class_hash(ref self: TContractState, "
"counter_class_hash: ClassHash);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod CounterFactory {\n"
"    use starknet::{ContractAddress, ClassHash};\n"
"    use starknet::syscalls::deploy_syscall;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        /// Store the constructor arguments of the contract to deploy\n"
"        init_value: u128,\n"
"        /// Store the class hash of the contract to deploy\n"
"        counter_class_hash: ClassHash,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_value: u128, class_hash: "
"ClassHash) {\n"
"        self.init_value.write(init_value);\n"
"        self.counter_class_hash.write(class_hash);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl Factory of super::ICounterFactory<ContractState> {\n"
"        fn create_counter_at(ref self: ContractState, init_value: u128) -> "
"ContractAddress {\n"
"            // Contructor arguments\n"
"            let mut constructor_calldata: Array::<felt252> = array!"
"[init_value.into()];\n"
"\n"
"            // Contract deployment\n"
"            let (deployed_address, _) = deploy_syscall(\n"
"                self.counter_class_hash.read(), 0, constructor_calldata."
"span(), false\n"
"            )\n"
"                .expect('failed to deploy counter');\n"
"\n"
"            deployed_address\n"
"        }\n"
"\n"
"        fn create_counter(ref self: ContractState) -> ContractAddress {\n"
"            self.create_counter_at(self.init_value.read())\n"
"        }\n"
"\n"
"        fn update_init_value(ref self: ContractState, init_value: u128) {\n"
"            self.init_value.write(init_value);\n"
"        }\n"
"\n"
"        fn update_counter_class_hash(ref self: ContractState, "
"counter_class_hash: ClassHash) {\n"
"            self.counter_class_hash.write(counter_class_hash);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/interacting/factory.md:86
msgid ""
"<!-- This is not ready for \"Open in remix\" because we need multiple files "
"-->"
msgstr ""

#: src/ch00/interacting/factory.md:88
msgid ""
"This factory can be used to deploy multiple instances of the `SimpleCounter` "
"contract by calling the `create_counter` and `create_counter_at` functions."
msgstr ""

#: src/ch00/interacting/factory.md:90
msgid ""
"The `SimpleCounter` class hash is stored inside the factory, and can be "
"upgraded with the `update_counter_class_hash` function which allows to reuse "
"the same factory contract when the `SimpleCounter` contract is upgraded."
msgstr ""

#: src/ch00/interacting/factory.md:92
msgid ""
"This minimal example lacks several useful features such as access control, "
"tracking of deployed contracts, events, ..."
msgstr ""

#: src/ch00/interacting/factory.md:94
msgid ""
"<!-- TODO maybe add a more complete example at the end of this section or in "
"the `Applications examples` chapter -->\n"
"\n"
"<footer id=\"last-change\">Last change: 2023-10-19</footer>"
msgstr ""

#: src/ch00/testing/contract-testing.md:1
msgid "# Contract Testing"
msgstr ""

#: src/ch00/testing/contract-testing.md:3
msgid ""
"Testing plays a crucial role in software development, especially for smart "
"contracts. In this section, we'll guide you through the basics of testing a "
"smart contract on Starknet with `scarb`."
msgstr ""

#: src/ch00/testing/contract-testing.md:5
msgid "Let's start with a simple smart contract as an example:"
msgstr ""

#: src/ch00/testing/contract-testing.md:6
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait ISimpleContract<TContractState> {\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn get_owner(self: @TContractState) -> ContractAddress;\n"
"    fn set_value(ref self: TContractState, value: u32);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleContract {\n"
"    use starknet::{get_caller_address, ContractAddress};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32,\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, initial_value: u32) {\n"
"        self.value.write(initial_value);\n"
"        self.owner.write(get_caller_address());\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleContract of super::ISimpleContract<ContractState> {\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            assert(self.owner.read() == get_caller_address(), 'Not owner');\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/testing/contract-testing.md:50
msgid "Now, take a look at the tests for this contract:"
msgstr ""

#: src/ch00/testing/contract-testing.md:51
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    // Import the interface and dispatcher to be able to interact with the "
"contract.\n"
"    use sbe_testing::contract::{\n"
"        ISimpleContract, SimpleContract, ISimpleContractDispatcher, "
"ISimpleContractDispatcherTrait\n"
"    };\n"
"\n"
"    // Import the deploy syscall to be able to deploy the contract.\n"
"    use starknet::class_hash::Felt252TryIntoClassHash;\n"
"    use starknet::{\n"
"        deploy_syscall, ContractAddress, get_caller_address, "
"get_contract_address,\n"
"        contract_address_const\n"
"    };\n"
"\n"
"    // Use starknet test utils to fake the transaction context.\n"
"    use starknet::testing::{set_caller_address, set_contract_address};\n"
"\n"
"    // Deploy the contract and return its dispatcher.\n"
"    fn deploy(initial_value: u32) -> ISimpleContractDispatcher {\n"
"        // Set up constructor arguments.\n"
"        let mut calldata = ArrayTrait::new();\n"
"        initial_value.serialize(ref calldata);\n"
"\n"
"        // Declare and deploy\n"
"        let (contract_address, _) = deploy_syscall(\n"
"            SimpleContract::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata."
"span(), false\n"
"        )\n"
"            .unwrap();\n"
"\n"
"        // Return the dispatcher.\n"
"        // The dispatcher allows to interact with the contract based on its "
"interface.\n"
"        ISimpleContractDispatcher { contract_address }\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_deploy() {\n"
"        let initial_value: u32 = 10;\n"
"        let contract = deploy(initial_value);\n"
"\n"
"        assert(contract.get_value() == initial_value, 'wrong initial "
"value');\n"
"        assert(contract.get_owner() == get_contract_address(), 'wrong "
"owner');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_set_as_owner() {\n"
"        // Fake the caller address to address 1\n"
"        let owner = contract_address_const::<1>();\n"
"        set_contract_address(owner);\n"
"\n"
"        let contract = deploy(10);\n"
"        assert(contract.get_owner() == owner, 'wrong owner');\n"
"\n"
"        // Fake the contract address to address 1\n"
"        set_contract_address(owner);\n"
"        let new_value: u32 = 20;\n"
"        contract.set_value(new_value);\n"
"\n"
"        assert(contract.get_value() == new_value, 'wrong value');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_set_not_owner() {\n"
"        let owner = contract_address_const::<1>();\n"
"        set_contract_address(owner);\n"
"\n"
"        let contract = deploy(10);\n"
"\n"
"        let not_owner = contract_address_const::<2>();\n"
"        set_contract_address(not_owner);\n"
"\n"
"        let new_value: u32 = 20;\n"
"        contract.set_value(new_value);\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/testing/contract-testing.md:132
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/testing/src/lib.cairo)."
msgstr ""

#: src/ch00/testing/contract-testing.md:134
msgid ""
"To define our test, we use scarb, which allows us to create a separate "
"module guarded with `#[cfg(test)]`. This ensures that the test module is "
"only compiled when running tests using `scarb test`."
msgstr ""

#: src/ch00/testing/contract-testing.md:136
msgid ""
"Each test is defined as a function with the `#[test]` attribute. You can "
"also check if a test panics using the `#[should_panic]` attribute."
msgstr ""

#: src/ch00/testing/contract-testing.md:138
msgid ""
"As we are in the context of a smart contract, it's essential to set up the "
"gas limit. You do this by using the `#[available_gas(X)]` attribute to "
"specify the gas limit for a test. This is also a great way to ensure that "
"your contract's features stay under a certain gas limit!"
msgstr ""

#: src/ch00/testing/contract-testing.md:140
msgid "> Note: The term \"gas\" here refers to Sierra gas, not L1 gas"
msgstr ""

#: src/ch00/testing/contract-testing.md:142
msgid "Now, let's move on to the testing process:"
msgstr ""

#: src/ch00/testing/contract-testing.md:143
msgid ""
"- Use the `deploy` function logic to declare and deploy your contract.\n"
"- Use `assert` to verify that the contract behaves as expected in the given "
"context."
msgstr ""

#: src/ch00/testing/contract-testing.md:146
msgid ""
"To make testing more convenient, the `testing` module of the corelib "
"provides some helpful functions:"
msgstr ""

#: src/ch00/testing/contract-testing.md:147
msgid ""
"- `set_caller_address(address: ContractAddress)`\n"
"- `set_contract_address(address: ContractAddress)`\n"
"- `set_block_number(block_number: u64)`\n"
"- `set_block_timestamp(block_timestamp: u64)`\n"
"- `set_account_contract_address(address: ContractAddress)`\n"
"- `set_max_fee(fee: u128)`"
msgstr ""

#: src/ch00/testing/contract-testing.md:154
msgid ""
"You may also need the `info` module from the corelib, which allows you to "
"access information about the current transaction context:"
msgstr ""

#: src/ch00/testing/contract-testing.md:155
msgid ""
"- `get_caller_address() -> ContractAddress`\n"
"- `get_contract_address() -> ContractAddress`\n"
"- `get_block_info() -> Box<BlockInfo>`\n"
"- `get_tx_info() -> Box<TxInfo>`\n"
"- `get_block_timestamp() -> u64`\n"
"- `get_block_number() -> u64`"
msgstr ""

#: src/ch00/testing/contract-testing.md:163
msgid ""
"You can found the full list of functions in the [Starknet Corelib repo]"
"(https://github.com/starkware-libs/cairo/tree/main/corelib/src/starknet).\n"
"You can also find a detailled explaination of testing in cairo in the [Cairo "
"book - Chapter 8](https://book.cairo-lang.org/ch08-01-how-to-write-tests."
"html)."
msgstr ""

#: src/ch00/testing/contract-testing.md:166
msgid "## Starknet Foundry"
msgstr "## Starknet Foundry"

#: src/ch00/testing/contract-testing.md:168
msgid "<!-- TODO update this when Starknet Foundry is more mature. -->"
msgstr ""

#: src/ch00/testing/contract-testing.md:170
msgid ""
"Starknet Foundry is a powerful toolkit for developing smart contracts on "
"Starknet. It offers support for testing Starknet smart contracts on top of "
"`scarb` with the `Forge` tool."
msgstr ""

#: src/ch00/testing/contract-testing.md:172
msgid ""
"Testing with `snforge` is similar to the process we just described but "
"simplified. Moreover, additional features are on the way, including "
"cheatcodes or parallel tests execution. We highly recommend exploring "
"Starknet Foundry and incorporating it into your projects."
msgstr ""

#: src/ch00/testing/contract-testing.md:174
msgid ""
"For more detailed information about testing contracts with Starknet Foundry, "
"check out the [Starknet Foundry Book - Testing Contracts](https://foundry-rs."
"github.io/starknet-foundry/testing/contracts.html)."
msgstr ""

#: src/ch00/cairo_cheatsheet/cairo_cheatsheet.md:1
msgid "# Cairo Cheatsheet"
msgstr ""

#: src/ch00/cairo_cheatsheet/cairo_cheatsheet.md:3
msgid ""
"This chapter aims to provide a quick reference for the most common Cairo "
"constructs."
msgstr ""

#: src/ch00/cairo_cheatsheet/cairo_cheatsheet.md:5
#: src/ch00/cairo_cheatsheet/mapping.md:58
#: src/ch00/cairo_cheatsheet/arrays.md:42 src/ch00/cairo_cheatsheet/match.md:59
#: src/ch00/cairo_cheatsheet/struct.md:15
msgid "<footer id=\"last-change\">Last change: 2023-10-31</footer>"
msgstr ""

#: src/ch00/cairo_cheatsheet/felt.md:1
msgid "# Felt252"
msgstr "# Felt252"

#: src/ch00/cairo_cheatsheet/felt.md:3
msgid ""
"Felt252 is a fundamental data type in Cairo from which all other data types "
"are derived.\n"
"Felt252 can also be used to store short-string representations with a "
"maximum length of 31 characters."
msgstr ""

#: src/ch00/cairo_cheatsheet/felt.md:6 src/ch00/cairo_cheatsheet/arrays.md:20
#: src/ch02/hash-solidity-compatible.md:5
msgid "For example:"
msgstr "例如："

#: src/ch00/cairo_cheatsheet/felt.md:8
msgid ""
"```rust\n"
"    let felt: felt252 = 100;\n"
"    let felt_as_str = 'Hello Starknet!';\n"
"\n"
"    let felt = felt + felt_as_str;\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/mapping.md:1
msgid "# Mapping"
msgstr "# Mapping"

#: src/ch00/cairo_cheatsheet/mapping.md:3
msgid ""
"The ```LegacyMap``` type can be used to represent a collection of key-value."
msgstr ""

#: src/ch00/cairo_cheatsheet/mapping.md:5
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IMappingExample<TContractState> {\n"
"    fn register_user(ref self: TContractState, student_add: ContractAddress, "
"studentName: felt252);\n"
"    fn record_student_score(\n"
"        ref self: TContractState, student_add: ContractAddress, subject: "
"felt252, score: u16\n"
"    );\n"
"    fn view_student_name(self: @TContractState, student_add: "
"ContractAddress) -> felt252;\n"
"    fn view_student_score(\n"
"        self: @TContractState, student_add: ContractAddress, subject: "
"felt252\n"
"    ) -> u16;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod MappingContract {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        students_name: LegacyMap::<ContractAddress, felt252>,\n"
"        students_result_record: LegacyMap::<(ContractAddress, felt252), "
"u16>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl External of super::IMappingExample<ContractState> {\n"
"        fn register_user(\n"
"            ref self: ContractState, student_add: ContractAddress, "
"studentName: felt252\n"
"        ) {\n"
"            self.students_name.write(student_add, studentName);\n"
"        }\n"
"\n"
"        fn record_student_score(\n"
"            ref self: ContractState, student_add: ContractAddress, subject: "
"felt252, score: u16\n"
"        ) {\n"
"            self.students_result_record.write((student_add, subject), "
"score);\n"
"        }\n"
"\n"
"        fn view_student_name(self: @ContractState, student_add: "
"ContractAddress) -> felt252 {\n"
"            self.students_name.read(student_add)\n"
"        }\n"
"\n"
"        fn view_student_score(\n"
"            self: @ContractState, student_add: ContractAddress, subject: "
"felt252\n"
"        ) -> u16 {\n"
"            // for a 2D mapping its important to take note of the amount of "
"brackets being used.\n"
"            self.students_result_record.read((student_add, subject))\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/arrays.md:1
msgid "# Arrays"
msgstr "# 数组"

#: src/ch00/cairo_cheatsheet/arrays.md:3
msgid ""
"Arrays are collections of elements of the same type.\n"
"The possible operations on arrays are defined with the `array::ArrayTrait` "
"of the corelib:"
msgstr ""

#: src/ch00/cairo_cheatsheet/arrays.md:6
msgid ""
"```rust\n"
"trait ArrayTrait<T> {\n"
"    fn new() -> Array<T>;\n"
"    fn append(ref self: Array<T>, value: T);\n"
"    fn pop_front(ref self: Array<T>) -> Option<T> nopanic;\n"
"    fn pop_front_consume(self: Array<T>) -> Option<(Array<T>, T)> nopanic;\n"
"    fn get(self: @Array<T>, index: usize) -> Option<Box<@T>>;\n"
"    fn at(self: @Array<T>, index: usize) -> @T;\n"
"    fn len(self: @Array<T>) -> usize;\n"
"    fn is_empty(self: @Array<T>) -> bool;\n"
"    fn span(self: @Array<T>) -> Span<T>;\n"
"}\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/arrays.md:22
msgid ""
"```rust\n"
"fn array() -> bool {\n"
"    let mut arr = ArrayTrait::<u32>::new();\n"
"    arr.append(10);\n"
"    arr.append(20);\n"
"    arr.append(30);\n"
"\n"
"    assert(arr.len() == 3, 'array length should be 3');\n"
"\n"
"    let first_value = arr.pop_front().unwrap();\n"
"    assert(first_value == 10, 'first value should match');\n"
"\n"
"    let second_value = *arr.at(0);\n"
"    assert(second_value == 20, 'second value should match');\n"
"\n"
"    // Returns true if an array is empty, then false if it isn't.\n"
"    arr.is_empty()\n"
"}\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/loop.md:1
msgid "# Loop"
msgstr ""

#: src/ch00/cairo_cheatsheet/loop.md:3
msgid ""
"A loop specifies a block of code that will run repetitively until a halting "
"condition is encountered.\n"
"For example:"
msgstr ""

#: src/ch00/cairo_cheatsheet/loop.md:6
msgid ""
"```rust\n"
"    let mut arr = ArrayTrait::new();\n"
"\n"
"    // Same as ~ while (i < 10) arr.append(i++);\n"
"    let mut i: u32 = 0;\n"
"    let limit = 10;\n"
"    loop {\n"
"        if i == limit {\n"
"            break;\n"
"        };\n"
"\n"
"        arr.append(i);\n"
"\n"
"        i += 1;\n"
"    };\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/match.md:1
msgid "# Match"
msgstr ""

#: src/ch00/cairo_cheatsheet/match.md:3
msgid ""
"The \"match\" expression in Cairo allows us to control the flow of our code "
"by comparing a felt data type or an enum against various patterns and then "
"running specific code based on the pattern that matches.\n"
"For example:"
msgstr ""

#: src/ch00/cairo_cheatsheet/match.md:6
msgid ""
"```rust\n"
"#[derive(Drop, Serde)]\n"
"enum Colour {\n"
"    Red,\n"
"    Blue,\n"
"    Green,\n"
"    Orange,\n"
"    Black\n"
"}\n"
"\n"
"#[derive(Drop, Serde)]\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter,\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"\n"
"fn specified_colour(colour: Colour) -> felt252 {\n"
"    let mut response: felt252 = '';\n"
"\n"
"    match colour {\n"
"        Colour::Red => { response = 'You passed in Red'; },\n"
"        Colour::Blue => { response = 'You passed in Blue'; },\n"
"        Colour::Green => { response = 'You passed in Green'; },\n"
"        Colour::Orange => { response = 'You passed in Orange'; },\n"
"        Colour::Black => { response = 'You passed in Black'; },\n"
"    };\n"
"\n"
"    response\n"
"}\n"
"\n"
"fn quiz(num: felt252) -> felt252 {\n"
"    let mut response: felt252 = '';\n"
"\n"
"    match num {\n"
"        0 => { response = 'You failed' },\n"
"        _ => { response = 'You Passed' },\n"
"    };\n"
"\n"
"    response\n"
"}\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/tuples.md:1
msgid "# Tuples"
msgstr "# 元组"

#: src/ch00/cairo_cheatsheet/tuples.md:3
msgid ""
"Tuples is a data type to group a fixed number of items of potentially "
"different types into a single compound structure. Unlike arrays, tuples have "
"a set length and can contain elements of varying types. Once a tuple is "
"created, its size cannot change.\n"
"For example:"
msgstr ""

#: src/ch00/cairo_cheatsheet/tuples.md:6
msgid ""
"```rust\n"
"    let address = \"0x000\";\n"
"    let age = 20;\n"
"    let active = true;\n"
"\n"
"    // Create tuple\n"
"    let user_tuple = (address, age, active);\n"
"\n"
"    // Access tuple\n"
"    let (address, age, active) = stored_tuple;\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/struct.md:1
msgid "# Struct"
msgstr "# 结构体"

#: src/ch00/cairo_cheatsheet/struct.md:3
msgid ""
"A struct is a data type similar to tuple. Like tuples they can be used to "
"hold data of different types.\n"
"For example:"
msgstr ""

#: src/ch00/cairo_cheatsheet/struct.md:6
msgid ""
"```rust\n"
"// With Store, you can store Data's structs in the storage part of "
"contracts.\n"
"#[derive(Drop, starknet::Store)]\n"
"struct Data {\n"
"    address: starknet::ContractAddress,\n"
"    age: u8\n"
"}\n"
"```"
msgstr ""

#: src/ch00/cairo_cheatsheet/type_casting.md:1
msgid "# Type casting"
msgstr "# 类型转换"

#: src/ch00/cairo_cheatsheet/type_casting.md:3
msgid ""
"Cairo supports the conversion from one scalar types to another by using the "
"into and try_into methods.\n"
"`traits::Into` is used for conversion from a smaller data type to a larger "
"data type, while `traits::TryInto` is used when converting from a larger to "
"a smaller type that might not fit. \n"
"For example:"
msgstr ""

#: src/ch00/cairo_cheatsheet/type_casting.md:7
msgid ""
"```rust\n"
"    let a_number: u32 = 15;\n"
"    let my_felt252 = 15;\n"
"\n"
"    // Since a u32 might not fit in a u8 and a u16, we need to use "
"try_into,\n"
"    // then unwrap the Option<T> type thats returned.\n"
"    let new_u8: u8 = a_number.try_into().unwrap();\n"
"    let new_u16: u16 = a_number.try_into().unwrap();\n"
"\n"
"    // since new_u32 is the of the same type (u32) as rand_number, we can "
"directly assign them,\n"
"    // or use the .into() method.\n"
"    let new_u32: u32 = a_number;\n"
"\n"
"    // When typecasting from a smaller size to an equal or larger size we "
"use the .into() method.\n"
"    // Note: u64 and u128 are larger than u32, so a u32 type will always fit "
"into them.\n"
"    let new_u64: u64 = a_number.into();\n"
"    let new_u128: u128 = a_number.into();\n"
"\n"
"    // Since a felt252 is smaller than a u256, we can use the into() method\n"
"    let new_u256: u256 = my_felt252.into();\n"
"    let new_felt252: felt252 = new_u16.into();\n"
"\n"
"    //note a usize is smaller than a felt so we use the try_into\n"
"    let new_usize: usize = my_felt252.try_into().unwrap();\n"
"```"
msgstr ""

#: src/ch01/upgradeable_contract.md:1
msgid "# Upgradeable Contract"
msgstr ""

#: src/ch01/upgradeable_contract.md:3
msgid ""
"In Starknet, contracts are divided into two parts: contract classes and "
"contract\n"
"instances. This division follows a similar concept used in object-oriented\n"
"programming languages, where we distinguish between the definition and "
"implementation\n"
"of objects."
msgstr ""

#: src/ch01/upgradeable_contract.md:8
msgid ""
"A contract class is the definition of a contract: it specifies how the "
"contract\n"
"behaves. It contains essential information like the Cairo byte code, hint\n"
"information, entry point names, and everything that defines its semantics\n"
"unambiguously."
msgstr ""

#: src/ch01/upgradeable_contract.md:13
msgid ""
"To identify different contract classes, Starknet assigns a unique identifier "
"to each\n"
"class: the class hash. A contract instance is a deployed contract that "
"corresponds to\n"
"a specific contract class. Think of it as an instance of an object in "
"languages like\n"
"Java."
msgstr ""

#: src/ch01/upgradeable_contract.md:18
msgid ""
"Each class is identified by its class hash, which is analogous to a class "
"name in an object-oriented programming language. A contract instance is a "
"deployed contract corresponding to a class."
msgstr ""

#: src/ch01/upgradeable_contract.md:20
msgid ""
"You can upgrade a deployed contract to a newer version by calling the "
"`replace_class_syscall` function. By using this function, you can update the "
"class hash associated with a deployed contract, effectively upgrading its "
"implementation. However, this will not modify the contract's storage, so all "
"the data stored in the contract will remain the same."
msgstr ""

#: src/ch01/upgradeable_contract.md:22
msgid ""
"To illustrate this concept, let's consider an example with two contracts: "
"`UpgradeableContract_V0`, and `UpgradeableContract_V1`.\n"
"Start by deploying `UpgradeableContract_V0` as the initial version. Next, "
"send a transaction that invokes the `upgrade` function, with the class hash "
"of `UpgradeableContract_V1` as parameter to upgrade the class hash of the "
"deployed contract to the `UpgradeableContract_V1` one. Then, call the "
"`version` method on the contract to see that the contract was upgraded to "
"the V1 version."
msgstr ""

#: src/ch01/upgradeable_contract.md:25
msgid ""
"```rust\n"
"use starknet::class_hash::ClassHash;\n"
"\n"
"#[starknet::interface]\n"
"trait IUpgradeableContract<TContractState> {\n"
"    fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"    fn version(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod UpgradeableContract_V0 {\n"
"    use starknet::class_hash::ClassHash;\n"
"    use starknet::SyscallResultTrait;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Upgraded: Upgraded\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Upgraded {\n"
"        implementation: ClassHash\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"\n"
"        fn version(self: @ContractState) -> u8 {\n"
"            0\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch01/upgradeable_contract.md:68
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x005300003ade5d10447d941a42d48b7141074cd8bade2b16520684896a5090ea) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch01-applications/upgradeable_contract/src/"
"upgradeable_contract_v0.cairo)."
msgstr ""

#: src/ch01/upgradeable_contract.md:71
msgid ""
"```rust\n"
"use starknet::class_hash::ClassHash;\n"
"\n"
"#[starknet::interface]\n"
"trait IUpgradeableContract<TContractState> {\n"
"    fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"    fn version(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod UpgradeableContract_V1 {\n"
"    use starknet::class_hash::ClassHash;\n"
"    use starknet::SyscallResultTrait;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Upgraded: Upgraded\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Upgraded {\n"
"        implementation: ClassHash\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"\n"
"        fn version(self: @ContractState) -> u8 {\n"
"            1\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch01/upgradeable_contract.md:114
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x017c86152badd1d665b9836571bd6b0a484f028748aa13d9b2d5d9c9192fafc6) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch01-applications/upgradeable_contract/src/"
"upgradeable_contract_v1.cairo)."
msgstr ""

#: src/ch01/simple_vault.md:1
msgid "# Simple Defi Vault"
msgstr ""

#: src/ch01/simple_vault.md:3
msgid ""
"This is the Cairo adaptation of the [Solidity by example Vault](https://"
"solidity-by-example.org/defi/vault/).\n"
"Here's how it works:"
msgstr ""

#: src/ch01/simple_vault.md:6
msgid ""
"- When a user deposits a token, the contract calculates the amount of shares "
"to mint.\n"
"\n"
"- When a user withdraws, the contract burns their shares, calculates the "
"yield, and withdraw both the yield and the initial amount of token deposited."
msgstr ""

#: src/ch01/simple_vault.md:10
msgid ""
"```rust\n"
"use starknet::{ContractAddress};\n"
"\n"
"// In order to make contract calls within our Vault,\n"
"// we need to have the interface of the remote ERC20 contract defined to "
"import the Dispatcher.\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn name(self: @TContractState) -> felt252;\n"
"    fn symbol(self: @TContractState) -> felt252;\n"
"    fn decimals(self: @TContractState) -> u8;\n"
"    fn total_supply(self: @TContractState) -> u256;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: u256) -> bool;\n"
"    fn transfer_from(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: "
"ContractAddress, amount: u256\n"
"    ) -> bool;\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ISimpleVault<TContractState> {\n"
"    fn deposit(ref self: TContractState, amount: u256);\n"
"    fn withdraw(ref self: TContractState, shares: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleVault {\n"
"    use super::{IERC20Dispatcher, IERC20DispatcherTrait};\n"
"    use starknet::{ContractAddress, get_caller_address, "
"get_contract_address};\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token: IERC20Dispatcher,\n"
"        total_supply: u256,\n"
"        balance_of: LegacyMap<ContractAddress, u256>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, token: ContractAddress) {\n"
"        self.token.write(IERC20Dispatcher { contract_address: token });\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        fn _mint(ref self: ContractState, to: ContractAddress, shares: u256) "
"{\n"
"            self.total_supply.write(self.total_supply.read() + shares);\n"
"            self.balance_of.write(to, self.balance_of.read(to) + shares);\n"
"        }\n"
"\n"
"        fn _burn(ref self: ContractState, from: ContractAddress, shares: "
"u256) {\n"
"            self.total_supply.write(self.total_supply.read() - shares);\n"
"            self.balance_of.write(from, self.balance_of.read(from) - "
"shares);\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleVault of super::ISimpleVault<ContractState> {\n"
"        fn deposit(ref self: ContractState, amount: u256) {\n"
"            // a = amount\n"
"            // B = balance of token before deposit\n"
"            // T = total supply\n"
"            // s = shares to mint\n"
"            //\n"
"            // (T + s) / T = (a + B) / B \n"
"            //\n"
"            // s = aT / B\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"\n"
"            let mut shares = 0;\n"
"            if self.total_supply.read() == 0 {\n"
"                shares = amount;\n"
"            } else {\n"
"                let balance = self.token.read().balance_of(this);\n"
"                shares = (amount * self.total_supply.read()) / balance;\n"
"            }\n"
"\n"
"            PrivateFunctions::_mint(ref self, caller, shares);\n"
"            self.token.read().transfer_from(caller, this, amount);\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, shares: u256) {\n"
"            // a = amount\n"
"            // B = balance of token before withdraw\n"
"            // T = total supply\n"
"            // s = shares to burn\n"
"            //\n"
"            // (T - s) / T = (B - a) / B \n"
"            //\n"
"            // a = sB / T\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"\n"
"            let balance = self.token.read().balance_of(this);\n"
"            let amount = (shares * balance) / self.total_supply.read();\n"
"            PrivateFunctions::_burn(ref self, caller, shares);\n"
"            self.token.read().transfer(caller, amount);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/ch01/simple_vault.md:113
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch01-applications/simple_vault/src/simple_vault.cairo)."
msgstr ""

#: src/ch01/erc20.md:1
msgid "# ERC20 Token"
msgstr ""

#: src/ch01/erc20.md:3
msgid ""
"Contracts that follow the [ERC20 Standard](https://eips.ethereum.org/EIPS/"
"eip-20) are called ERC20 tokens. They are used to represent fungible assets."
msgstr ""

#: src/ch01/erc20.md:5
msgid ""
"To create an ERC20 conctract, it must implement the following interface:"
msgstr ""

#: src/ch01/erc20.md:7
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn get_name(self: @TContractState) -> felt252;\n"
"    fn get_symbol(self: @TContractState) -> felt252;\n"
"    fn get_decimals(self: @TContractState) -> u8;\n"
"    fn get_total_supply(self: @TContractState) -> felt252;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> "
"felt252;\n"
"    fn allowance(\n"
"        self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress\n"
"    ) -> felt252;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: felt252);\n"
"    fn transfer_from(\n"
"        ref self: TContractState,\n"
"        sender: ContractAddress,\n"
"        recipient: ContractAddress,\n"
"        amount: felt252\n"
"    );\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"felt252);\n"
"    fn increase_allowance(ref self: TContractState, spender: "
"ContractAddress, added_value: felt252);\n"
"    fn decrease_allowance(\n"
"        ref self: TContractState, spender: ContractAddress, "
"subtracted_value: felt252\n"
"    );\n"
"}\n"
"```"
msgstr ""

#: src/ch01/erc20.md:33
msgid ""
"In Starknet, function names should be written in *snake_case*. This is not "
"the case in Solidity, where function names are written in *camelCase*.\n"
"The Starknet ERC20 interface is therefore slightly different from the "
"Solidity ERC20 interface."
msgstr ""

#: src/ch01/erc20.md:36
msgid "Here's an implementation of the ERC20 interface in Cairo:"
msgstr ""

#: src/ch01/erc20.md:38
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use zeroable::Zeroable;\n"
"    use starknet::get_caller_address;\n"
"    use starknet::contract_address_const;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"        symbol: felt252,\n"
"        decimals: u8,\n"
"        total_supply: felt252,\n"
"        balances: LegacyMap::<ContractAddress, felt252>,\n"
"        allowances: LegacyMap::<(ContractAddress, ContractAddress), "
"felt252>,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Transfer: Transfer,\n"
"        Approval: Approval,\n"
"    }\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Transfer {\n"
"        from: ContractAddress,\n"
"        to: ContractAddress,\n"
"        value: felt252,\n"
"    }\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Approval {\n"
"        owner: ContractAddress,\n"
"        spender: ContractAddress,\n"
"        value: felt252,\n"
"    }\n"
"\n"
"    mod Errors {\n"
"        const APPROVE_FROM_ZERO: felt252 = 'ERC20: approve from 0';\n"
"        const APPROVE_TO_ZERO: felt252 = 'ERC20: approve to 0';\n"
"        const TRANSFER_FROM_ZERO: felt252 = 'ERC20: transfer from 0';\n"
"        const TRANSFER_TO_ZERO: felt252 = 'ERC20: transfer to 0';\n"
"        const BURN_FROM_ZERO: felt252 = 'ERC20: burn from 0';\n"
"        const MINT_TO_ZERO: felt252 = 'ERC20: mint to 0';\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        recipient: ContractAddress,\n"
"        name: felt252,\n"
"        decimals: u8,\n"
"        initial_supply: felt252,\n"
"        symbol: felt252\n"
"    ) {\n"
"        self.name.write(name);\n"
"        self.symbol.write(symbol);\n"
"        self.decimals.write(decimals);\n"
"        self.mint(recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl IERC20Impl of super::IERC20<ContractState> {\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"\n"
"        fn get_symbol(self: @ContractState) -> felt252 {\n"
"            self.symbol.read()\n"
"        }\n"
"\n"
"        fn get_decimals(self: @ContractState) -> u8 {\n"
"            self.decimals.read()\n"
"        }\n"
"\n"
"        fn get_total_supply(self: @ContractState) -> felt252 {\n"
"            self.total_supply.read()\n"
"        }\n"
"\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> "
"felt252 {\n"
"            self.balances.read(account)\n"
"        }\n"
"\n"
"        fn allowance(\n"
"            self: @ContractState, owner: ContractAddress, spender: "
"ContractAddress\n"
"        ) -> felt252 {\n"
"            self.allowances.read((owner, spender))\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, "
"amount: felt252) {\n"
"            let sender = get_caller_address();\n"
"            self._transfer(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn transfer_from(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self.spend_allowance(sender, caller, amount);\n"
"            self._transfer(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn approve(ref self: ContractState, spender: ContractAddress, "
"amount: felt252) {\n"
"            let caller = get_caller_address();\n"
"            self.approve_helper(caller, spender, amount);\n"
"        }\n"
"\n"
"        fn increase_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, added_value: "
"felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) "
"+ added_value\n"
"                );\n"
"        }\n"
"\n"
"        fn decrease_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, "
"subtracted_value: felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) "
"- subtracted_value\n"
"                );\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl of InternalTrait {\n"
"        fn _transfer(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            assert(!sender.is_zero(), Errors::TRANSFER_FROM_ZERO);\n"
"            assert(!recipient.is_zero(), Errors::TRANSFER_TO_ZERO);\n"
"            self.balances.write(sender, self.balances.read(sender) - "
"amount);\n"
"            self.balances.write(recipient, self.balances.read(recipient) + "
"amount);\n"
"            self.emit(Transfer { from: sender, to: recipient, value: "
"amount });\n"
"        }\n"
"\n"
"        fn spend_allowance(\n"
"            ref self: ContractState,\n"
"            owner: ContractAddress,\n"
"            spender: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            let allowance = self.allowances.read((owner, spender));\n"
"            self.allowances.write((owner, spender), allowance - amount);\n"
"        }\n"
"\n"
"        fn approve_helper(\n"
"            ref self: ContractState,\n"
"            owner: ContractAddress,\n"
"            spender: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            assert(!spender.is_zero(), Errors::APPROVE_TO_ZERO);\n"
"            self.allowances.write((owner, spender), amount);\n"
"            self.emit(Approval { owner, spender, value: amount });\n"
"        }\n"
"\n"
"        fn mint(ref self: ContractState, recipient: ContractAddress, amount: "
"felt252) {\n"
"            assert(!recipient.is_zero(), Errors::MINT_TO_ZERO);\n"
"            let supply = self.total_supply.read() + amount; // What can go "
"wrong here?\n"
"            self.total_supply.write(supply);\n"
"            let balance = self.balances.read(recipient) + amount;\n"
"            self.balances.write(recipient, amount);\n"
"            self\n"
"                .emit(\n"
"                    Event::Transfer(\n"
"                        Transfer {\n"
"                            from: contract_address_const::<0>(), to: "
"recipient, value: amount\n"
"                        }\n"
"                    )\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch01/erc20.md:224
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch01-applications/erc20/src/token.cairo)."
msgstr ""

#: src/ch01/erc20.md:226
msgid ""
"There's several other implementations, such as the [Open Zeppelin](https://"
"docs.openzeppelin.com/contracts-cairo/0.7.0/erc20) or the [Cairo By Example]"
"(https://cairo-by-example.com/examples/erc20/) ones."
msgstr ""

#: src/ch01/erc20.md:228
msgid "<footer id=\"last-change\">Last change: 2023-10-24</footer>"
msgstr ""

#: src/ch01/constant-product-amm.md:1
msgid "# Constant Product AMM"
msgstr ""

#: src/ch01/constant-product-amm.md:3
msgid ""
"This is the Cairo adaptation of the [Solidity by example Constant Product "
"AMM](https://solidity-by-example.org/defi/constant-product-amm/)."
msgstr ""

#: src/ch01/constant-product-amm.md:5
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IConstantProductAmm<TContractState> {\n"
"    fn swap(ref self: TContractState, token_in: ContractAddress, amount_in: "
"u256) -> u256;\n"
"    fn add_liquidity(ref self: TContractState, amount0: u256, amount1: u256) "
"-> u256;\n"
"    fn remove_liquidity(ref self: TContractState, shares: u256) -> (u256, "
"u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ConstantProductAmm {\n"
"    use core::traits::Into;\n"
"    use openzeppelin::token::erc20::interface::{IERC20Dispatcher, "
"IERC20DispatcherTrait};\n"
"    use starknet::{\n"
"        ContractAddress, get_caller_address, get_contract_address, "
"contract_address_const\n"
"    };\n"
"    use integer::u256_sqrt;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token0: IERC20Dispatcher,\n"
"        token1: IERC20Dispatcher,\n"
"        reserve0: u256,\n"
"        reserve1: u256,\n"
"        total_supply: u256,\n"
"        balance_of: LegacyMap::<ContractAddress, u256>,\n"
"        // Fee 0 - 1000 (0% - 100%, 1 decimal places)\n"
"        // E.g. 3 = 0.3%\n"
"        fee: u16,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState, token0: ContractAddress, token1: "
"ContractAddress, fee: u16\n"
"    ) {\n"
"        // assert(fee <= 1000, 'fee > 1000');\n"
"        self.token0.write(IERC20Dispatcher { contract_address: token0 });\n"
"        self.token1.write(IERC20Dispatcher { contract_address: token1 });\n"
"        self.fee.write(fee);\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        fn _mint(ref self: ContractState, to: ContractAddress, amount: u256) "
"{\n"
"            self.balance_of.write(to, self.balance_of.read(to) + amount);\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"\n"
"        fn _burn(ref self: ContractState, from: ContractAddress, amount: "
"u256) {\n"
"            self.balance_of.write(from, self.balance_of.read(from) - "
"amount);\n"
"            self.total_supply.write(self.total_supply.read() - amount);\n"
"        }\n"
"\n"
"        fn _update(ref self: ContractState, reserve0: u256, reserve1: u256) "
"{\n"
"            self.reserve0.write(reserve0);\n"
"            self.reserve1.write(reserve1);\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn select_token(self: @ContractState, token: ContractAddress) -> "
"bool {\n"
"            assert(\n"
"                token == self.token0.read().contract_address\n"
"                    || token == self.token1.read().contract_address,\n"
"                'invalid token'\n"
"            );\n"
"            token == self.token0.read().contract_address\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn min(x: u256, y: u256) -> u256 {\n"
"            if (x <= y) {\n"
"                x\n"
"            } else {\n"
"                y\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ConstantProductAmm of super::IConstantProductAmm<ContractState> {\n"
"        fn swap(ref self: ContractState, token_in: ContractAddress, "
"amount_in: u256) -> u256 {\n"
"            assert(amount_in > 0, 'amount in = 0');\n"
"            let is_token0: bool = self.select_token(token_in);\n"
"\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"            let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), "
"self.reserve1.read());\n"
"            let (\n"
"                token_in, token_out, reserve_in, reserve_out\n"
"            ): (IERC20Dispatcher, IERC20Dispatcher, u256, u256) =\n"
"                if (is_token0) {\n"
"                (token0, token1, reserve0, reserve1)\n"
"            } else {\n"
"                (token1, token0, reserve1, reserve0)\n"
"            };\n"
"\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            token_in.transfer_from(caller, this, amount_in);\n"
"\n"
"            // How much dy for dx?\n"
"            // xy = k\n"
"            // (x + dx)(y - dy) = k\n"
"            // y - dy = k / (x + dx)\n"
"            // y - k / (x + dx) = dy\n"
"            // y - xy / (x + dx) = dy\n"
"            // (yx + ydx - xy) / (x + dx) = dy\n"
"            // ydx / (x + dx) = dy\n"
"\n"
"            let amount_in_with_fee = (amount_in * (1000 - self.fee.read()."
"into()) / 1000);\n"
"            let amount_out = (reserve_out * amount_in_with_fee) / "
"(reserve_in + amount_in_with_fee);\n"
"\n"
"            token_out.transfer(caller, amount_out);\n"
"\n"
"            self._update(self.token0.read().balance_of(this), self.token1."
"read().balance_of(this));\n"
"            amount_out\n"
"        }\n"
"\n"
"        fn add_liquidity(ref self: ContractState, amount0: u256, amount1: "
"u256) -> u256 {\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"\n"
"            token0.transfer_from(caller, this, amount0);\n"
"            token1.transfer_from(caller, this, amount1);\n"
"\n"
"            // How much dx, dy to add?\n"
"            //\n"
"            // xy = k\n"
"            // (x + dx)(y + dy) = k'\n"
"            //\n"
"            // No price change, before and after adding liquidity\n"
"            // x / y = (x + dx) / (y + dy)\n"
"            //\n"
"            // x(y + dy) = y(x + dx)\n"
"            // x * dy = y * dx\n"
"            //\n"
"            // x / y = dx / dy\n"
"            // dy = y / x * dx\n"
"\n"
"            let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), "
"self.reserve1.read());\n"
"            if (reserve0 > 0 || reserve1 > 0) {\n"
"                assert(reserve0 * amount1 == reserve1 * amount0, 'x / y != "
"dx / dy');\n"
"            }\n"
"\n"
"            // How much shares to mint?\n"
"            //\n"
"            // f(x, y) = value of liquidity\n"
"            // We will define f(x, y) = sqrt(xy)\n"
"            //\n"
"            // L0 = f(x, y)\n"
"            // L1 = f(x + dx, y + dy)\n"
"            // T = total shares\n"
"            // s = shares to mint\n"
"            //\n"
"            // Total shares should increase proportional to increase in "
"liquidity\n"
"            // L1 / L0 = (T + s) / T\n"
"            //\n"
"            // L1 * T = L0 * (T + s)\n"
"            //\n"
"            // (L1 - L0) * T / L0 = s\n"
"\n"
"            // Claim\n"
"            // (L1 - L0) / L0 = dx / x = dy / y\n"
"            //\n"
"            // Proof\n"
"            // --- Equation 1 ---\n"
"            // (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / "
"sqrt(xy)\n"
"            //\n"
"            // dx / dy = x / y so replace dy = dx * y / x\n"
"            //\n"
"            // --- Equation 2 ---\n"
"            // Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / "
"sqrt(xy)\n"
"            //\n"
"            // Multiply by sqrt(x) / sqrt(x)\n"
"            // Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / "
"sqrt(x^2y)\n"
"            //            = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
"(sqrt(y)sqrt(x^2))\n"
"            // sqrt(y) on top and bottom cancels out\n"
"            //\n"
"            // --- Equation 3 ---\n"
"            // Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
"(sqrt(x^2)\n"
"            // = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n"
"            // = ((x + dx) - x) / x\n"
"            // = dx / x\n"
"            // Since dx / dy = x / y,\n"
"            // dx / x = dy / y\n"
"            //\n"
"            // Finally\n"
"            // (L1 - L0) / L0 = dx / x = dy / y\n"
"\n"
"            let total_supply = self.total_supply.read();\n"
"            let shares = if (total_supply == 0) {\n"
"                u256_sqrt(amount0 * amount1).into()\n"
"            } else {\n"
"                PrivateFunctions::min(\n"
"                    amount0 * total_supply / reserve0, amount1 * "
"total_supply / reserve1\n"
"                )\n"
"            };\n"
"            assert(shares > 0, 'shares = 0');\n"
"            self._mint(caller, shares);\n"
"\n"
"            self._update(self.token0.read().balance_of(this), self.token1."
"read().balance_of(this));\n"
"            shares\n"
"        }\n"
"\n"
"        fn remove_liquidity(ref self: ContractState, shares: u256) -> (u256, "
"u256) {\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"\n"
"            // Claim\n"
"            // dx, dy = amount of liquidity to remove\n"
"            // dx = s / T * x\n"
"            // dy = s / T * y\n"
"            //\n"
"            // Proof\n"
"            // Let's find dx, dy such that\n"
"            // v / L = s / T\n"
"            //\n"
"            // where\n"
"            // v = f(dx, dy) = sqrt(dxdy)\n"
"            // L = total liquidity = sqrt(xy)\n"
"            // s = shares\n"
"            // T = total supply\n"
"            //\n"
"            // --- Equation 1 ---\n"
"            // v = s / T * L\n"
"            // sqrt(dxdy) = s / T * sqrt(xy)\n"
"            //\n"
"            // Amount of liquidity to remove must not change price so\n"
"            // dx / dy = x / y\n"
"            //\n"
"            // replace dy = dx * y / x\n"
"            // sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n"
"            //\n"
"            // Divide both sides of Equation 1 with sqrt(y / x)\n"
"            // dx = s / T * sqrt(xy) / sqrt(y / x)\n"
"            // = s / T * sqrt(x^2) = s / T * x\n"
"            //\n"
"            // Likewise\n"
"            // dy = s / T * y\n"
"\n"
"            // bal0 >= reserve0\n"
"            // bal1 >= reserve1\n"
"            let (bal0, bal1): (u256, u256) = (token0.balance_of(this), "
"token1.balance_of(this));\n"
"\n"
"            let total_supply = self.total_supply.read();\n"
"            let (amount0, amount1): (u256, u256) = (\n"
"                (shares * bal0) / total_supply, (shares * bal1) / "
"total_supply\n"
"            );\n"
"            assert(amount0 > 0 && amount1 > 0, 'amount0 or amount1 = 0');\n"
"\n"
"            self._burn(caller, shares);\n"
"            self._update(bal0 - amount0, bal1 - amount1);\n"
"\n"
"            token0.transfer(caller, amount0);\n"
"            token1.transfer(caller, amount1);\n"
"            (amount0, amount1)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch01/constant-product-amm.md:274
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch01-applications/constant_product_amm/src/"
"constant_product_amm.cairo)."
msgstr ""

#: src/ch02/write_to_any_slot.md:1
msgid "# Writing to any storage slot"
msgstr ""

#: src/ch02/write_to_any_slot.md:3
msgid ""
"On Starknet, a contract's storage is a map with 2^251 slots, where each slot "
"is a felt which is initialized to 0.\n"
"The address of storage variables is computed at compile time using the "
"formula: `storage variable address := pedersen(keccak(variable name), "
"keys)`. Interactions with storage variables are commonly performed using the "
"`self.var.read()` and `self.var.write()` functions."
msgstr ""

#: src/ch02/write_to_any_slot.md:6
msgid ""
"Nevertheless, we can use the `storage_write_syscall` and "
"`storage_read_syscall` syscalls, to write to and read from any storage "
"slot.\n"
"This is useful when writing to storage variables that are not known at "
"compile time, or to ensure that even if the contract is upgraded and the "
"computation method of storage variable addresses changes, they remain "
"accessible."
msgstr ""

#: src/ch02/write_to_any_slot.md:9
msgid ""
"In the following example, we use the Poseidon hash function to compute the "
"address of a storage variable. Poseidon is a ZK-friendly hash function that "
"is cheaper and faster than Pedersen, making it an excellent choice for "
"onchain computations. Once the address is computed, we use the storage "
"syscalls to interact with it."
msgstr ""

#: src/ch02/write_to_any_slot.md:11
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IWriteToAnySlots<TContractState> {\n"
"    fn write_slot(ref self: TContractState, value: u32);\n"
"    fn read_slot(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod WriteToAnySlot {\n"
"    use starknet::syscalls::{storage_read_syscall, storage_write_syscall};\n"
"    use starknet::SyscallResultTrait;\n"
"    use poseidon::poseidon_hash_span;\n"
"    use starknet::storage_access::Felt252TryIntoStorageAddress;\n"
"    use starknet::StorageAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    const SLOT_NAME: felt252 = 'test_slot';\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl WriteToAnySlot of super::IWriteToAnySlots<ContractState> {\n"
"        fn write_slot(ref self: ContractState, value: u32) {\n"
"            storage_write_syscall(0, get_address_from_name(SLOT_NAME), value."
"into());\n"
"        }\n"
"\n"
"        fn read_slot(self: @ContractState) -> u32 {\n"
"            storage_read_syscall(0, get_address_from_name(SLOT_NAME))\n"
"                .unwrap_syscall()\n"
"                .try_into()\n"
"                .unwrap()\n"
"        }\n"
"    }\n"
"    fn get_address_from_name(variable_name: felt252) -> StorageAddress {\n"
"        let mut data: Array<felt252> = ArrayTrait::new();\n"
"        data.append(variable_name);\n"
"        let hashed_name: felt252 = poseidon_hash_span(data.span());\n"
"        let MASK_250: u256 = "
"0x03ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n"
"        // By taking the 250 least significant bits of the hash output, we "
"get a valid 250bits storage address.\n"
"        let result: felt252 = (hashed_name.into() & MASK_250).try_into()."
"unwrap();\n"
"        let result: StorageAddress = result.try_into().unwrap();\n"
"        result\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/write_to_any_slot.md:56
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x033943CB781A4E63C9dcE0A1A09eAa3b617AA43CC61637C08c043a67f3fe0087) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch02-advanced-concepts/write_to_any_slot/src/contract."
"cairo)."
msgstr ""

#: src/ch02/storing_arrays.md:1
msgid "# Storing Arrays"
msgstr ""

#: src/ch02/storing_arrays.md:3
msgid ""
"On Starknet, complex values (e.g., tuples or structs), are stored in a "
"continuous segment starting from the address of the storage variable. There "
"is a 256 field elements limitation to the maximal size of a complex storage "
"value, meaning that to store arrays of more than 255 elements in storage, we "
"would need to split it into segments of size `n <= 255` and store these "
"segments in multiple storage addresses. There is currently no native support "
"for storing arrays in Cairo, so you will need to write your own "
"implementation of the `Store` trait for the type of array you wish to store."
msgstr ""

#: src/ch02/storing_arrays.md:5
msgid ""
"> Note: While storing arrays in storage is possible, it is not always "
"recommended, as the read and write operations can get very costly. For "
"example, reading an array of size `n` requires `n` storage reads, and "
"writing to an array of size `n` requires `n` storage writes. If you only "
"need to access a single element of the array at a time, it is recommended to "
"use a `LegacyMap` and store the length in another variable instead."
msgstr ""

#: src/ch02/storing_arrays.md:7
msgid ""
"The following example demonstrates how to write a simple implementation of "
"the `StorageAccess` trait for the `Array<felt252>` type, allowing us to "
"store arrays of up to 255 `felt252` elements."
msgstr ""

#: src/ch02/storing_arrays.md:9
msgid ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> "
"SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: "
"Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"\n"
"        // Read the stored array's length. If the length is superior to 255, "
"the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, "
"offset)\n"
"            .expect('Storage Span too large');\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the "
"array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, "
"base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"\n"
"        // Return the array.\n"
"        Result::Ok(arr)\n"
"    }\n"
"\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut "
"value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot.\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too "
"large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, "
"offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None(_) => { break Result::Ok(()); }\n"
"            };\n"
"        }\n"
"    }\n"
"\n"
"    fn size() -> u8 {\n"
"        255 * Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/storing_arrays.md:73
msgid ""
"You can then import this implementation in your contract and use it to store "
"arrays in storage:"
msgstr ""

#: src/ch02/storing_arrays.md:75
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStoreArrayContract<TContractState> {\n"
"    fn store_array(ref self: TContractState, arr: Array<felt252>);\n"
"    fn read_array(self: @TContractState) -> Array<felt252>;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod StoreArrayContract {\n"
"    use super::StoreFelt252Array;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        arr: Array<felt252>\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StoreArrayImpl of super::IStoreArrayContract<ContractState> {\n"
"        fn store_array(ref self: ContractState, arr: Array<felt252>) {\n"
"            self.arr.write(arr);\n"
"        }\n"
"\n"
"        fn read_array(self: @ContractState) -> Array<felt252> {\n"
"            self.arr.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/storing_arrays.md:103
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x008F8069a3Fcd7691Db46Dc3b6F9D2C0436f9200E861330957Fd780A3595da86) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch02-advanced-concepts/storing_arrays/src/contract.cairo)."
msgstr ""

#: src/ch02/struct-mapping-key.md:1
msgid "# Structs as mapping keys"
msgstr ""

#: src/ch02/struct-mapping-key.md:3
msgid ""
"In order to use structs as mapping keys, you can use `#[derive(Hash)]` on "
"the struct definition. This will automatically generate a hash function for "
"the struct that can be used to represent the struct as a key in a "
"`LegacyMap`."
msgstr ""

#: src/ch02/struct-mapping-key.md:5
msgid ""
"Consider the following example in which we would like to use an object of\n"
"type `Pet` as a key in a `LegacyMap`. The `Pet` struct has three fields: "
"`name`, `age` and `owner`. We consider that the combination of these three "
"fields uniquely identifies a pet."
msgstr ""

#: src/ch02/struct-mapping-key.md:8
msgid ""
"```rust\n"
"#[derive(Copy, Drop, Serde, Hash)]\n"
"struct Pet {\n"
"    name: felt252,\n"
"    age: u8,\n"
"    owner: felt252,\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IPetRegistry<TContractState> {\n"
"    fn register_pet(ref self: TContractState, key: Pet, timestamp: u64);\n"
"    fn get_registration_date(self: @TContractState, key: Pet) -> u64;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod PetRegistry {\n"
"    use hash::{HashStateTrait, Hash};\n"
"    use super::Pet;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        registration_time: LegacyMap::<Pet, u64>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl PetRegistry of super::IPetRegistry<ContractState> {\n"
"        fn register_pet(ref self: ContractState, key: Pet, timestamp: u64) "
"{\n"
"            self.registration_time.write(key, timestamp);\n"
"        }\n"
"\n"
"        fn get_registration_date(self: @ContractState, key: Pet) -> u64 {\n"
"            self.registration_time.read(key)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/struct-mapping-key.md:45
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch02-advanced-concepts/struct_as_mapping_key/src/contract."
"cairo)."
msgstr ""

#: src/ch02/hash-solidity-compatible.md:1
msgid "# Hash Solidity Compatible"
msgstr ""

#: src/ch02/hash-solidity-compatible.md:3
msgid ""
"This contract demonstrates Keccak hashing in Cairo to match Solidity's "
"keccak256. While both use Keccak, their endianness differs: Cairo is little-"
"endian, Solidity big-endian. The contract achieves compatibility by hashing "
"in big-endian using `keccak_u256s_be_inputs`, and reversing the bytes of the "
"result with `u128_byte_reverse`."
msgstr ""

#: src/ch02/hash-solidity-compatible.md:7
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISolidityHashExample<TContractState> {\n"
"    fn hash_data(ref self: TContractState, input_data: Span<u256>) -> u256;\n"
"}\n"
"\n"
"\n"
"#[starknet::contract]\n"
"mod SolidityHashExample {\n"
"    use keccak::{keccak_u256s_be_inputs};\n"
"    use array::Span;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SolidityHashExample of super::ISolidityHashExample<ContractState> "
"{\n"
"        fn hash_data(ref self: ContractState, input_data: Span<u256>) -> "
"u256 {\n"
"            let hashed = keccak_u256s_be_inputs(input_data);\n"
"\n"
"            // Split the hashed value into two 128-bit segments\n"
"            let low: u128 = hashed.low;\n"
"            let high: u128 = hashed.high;\n"
"\n"
"            // Reverse each 128-bit segment\n"
"            let reversed_low = integer::u128_byte_reverse(low);\n"
"            let reversed_high = integer::u128_byte_reverse(high);\n"
"\n"
"            // Reverse merge the reversed segments back into a u256 value\n"
"            let compatible_hash = u256 { low: reversed_high, high: "
"reversed_low };\n"
"\n"
"            compatible_hash\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/hash-solidity-compatible.md:44
msgid ""
"Play with the contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch02-advanced-concepts/hash_solidity_compatible/src/"
"contract.cairo)."
msgstr ""

#: src/ch02/hash-solidity-compatible.md:46
msgid "<footer id=\"last-change\">Last change: 2023-11-21</footer>"
msgstr ""

#: src/ch02/optimisations/optimisations.md:1
msgid "# Optimisations "
msgstr ""

#: src/ch02/optimisations/optimisations.md:3
msgid "A collection of optimisation patterns to save gas and steps."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:1
msgid "# Storage optimisation "
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:3
msgid ""
"A smart contract has a limited amount of **storage slots**. Each slot can "
"store a single `felt252` value.\n"
"Writing to a storage slot has a cost, so we want to use as few storage slots "
"as possible."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:6
msgid ""
"In Cairo, every type is derived from the `felt252` type, which uses 252 bits "
"to store a value.\n"
"This design is quite simple, but it does have a drawback: it is not storage "
"efficient. For example, if we want to store a `u8` value, we need to use an "
"entire slot, even though we only need 8 bits."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:9
msgid "## Packing"
msgstr "## 打包"

#: src/ch02/optimisations/store_using_packing.md:11
msgid ""
"When storing multiple values, we can use a technique called **packing**. "
"Packing is a technique that allows us to store multiple values in a single "
"felt value. This is done by using the bits of the felt value to store "
"multiple values."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:13
msgid ""
"For example, if we want to store two `u8` values, we can use the first 8 "
"bits of the felt value to store the first `u8` value, and the last 8 bits to "
"store the second `u8` value. This way, we can store two `u8` values in a "
"single felt value."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:15
msgid ""
"Cairo provides a built-in store using packing that you can use with the "
"`StorePacking` trait."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:17
msgid ""
"```rust\n"
"trait StorePacking<T, PackedT> {\n"
"    fn pack(value: T) -> PackedT;\n"
"    fn unpack(value: PackedT) -> T;\n"
"}\n"
"```"
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:24
msgid ""
"This allows to store the type `T` by first packing it into the type "
"`PackedT` with the `pack` function, and then storing the `PackedT` value "
"with it's `Store` implementation. When reading the value, we first retrieve "
"the `PackedT` value, and then unpack it into the type `T` using the `unpack` "
"function."
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:26
msgid ""
"Here's an example of storing a `Time` struct with two `u8` values using the "
"`StorePacking` trait:"
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:28
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ITime<TContractState> {\n"
"    fn set(ref self: TContractState, value: TimeContract::Time);\n"
"    fn get(self: @TContractState) -> TimeContract::Time;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod TimeContract {\n"
"    use starknet::storage_access::StorePacking;\n"
"    use integer::{\n"
"        U8IntoFelt252, Felt252TryIntoU16, U16DivRem, u16_as_non_zero, "
"U16IntoFelt252,\n"
"        Felt252TryIntoU8\n"
"    };\n"
"    use traits::{Into, TryInto, DivRem};\n"
"    use option::OptionTrait;\n"
"    use serde::Serde;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        time: Time\n"
"    }\n"
"\n"
"    #[derive(Copy, Serde, Drop)]\n"
"    struct Time {\n"
"        hour: u8,\n"
"        minute: u8\n"
"    }\n"
"\n"
"    impl TimePackable of StorePacking<Time, felt252> {\n"
"        fn pack(value: Time) -> felt252 {\n"
"            let msb: felt252 = 256 * value.hour.into();\n"
"            let lsb: felt252 = value.minute.into();\n"
"            return msb + lsb;\n"
"        }\n"
"        fn unpack(value: felt252) -> Time {\n"
"            let value: u16 = value.try_into().unwrap();\n"
"            let (q, r) = U16DivRem::div_rem(value, u16_as_non_zero(256));\n"
"            let hour: u8 = Into::<u16, felt252>::into(q).try_into()."
"unwrap();\n"
"            let minute: u8 = Into::<u16, felt252>::into(r).try_into()."
"unwrap();\n"
"            return Time { hour, minute };\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl TimeContract of super::ITime<ContractState> {\n"
"        fn set(ref self: ContractState, value: Time) {\n"
"            // This will call the pack method of the TimePackable trait\n"
"            // and store the resulting felt252\n"
"            self.time.write(value);\n"
"        }\n"
"        fn get(self: @ContractState) -> Time {\n"
"            // This will read the felt252 value from storage\n"
"            // and return the result of the unpack method of the "
"TimePackable trait\n"
"            return self.time.read();\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/optimisations/store_using_packing.md:88
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet-cairo1-compiler&url=https://github.com/NethermindEth/"
"StarknetByExample/blob/main/listings/ch02-advanced-concepts/"
"store_using_packing/src/contract.cairo)."
msgstr ""

#: src/ch02/list.md:1
msgid "# List"
msgstr "# 列表"

#: src/ch02/list.md:3
msgid ""
"By default, there is no list type supported in Cairo, but you can use "
"Alexandria. You can refer to the [Alexandria documentation](https://github."
"com/keep-starknet-strange/alexandria/tree/main/src/storage) for more details."
msgstr ""

#: src/ch02/list.md:5
msgid "## What is `List`?"
msgstr ""

#: src/ch02/list.md:7
msgid "An ordered sequence of values that can be used in Starknet storage:"
msgstr ""

#: src/ch02/list.md:9
msgid ""
"```rust\n"
"#[storage]\n"
"stuct Storage {\n"
"  amounts: List<u128>\n"
"}\n"
"```"
msgstr ""

#: src/ch02/list.md:16
msgid "### Interface"
msgstr "### 接口"

#: src/ch02/list.md:18
msgid ""
"```rust\n"
"trait ListTrait<T> {\n"
"  fn len(self: @List<T>) -> u32;\n"
"  fn is_empty(self: @List<T>) -> bool;\n"
"  fn append(ref self: List<T>, value: T) -> u32;\n"
"  fn get(self: @List<T>, index: u32) -> Option<T>;\n"
"  fn set(ref self: List<T>, index: u32, value: T);\n"
"  fn pop_front(ref self: List<T>) -> Option<T>;\n"
"  fn array(self: @List<T>) -> Array<T>;\n"
"}\n"
"```"
msgstr ""

#: src/ch02/list.md:30
msgid ""
"`List` also implements `IndexView` so you can use the familiar bracket "
"notation to access its members:"
msgstr ""

#: src/ch02/list.md:32
msgid ""
"```rust\n"
"let second = self.amounts.read()[1];\n"
"```"
msgstr ""

#: src/ch02/list.md:36
msgid ""
"Note that unlike `get`, using this bracket notation panics when accessing an "
"out of bounds index."
msgstr ""

#: src/ch02/list.md:38
msgid "### Support for custom types"
msgstr ""

#: src/ch02/list.md:40
msgid ""
"`List` supports most of the corelib types out of the box. If you want to "
"store a your own custom type in a `List`, it has to implement the `Store` "
"trait. You can have the compiler derive it for you using the "
"`#[derive(starknet::Store)]` attribute."
msgstr ""

#: src/ch02/list.md:42
msgid "### Caveats"
msgstr ""

#: src/ch02/list.md:44
msgid "There are two idiosyncacies you should be aware of when using `List`"
msgstr ""

#: src/ch02/list.md:46
msgid ""
"1. The `append` operation costs 2 storage writes - one for the value itself "
"and another one for updating the List's length\n"
"2. Due to a compiler limitation, it is not possible to use mutating "
"operations with a single inline statement. For example, `self.amounts.read()."
"append(42);` will not work. You have to do it in 2 steps:"
msgstr ""

#: src/ch02/list.md:49
msgid ""
"```rust\n"
"let mut amounts = self.amounts.read();\n"
"amounts.append(42);\n"
"```"
msgstr ""

#: src/ch02/list.md:54
msgid "### Dependencies"
msgstr "### 依赖关系"

#: src/ch02/list.md:56
msgid "Update your project dependencies by in the `Scarb.toml` file:"
msgstr ""

#: src/ch02/list.md:57
msgid ""
"```rust\n"
"[dependencies]\n"
"(...)\n"
"alexandria_storage = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\" }\n"
"```"
msgstr ""

#: src/ch02/list.md:63
msgid ""
"For example, let's use `List` to create a contract that tracks a list of "
"amounts and tasks:"
msgstr ""

#: src/ch02/list.md:65
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IListExample<TContractState> {\n"
"    fn add_in_amount(ref self: TContractState, number: u128);\n"
"    fn add_in_task(ref self: TContractState, description: felt252, status: "
"felt252);\n"
"    fn is_empty_list(self: @TContractState) -> bool;\n"
"    fn list_length(self: @TContractState) -> u32;\n"
"    fn get_from_index(self: @TContractState, index: u32) -> u128;\n"
"    fn set_from_index(ref self: TContractState, index: u32, number: u128);\n"
"    fn pop_front_list(ref self: TContractState);\n"
"    fn array_conversion(self: @TContractState) -> Array<u128>;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ListExample {\n"
"    use alexandria_storage::list::{List, ListTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        amount: List<u128>,\n"
"        tasks: List<Task>\n"
"    }\n"
"\n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Task {\n"
"        description: felt252,\n"
"        status: felt252\n"
"    }\n"
"\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ListExample of super::IListExample<ContractState> {\n"
"        fn add_in_amount(ref self: ContractState, number: u128) {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.append(number);\n"
"        }\n"
"\n"
"        fn add_in_task(ref self: ContractState, description: felt252, "
"status: felt252) {\n"
"            let new_task = Task { description: description, status: "
"status };\n"
"            let mut current_tasks_list = self.tasks.read();\n"
"            current_tasks_list.append(new_task);\n"
"        }\n"
"\n"
"        fn is_empty_list(self: @ContractState) -> bool {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.is_empty()\n"
"        }\n"
"\n"
"        fn list_length(self: @ContractState) -> u32 {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.len()\n"
"        }\n"
"\n"
"        fn get_from_index(self: @ContractState, index: u32) -> u128 {\n"
"            self.amount.read()[index]\n"
"        }\n"
"\n"
"        fn set_from_index(ref self: ContractState, index: u32, number: u128) "
"{\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.set(index, number);\n"
"        }\n"
"\n"
"        fn pop_front_list(ref self: ContractState) {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.pop_front();\n"
"        }\n"
"\n"
"        fn array_conversion(self: @ContractState) -> Array<u128> {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.array()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/ch02/list.md:139
msgid "<footer id=\"last-change\">Last change: 2023-11-27</footer>"
msgstr ""
