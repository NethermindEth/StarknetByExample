msgid ""
msgstr ""
"Project-Id-Version: Starknet by Example\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2024-01-09 11:10+0000\n"
"Last-Translator: Nadai <nadai@proton.me>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.4.2\n"
"X-Poedit-Bookmarks: -1,-1,-1,78,-1,-1,-1,-1,-1,-1\n"

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr "Introducción"

#: src/SUMMARY.md:7
msgid "Getting Started"
msgstr "Primeros Pasos"

#: src/SUMMARY.md:10
msgid "Basics of a Starknet contract"
msgstr "Conceptos Básicos de un Contrato de Starknet"

#: src/SUMMARY.md:11
msgid "Storage"
msgstr "Almacenamiento"

#: src/SUMMARY.md:12
msgid "Constructor"
msgstr "Constructor"

#: src/SUMMARY.md:13
msgid "Variables"
msgstr "Variables"

#: src/SUMMARY.md:14
msgid "Visibility and Mutability"
msgstr "Visibilidad y Mutabilidad"

#: src/SUMMARY.md:15
msgid "Counter Example"
msgstr "Ejemplo de Counter"

#: src/SUMMARY.md:16
msgid "Mappings"
msgstr "Mapas"

#: src/SUMMARY.md:17
msgid "Errors"
msgstr "Errores"

#: src/SUMMARY.md:18
msgid "Events"
msgstr "Eventos"

#: src/SUMMARY.md:19
msgid "Syscalls"
msgstr "Llamadas al Sistema"

#: src/SUMMARY.md:20
msgid "Storing Custom Types"
msgstr "Almacenamiento de Tipos Personalizados"

#: src/SUMMARY.md:21
msgid "Custom types in entrypoints"
msgstr "Tipos personalizados en entrypoints"

#: src/SUMMARY.md:22
msgid "Documentation"
msgstr "Documentación"

#: src/SUMMARY.md:23
msgid "Deploy and interact with contracts"
msgstr "Desplegar contratos e interactuar con ellos"

#: src/SUMMARY.md:24
msgid "Contract interfaces and Traits generation"
msgstr "Interfaces de Contratos y generación de Traits"

#: src/SUMMARY.md:25
msgid "Calling other contracts"
msgstr "Llamar a otros contratos"

#: src/SUMMARY.md:26
msgid "Factory pattern"
msgstr "Patrón de la Factory"

#: src/SUMMARY.md:27
msgid "Testing contracts"
msgstr "Contratos de Testing"

#: src/SUMMARY.md:28
msgid "Cairo cheatsheet"
msgstr "Hoja de ruta de Cairo"

#: src/SUMMARY.md:29
msgid "Felt"
msgstr "Felt"

#: src/SUMMARY.md:30
msgid "LegacyMap"
msgstr "LegacyMap"

#: src/SUMMARY.md:31
msgid "Arrays"
msgstr "Arrays"

#: src/SUMMARY.md:32
msgid "Loop"
msgstr "Loop"

#: src/SUMMARY.md:33
msgid "Match"
msgstr "Match"

#: src/SUMMARY.md:34
msgid "Tuples"
msgstr "Tuples"

#: src/SUMMARY.md:35
msgid "Struct"
msgstr "Struct"

#: src/SUMMARY.md:36
msgid "Type casting"
msgstr "Conversión de Tipos"

#: src/SUMMARY.md:38
msgid "Components"
msgstr "Componentes"

#: src/SUMMARY.md:40
msgid "Components How-To"
msgstr "Cómo hacer Componentes"

#: src/SUMMARY.md:41
msgid "Components Dependencies"
msgstr "Componentes Dependencias"

#: src/SUMMARY.md:42
msgid "Storage Collisions"
msgstr "Colisiones de Almacenamiento"

#: src/SUMMARY.md:43
msgid "Ownable"
msgstr "Ownable"

#: src/SUMMARY.md:47
msgid "Applications"
msgstr "Aplicaciones"

#: src/SUMMARY.md:49
msgid "Upgradeable Contract"
msgstr "Contratos Actualizables"

#: src/SUMMARY.md:50
msgid "Defi Vault"
msgstr "Defi Vault"

#: src/SUMMARY.md:51
msgid "ERC20 Token"
msgstr "Token ERC20"

#: src/SUMMARY.md:52
msgid "Constant Product AMM"
msgstr "AMM de Producto Constante"

#: src/SUMMARY.md:56
msgid "Advanced concepts"
msgstr "Conceptos Avanzados"

#: src/SUMMARY.md:58
msgid "Writing to any storage slot"
msgstr "Escribir en cualquier ranura de almacenamiento"

#: src/SUMMARY.md:59
msgid "Storing Arrays"
msgstr "Almacenamiento de Arrays"

#: src/SUMMARY.md:60
msgid "Struct as mapping key"
msgstr "Estructura como mapping key"

#: src/SUMMARY.md:61
msgid "Hashing"
msgstr "Hashing"

#: src/SUMMARY.md:62
msgid "Hash Solidity Compatible"
msgstr "Hash compatible con Solidity"

#: src/SUMMARY.md:63
msgid "Optimisations"
msgstr "Optimizaciones"

#: src/SUMMARY.md:64
msgid "Storage Optimisations"
msgstr "Optimizaciones de Almacenamiento"

#: src/SUMMARY.md:65
msgid "List"
msgstr "Lista"

#: src/starknet-by-example.md:1
msgid "# Starknet by Example"
msgstr "# Starknet by Example"

#: src/starknet-by-example.md:3
msgid ""
"Starknet By Example is a collection of examples of how to use the Cairo "
"programming language to create smart contracts on Starknet."
msgstr ""
"Starknet By Example es una colección de ejemplos de cómo utilizar el "
"lenguaje de programación de Cairo para crear smart contracts en Starknet."

#: src/starknet-by-example.md:5
msgid ""
"Starknet is a permissionless Validity-Rollup that supports general "
"computation. It is currently used as an Ethereum layer-2. Starknet use the "
"STARK cryptographic proof system to ensure high safety and scalability."
msgstr ""
"Starknet es un Validity-Rollup sin permiso que admite el cálculo general. "
"Actualmente se utiliza como capa 2 de Ethereum. Starknet utiliza el sistema "
"de prueba criptográfica STARK para garantizar una alta seguridad y "
"escalabilidad."

#: src/starknet-by-example.md:7
msgid ""
"Starknet smart contracts are written in the Cairo language. Cairo is a "
"Turing-complete programming language designed to write provable programs, "
"abstracting the zk-STARK proof system away from the programmer."
msgstr ""
"Los smart contracts de Starknet están escritos en el idioma de Cairo. Cairo "
"es un lenguaje de programación completo de Turing diseñado para escribir "
"programas demostrables, abstrayendo el sistema de prueba zk-STARK del "
"programador."

#: src/starknet-by-example.md:9
msgid "The current version of this book use:"
msgstr "La versión actual de este libro usa:"

#: src/starknet-by-example.md:10
msgid ""
"```\n"
"scarb 2.3.1\n"
"```"
msgstr ""
"```\n"
"scarb 2.3.1\n"
"```"

#: src/starknet-by-example.md:14
msgid ""
"> ⚠️ The examples have not been audited and are not intended for production "
"use.\n"
"> The authors are not responsible for any damages caused by the use of the "
"code provided in this book."
msgstr ""
"> ⚠️ Los ejemplos no han sido auditados y no están pensados para su uso en "
"producción.\n"
"> Los autores no se hacen responsables de los daños causados por el uso del "
"código proporcionado en este libro."

#: src/starknet-by-example.md:17
msgid "## For whom is this for?"
msgstr "## ¿Para quién es esto?"

#: src/starknet-by-example.md:19
msgid ""
"Starknet By Example is for anyone who wants to quickly learn how to write "
"smart contracts on Starknet using Cairo with some technical background in "
"programming and blockchain."
msgstr ""
"Starknet By Example es para cualquiera que quiera aprender rápidamente cómo "
"escribir contratos inteligentes en Starknet usando Cairo con cierta "
"experiencia técnica en programación y blockchain."

#: src/starknet-by-example.md:21
msgid ""
"The first chapters will give you a basic understanding of the Cairo "
"programming language and how to write, deploy and use smart contracts on "
"Starknet.\n"
"The later chapters will cover more advanced topics and show you how to write "
"more complex smart contracts."
msgstr ""
"Los primeros capítulos le brindarán una comprensión básica del lenguaje de "
"programación Cairo y cómo escribir, implementar y utilizar contratos "
"inteligentes en Starknet. Los capítulos posteriores cubrirán temas más "
"avanzados y le mostrarán cómo escribir contratos inteligentes más complejos."

#: src/starknet-by-example.md:24
msgid "## Further reading"
msgstr "## Otras lecturas"

#: src/starknet-by-example.md:26
msgid ""
"If you want to learn more about the Cairo programming language, you can read "
"the [Cairo Book](https://book.cairo-lang.org).\n"
"If you want to learn more about Starknet, you can read the [Starknet "
"documentation](https://docs.starknet.io/) and the [Starknet Book](https://"
"book.starknet.io)."
msgstr ""
"Si desea obtener más información sobre el lenguaje de programación de Cairo, "
"puede leer el [Cairo Book](https://book.cairo-lang.org). Si desea obtener "
"más información sobre Starknet, puede leer la [Documentación de Starknet]"
"(https://docs.starknet.io/) y el [Starknet Book](https://book.starknet.io)."

#: src/starknet-by-example.md:29
msgid ""
"For more resources, check [Awesome Starknet](https://github.com/keep-"
"starknet-strange/awesome-starknet)."
msgstr ""
"Para obtener más recursos, consulte [Awesome Starknet](https://github.com/"
"keep-starknet-strange/awesome-starknet)."

#: src/starknet-by-example.md:31 src/ch00/basics/storage.md:34
#: src/ch00/basics/constructor.md:27 src/ch00/basics/variables.md:126
#: src/ch00/basics/visibility-mutability.md:75 src/ch00/basics/counter.md:56
#: src/ch00/basics/errors.md:139 src/ch00/basics/storing-custom-types.md:39
#: src/ch00/basics/custom-types-in-entrypoints.md:39
#: src/ch00/interacting/interfaces-traits.md:129
#: src/ch00/interacting/calling_other_contracts.md:69
#: src/ch00/cairo_cheatsheet/felt.md:15 src/ch00/cairo_cheatsheet/mapping.md:58
#: src/ch00/cairo_cheatsheet/arrays.md:42 src/ch00/cairo_cheatsheet/loop.md:23
#: src/ch00/cairo_cheatsheet/match.md:59 src/ch00/cairo_cheatsheet/tuples.md:18
#: src/ch00/cairo_cheatsheet/struct.md:15
#: src/ch00/cairo_cheatsheet/type_casting.md:33 src/ch01/simple_vault.md:114
#: src/ch01/erc20.md:228 src/ch01/constant-product-amm.md:275
#: src/ch02/write_to_any_slot.md:58 src/ch02/storing_arrays.md:105
#: src/ch02/struct-mapping-key.md:46 src/ch02/hash-solidity-compatible.md:46
#: src/ch02/optimisations/store_using_packing.md:90 src/ch02/list.md:139
msgid "<footer id=\"last-change\">Last change: 2023-12-07</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-12-07</footer>"

#: src/ch00/basics/introduction.md:1
msgid "# Basics of Smart Contracts in Cairo"
msgstr "# Conceptos básicos de los Smart Contracts en Cairo"

#: src/ch00/basics/introduction.md:3
msgid ""
"The following chapters will introduce you to Starknet smart contracts and "
"how to write them in Cairo."
msgstr ""
"Los siguientes capítulos le presentarán los smart contracts de Starknet y "
"cómo escribirlos en Cairo."

#: src/ch00/basics/introduction.md:5 src/ch02/optimisations/optimisations.md:5
msgid "<footer id=\"last-change\">Last change: 2023-10-12</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-10-12</footer>"

#: src/ch00/basics/storage.md:1
msgid "# Storage"
msgstr "# Almacenamiento"

#: src/ch00/basics/storage.md:3
msgid "Here's the most minimal contract you can write in Cairo:"
msgstr "Este es el contrato mínimo que puedes redactar en Cairo:"

#: src/ch00/basics/storage.md:5
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"}\n"
"```"

#: src/ch00/basics/storage.md:13
msgid ""
"Storage is a struct annoted with `#[storage]`. Every contract must have one "
"and only one storage.\n"
"It's a key-value store, where each key will be mapped to a storage address "
"of the contract's storage space."
msgstr ""
"El almacenamiento es una estructura (struct) anotada con `#[storage]`. Cada "
"contrato debe tener un único almacenamiento. Es un almacén key-value, donde "
"cada key se asignará a una dirección de almacenamiento del espacio de "
"almacenamiento del contrato."

#: src/ch00/basics/storage.md:16
msgid ""
"You can define [storage variables](./variables.md#storage-variables) in your "
"contract, and then use them to store and retrieve data."
msgstr ""
"Puede definir [variables de storage](./variables.md#storage-variables) en su "
"contrato y luego usarlas para almacenar y recuperar datos."

#: src/ch00/basics/storage.md:17
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        a: u128,\n"
"        b: u8,\n"
"        c: u256\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Contract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        a: u128,\n"
"        b: u8,\n"
"        c: u256\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/storage.md:29
msgid ""
"> Actually these two contracts have the same underlying sierra program.\n"
"> From the compiler's perspective, the storage variables don't exist until "
"they are used."
msgstr ""
"> En realidad estos dos contratos tienen el mismo programa sierra "
"subyacente.\n"
"> Desde la perspectiva del compilador, las variables de almacenamiento no "
"existen hasta que se utilizan."

#: src/ch00/basics/storage.md:32
msgid ""
"You can also read about [storing custom types](./storing-custom-types.md)"
msgstr ""
"También puede leer sobre [almacenamiento de tipos personalizados](./storing-"
"custom-types.md)"

#: src/ch00/basics/constructor.md:1
msgid "# Constructor"
msgstr "# Constructor"

#: src/ch00/basics/constructor.md:3
msgid ""
"Constructors are a special type of function that runs only once when "
"deploying a contract, and can be used to initialize the state of the "
"contract. Your contract must not have more than one constructor, and that "
"constructor function must be annotated with the `#[constructor]` attribute. "
"Also, a good practice consists in naming that function `constructor`."
msgstr ""
"Los constructores son un tipo especial de función que se ejecuta solo una "
"vez al implementar un contrato y se pueden usar para inicializar el estado "
"del contrato. Su contrato no debe tener más de un constructor, y esa función "
"constructora debe estar anotada con el atributo `#[constructor]`. Además, "
"una buena práctica consiste en denominar a esa función `constructor`."

#: src/ch00/basics/constructor.md:5
msgid ""
"Here's a simple example that demonstrates how to initialize the state of a "
"contract on deployment by defining logic inside a constructor."
msgstr ""
"A continuación se muestra un ejemplo sencillo que demuestra cómo inicializar "
"el estado de un contrato durante la implementación definiendo la lógica "
"dentro de un constructor."

#: src/ch00/basics/constructor.md:7
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod ExampleConstructor {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"\n"
"    // The constructor is decorated with a `#[constructor]` attribute.\n"
"    // It is not inside an `impl` block.\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252, address: "
"ContractAddress) {\n"
"        self.names.write(address, name);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod ExampleConstructor {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        names: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"\n"
"    // The constructor is decorated with a `#[constructor]` attribute.\n"
"    // It is not inside an `impl` block.\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, name: felt252, address: "
"ContractAddress) {\n"
"        self.names.write(address, name);\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/constructor.md:25
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x017fd6558e67451dA583d123D77F4e2651E91502D08F8F8432355293b11e1f8F) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/constructor/src/constructor.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x017fd6558e67451dA583d123D77F4e2651E91502D08F8F8432355293b11e1f8F) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/constructor/src/constructor.cairo)."

#: src/ch00/basics/variables.md:1
msgid "# Variables"
msgstr "# Variables"

#: src/ch00/basics/variables.md:3
msgid "There are 3 types of variables in Cairo contracts:"
msgstr "Hay 3 tipos de variables en los contratos de Cairo:"

#: src/ch00/basics/variables.md:5
msgid ""
"- Local\n"
"  - declared inside a function\n"
"  - not stored on the blockchain\n"
"- Storage\n"
"  - declared in the [Storage](./storage.md) of a contract\n"
"  - can be accessed from one execution to another\n"
"- Global\n"
"  - provides information about the blockchain\n"
"  - accessed anywhere, even within library functions"
msgstr ""
"- Local\n"
"   - Declarado dentro de una función\n"
"   - No almacenado en blockchain\n"
"- Almacenamiento\n"
"   - Declarado en el [Almacenamiento](./storage.md) de un contrato\n"
"   - Se puede acceder de una ejecución a otra\n"
"- Global\n"
"   - Proporciona información sobre la blockchain\n"
"   - Se accede desde cualquier lugar, incluso dentro de las funciones de la "
"biblioteca"

#: src/ch00/basics/variables.md:15
msgid "## Local Variables"
msgstr "## Variables Locales"

#: src/ch00/basics/variables.md:17
msgid ""
"Local variables are used and accessed within the scope of a specific "
"function or block of code. They are temporary and exist only for the "
"duration of that particular function or block execution."
msgstr ""
"Las variables locales se utilizan y se accede a ellas dentro del alcance de "
"una función o bloque de código específico. Son temporales y existen solo "
"mientras dure esa función en particular o la ejecución del bloque."

#: src/ch00/basics/variables.md:19
msgid ""
"Local variables are stored in memory and are not stored on the blockchain. "
"This means they cannot be accessed from one execution to another. Local "
"variables are useful for storing temporary data that is relevant only within "
"a specific context. They also make the code more readable by giving names to "
"intermediate values."
msgstr ""
"Las variables locales se almacenan en la memoria y no en la cadena de "
"bloques. Esto significa que no se puede acceder a ellos de una ejecución a "
"otra. Las variables locales son útiles para almacenar datos temporales que "
"son relevantes sólo dentro de un contexto específico. También hacen que el "
"código sea más legible al dar nombres a los valores intermedios."

#: src/ch00/basics/variables.md:21
msgid "Here's a simple example of a contract with only local variables:"
msgstr "Aquí hay un ejemplo simple de un contrato con solo variables locales:"

#: src/ch00/basics/variables.md:23
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ILocalVariablesExample<TContractState> {\n"
"    fn do_something(self: @TContractState, value: u32) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod LocalVariablesExample {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl LocalVariablesExample of super::"
"ILocalVariablesExample<ContractState> {\n"
"        fn do_something(self: @ContractState, value: u32) -> u32 {\n"
"            // This variable is local to the current block. It can't be "
"accessed once it goes out of scope.\n"
"            let increment = 10;\n"
"\n"
"            {\n"
"                // The scope of a code block allows for local variable "
"declaration\n"
"                // We can access variables defined in higher scopes.\n"
"                let sum = value + increment;\n"
"                sum\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ILocalVariablesExample<TContractState> {\n"
"    fn do_something(self: @TContractState, value: u32) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod LocalVariablesExample {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl LocalVariablesExample of super::"
"ILocalVariablesExample<ContractState> {\n"
"        fn do_something(self: @ContractState, value: u32) -> u32 {\n"
"            // This variable is local to the current block. It can't be "
"accessed once it goes out of scope.\n"
"            let increment = 10;\n"
"\n"
"            {\n"
"                // The scope of a code block allows for local variable "
"declaration\n"
"                // We can access variables defined in higher scopes.\n"
"                let sum = value + increment;\n"
"                sum\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/variables.md:50
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x015B3a10F9689BeD741Ca3C210017BC097122CeF76f3cAA191A20ff8b9b56b96) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/variables/src/local_variables.cairo)."
msgstr ""
"Visite el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x015B3a10F9689BeD741Ca3C210017BC097122CeF76f3cAA191A20ff8b9b56b96) "
"o juegue con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/variables/src/local_variables.cairo)."

#: src/ch00/basics/variables.md:52
msgid "## Storage Variables"
msgstr "## Variables de Storage"

#: src/ch00/basics/variables.md:54
msgid ""
"Storage variables are persistent data stored on the blockchain. They can be "
"accessed from one execution to another, allowing the contract to remember "
"and update information over time."
msgstr ""
"Las variables de almacenamiento (storage) son datos persistentes almacenados "
"en la blockchain. Se puede acceder a ellos de una ejecución a otra, lo que "
"permite que el contrato recuerde y actualice la información a lo largo del "
"tiempo."

#: src/ch00/basics/variables.md:56
msgid ""
"To write or update a storage variable, you need to interact with the "
"contract through an external entrypoint by sending a transaction."
msgstr ""
"Para escribir o actualizar una variable de storage, debe interactuar con el "
"contrato a través de un punto de entrada externo mediante el envío de una "
"transacción."

#: src/ch00/basics/variables.md:58
msgid ""
"On the other hand, you can read state variables, for free, without any "
"transaction, simply by interacting with a node."
msgstr ""
"Por otro lado, puedes leer variables de estado, de forma gratuita, sin "
"ninguna transacción, simplemente interactuando con un nodo."

#: src/ch00/basics/variables.md:60
msgid "Here's a simple example of a contract with one storage variable:"
msgstr ""
"A continuación se muestra un ejemplo sencillo de un contrato con una "
"variable de almacenamiento:"

#: src/ch00/basics/variables.md:62
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStorageVariableExample<TContractState> {\n"
"    fn set(ref self: TContractState, value: u32);\n"
"    fn get(self: @TContractState) -> u32;\n"
"}\n"
"#[starknet::contract]\n"
"mod StorageVariablesExample {\n"
"    // All storage variables are contained in a struct called Storage\n"
"    // annotated with the `#[storage]` attribute\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Storage variable holding a number\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StorageVariablesExample of super::"
"IStorageVariableExample<ContractState> {\n"
"        // Write to storage variables by sending a transaction that calls an "
"external function\n"
"        fn set(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"\n"
"        // Read from storage variables without sending transactions\n"
"        fn get(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStorageVariableExample<TContractState> {\n"
"    fn set(ref self: TContractState, value: u32);\n"
"    fn get(self: @TContractState) -> u32;\n"
"}\n"
"#[starknet::contract]\n"
"mod StorageVariablesExample {\n"
"    // All storage variables are contained in a struct called Storage\n"
"    // annotated with the `#[storage]` attribute\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Storage variable holding a number\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StorageVariablesExample of super::"
"IStorageVariableExample<ContractState> {\n"
"        // Write to storage variables by sending a transaction that calls an "
"external function\n"
"        fn set(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"\n"
"        // Read from storage variables without sending transactions\n"
"        fn get(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/variables.md:92
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x06eA827B32875483709b785A7F9e846a52776Cd8D42C3fE696218c2624b0DCCa) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/variables/src/storage_variables.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x06eA827B32875483709b785A7F9e846a52776Cd8D42C3fE696218c2624b0DCCa) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/variables/src/storage_variables."
"cairo)."

#: src/ch00/basics/variables.md:94
msgid "## Global Variables"
msgstr "## Variables Globales"

#: src/ch00/basics/variables.md:96
msgid ""
"Global variables are predefined variables that provide information about the "
"blockchain and the current execution environment. They can be accessed at "
"any time and from anywhere!"
msgstr ""
"Las variables globales son variables predefinidas que proporcionan "
"información sobre la blockchain y el entorno de ejecución actual. ¡Se puede "
"acceder a ellos en cualquier momento y desde cualquier lugar!"

#: src/ch00/basics/variables.md:98
msgid ""
"In Starknet, you can access global variables by using specific functions "
"contained in the starknet core libraries."
msgstr ""
"En Starknet, puede acceder a variables globales utilizando funciones "
"específicas contenidas en las bibliotecas principales de Starknet."

#: src/ch00/basics/variables.md:100
msgid ""
"For example, the `get_caller_address` function returns the address of the "
"caller of the current transaction, and the `get_contract_address` function "
"returns the address of the current contract."
msgstr ""
"Por ejemplo, la función `get_caller_address` devuelve la dirección de la "
"persona que llama de la transacción actual, y la función "
"`get_contract_address` devuelve la dirección del contrato actual."

#: src/ch00/basics/variables.md:102
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IGlobalExample<TContractState> {\n"
"    fn foo(ref self: TContractState);\n"
"}\n"
"#[starknet::contract]\n"
"mod GlobalExample {\n"
"    // import the required functions from the starknet core library\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl GlobalExampleImpl of super::IGlobalExample<ContractState> {\n"
"        fn foo(ref self: ContractState) {\n"
"            // Call the get_caller_address function to get the sender "
"address\n"
"            let caller = get_caller_address();\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IGlobalExample<TContractState> {\n"
"    fn foo(ref self: TContractState);\n"
"}\n"
"#[starknet::contract]\n"
"mod GlobalExample {\n"
"    // import the required functions from the starknet core library\n"
"    use starknet::get_caller_address;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl GlobalExampleImpl of super::IGlobalExample<ContractState> {\n"
"        fn foo(ref self: ContractState) {\n"
"            // Call the get_caller_address function to get the sender "
"address\n"
"            let caller = get_caller_address();\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/variables.md:125
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x05bD2F3943bd4e030f85678b55b2EC2C1be939e32388530FB20ED967B3Be433F) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/variables/src/global_variables.cairo)."
msgstr ""
"Visite el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x05bD2F3943bd4e030f85678b55b2EC2C1be939e32388530FB20ED967B3Be433F) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/variables/src/global_variables.cairo)."

#: src/ch00/basics/visibility-mutability.md:1
msgid "# Visibility and Mutability"
msgstr "# Visibilidad y Mutabilidad"

#: src/ch00/basics/visibility-mutability.md:3
msgid "## Visibility"
msgstr "## Visibilidad"

#: src/ch00/basics/visibility-mutability.md:5
msgid "There are two types of functions in Starknet contracts:"
msgstr "Hay dos tipos de funciones en los contratos Starknet:"

#: src/ch00/basics/visibility-mutability.md:7
msgid ""
"- Functions that are accessible externally and can be called by anyone.\n"
"- Functions that are only accessible internally and can only be called by "
"other functions in the contract."
msgstr ""
"- Funciones a las que se puede acceder externamente y que cualquiera puede "
"llamar.\n"
"- Funciones a las que solo se puede acceder internamente y que solo pueden "
"ser invocadas por otras funciones del contrato."

#: src/ch00/basics/visibility-mutability.md:10
msgid ""
"These functions are also typically divided into two different "
"implementations blocks. The first `impl` block for externally accessible "
"functions is explicitly annotated with an `#[abi(embed_v0)]` attribute. This "
"indicates that all the functions inside this block can be called either as a "
"transaction or as a view function. The second `impl` block for internally "
"accessible functions is not annotated with any attribute, which means that "
"all the functions inside this block are private by default."
msgstr ""
"Estas funciones también suelen dividirse en dos bloques de implementación "
"diferentes. El primer bloque `impl` para funciones accesibles externamente "
"está anotado explícitamente con un atributo `#[abi(embed_v0)]`. Esto indica "
"que todas las funciones dentro de este bloque se pueden llamar como una "
"transacción o como una función de view. El segundo bloque `impl` para "
"funciones accesibles internamente no está anotado con ningún atributo, lo "
"que significa que todas las funciones dentro de este bloque son privadas de "
"forma predeterminada."

#: src/ch00/basics/visibility-mutability.md:12
msgid "## State Mutability"
msgstr "## Mutabilidad del Estado"

#: src/ch00/basics/visibility-mutability.md:14
msgid ""
"Regardless of whether a function is internal or external, it can either "
"modify the contract's state or not. When we declare functions that interact "
"with storage variables inside a smart contract,\n"
"we need to explicitly state that we are accessing the `ContractState` by "
"adding it as the first parameter of the function. This can be done in two "
"different ways:"
msgstr ""
"Independientemente de si una función es interna o externa, puede modificar "
"el estado del contrato o no. Cuando declaramos funciones que interactúan con "
"variables de almacenamiento dentro de un smart contract, debemos indicar "
"explícitamente que estamos accediendo al `ContractState` agregándolo como el "
"primer parámetro de la función. Esto se puede hacer de dos maneras "
"diferentes:"

#: src/ch00/basics/visibility-mutability.md:17
msgid ""
"- If we want our function to be able to mutate the state of the contract, we "
"pass it by reference like this: `ref self: ContractState`.\n"
"- If we want our function to be read-only and not mutate the state of the "
"contract, we pass it by snapshot like this: `self: @ContractState`."
msgstr ""
"- Si queremos que nuestra función pueda mutar el estado del contrato, lo "
"pasamos por referencia así: `ref self: ContractState`.\n"
"- Si queremos que nuestra función sea de solo lectura y no mute el estado "
"del contrato, la pasamos por instantánea como esta: `self: @ContractState`."

#: src/ch00/basics/visibility-mutability.md:20
msgid ""
"Read-only functions, also called view functions, can be directly called "
"without making a transaction. You can interact with them directly through a "
"RPC node to read the contract's state, and they're free to call!\n"
"External functions, that modify the contract's state, on the other side can "
"only be called by making a transaction."
msgstr ""
"Las funciones de solo lectura, también llamadas funciones de visualización, "
"se pueden llamar directamente sin realizar una transacción. Puede "
"interactuar con ellos directamente a través de un nodo RPC para leer el "
"estado del contrato, ¡y pueden llamar libremente! Las funciones externas, "
"que modifican el estado del contrato, por otro lado, solo se pueden llamar "
"realizando una transacción."

#: src/ch00/basics/visibility-mutability.md:23
msgid ""
"Internal functions can't be called externally, but the same principle "
"applies regarding state mutability."
msgstr ""
"Las funciones internas no se pueden llamar externamente, pero se aplica el "
"mismo principio con respecto a la mutabilidad de estado."

#: src/ch00/basics/visibility-mutability.md:25
msgid "Let's take a look at a simple example contract to see these in action:"
msgstr ""
"Echemos un vistazo a un contrato de ejemplo simple para verlos en acción:"

#: src/ch00/basics/visibility-mutability.md:27
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IExampleContract<TContractState> {\n"
"    fn set(ref self: TContractState, value: u32);\n"
"    fn get(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ExampleContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"\n"
"    // The `abi(embed_v0)` attribute indicates that all the functions in "
"this implementation can be called externally.\n"
"    // Omitting this attribute would make all the functions in this "
"implementation internal.\n"
"    #[abi(embed_v0)]\n"
"    impl ExampleContract of super::IExampleContract<ContractState> {\n"
"        // The `set` function can be called externally because it is written "
"inside an implementation marked as `#[external]`.\n"
"        // It can modify the contract's state as it is passed as a "
"reference.\n"
"        fn set(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"\n"
"        // The `get` function can be called externally because it is written "
"inside an implementation marked as `#[external]`.\n"
"        // However, it can't modify the contract's state is passed as a "
"snapshot: it is only a \"view\" function.\n"
"        fn get(self: @ContractState) -> u32 {\n"
"            // We can call an internal function from any functions within "
"the contract\n"
"            PrivateFunctionsTrait::_read_value(self)\n"
"        }\n"
"    }\n"
"\n"
"    // The lack of the `external` attribute indicates that all the functions "
"in this implementation can only be called internally.\n"
"    // We name the trait `PrivateFunctionsTrait` to indicate that it is an "
"internal trait allowing us to call internal functions.\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        // The `_read_value` function is outside the implementation that is "
"marked as `#[abi(embed_v0)]`, so it's an _internal_ function\n"
"        // and can only be called from within the contract.\n"
"        // However, it can't modify the contract's state is passed as a "
"snapshot: it is only a \"view\" function.\n"
"        fn _read_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IExampleContract<TContractState> {\n"
"    fn set(ref self: TContractState, value: u32);\n"
"    fn get(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ExampleContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"\n"
"    // The `abi(embed_v0)` attribute indicates that all the functions in "
"this implementation can be called externally.\n"
"    // Omitting this attribute would make all the functions in this "
"implementation internal.\n"
"    #[abi(embed_v0)]\n"
"    impl ExampleContract of super::IExampleContract<ContractState> {\n"
"        // The `set` function can be called externally because it is written "
"inside an implementation marked as `#[external]`.\n"
"        // It can modify the contract's state as it is passed as a "
"reference.\n"
"        fn set(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"\n"
"        // The `get` function can be called externally because it is written "
"inside an implementation marked as `#[external]`.\n"
"        // However, it can't modify the contract's state is passed as a "
"snapshot: it is only a \"view\" function.\n"
"        fn get(self: @ContractState) -> u32 {\n"
"            // We can call an internal function from any functions within "
"the contract\n"
"            PrivateFunctionsTrait::_read_value(self)\n"
"        }\n"
"    }\n"
"\n"
"    // The lack of the `external` attribute indicates that all the functions "
"in this implementation can only be called internally.\n"
"    // We name the trait `PrivateFunctionsTrait` to indicate that it is an "
"internal trait allowing us to call internal functions.\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        // The `_read_value` function is outside the implementation that is "
"marked as `#[abi(embed_v0)]`, so it's an _internal_ function\n"
"        // and can only be called from within the contract.\n"
"        // However, it can't modify the contract's state is passed as a "
"snapshot: it is only a \"view\" function.\n"
"        fn _read_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/visibility-mutability.md:73
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x0071dE3093AB58053b0292C225aa0eED40293e7694A0042685FF6D813d39889F) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/visibility/src/visibility.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x0071dE3093AB58053b0292C225aa0eED40293e7694A0042685FF6D813d39889F) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/visibility/src/visibility.cairo)."

#: src/ch00/basics/counter.md:1
msgid "# Simple Counter"
msgstr "# Counter Sencillo"

#: src/ch00/basics/counter.md:3
msgid "This is a simple counter contract."
msgstr "Este es un contrato de un simple counter."

#: src/ch00/basics/counter.md:5
msgid "Here's how it works:"
msgstr "Así es como trabaja:"

#: src/ch00/basics/counter.md:7
msgid ""
"- The contract has a state variable called 'counter' that is initialized to "
"0.\n"
"\n"
"- When a user calls 'increment', the contract increments the counter by 1.\n"
"\n"
"- When a user calls 'decrement', the contract decrements the counter by 1."
msgstr ""
"- El contrato tiene una variable de estado llamada 'counter' que se "
"inicializa a 0.\n"
"\n"
"- Cuando un usuario llama 'increment', el contrato incrementa el contador en "
"1.\n"
"\n"
"- Cuando un usuario llama 'decrement', el contrato disminuye el contador en "
"1."

#: src/ch00/basics/counter.md:13
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISimpleCounter<TContractState> {\n"
"    fn get_current_count(self: @TContractState) -> u128;\n"
"    fn increment(ref self: TContractState);\n"
"    fn decrement(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleCounter {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Counter variable\n"
"        counter: u128,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_value: u128) {\n"
"        // Store initial value\n"
"        self.counter.write(init_value);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleCounter of super::ISimpleCounter<ContractState> {\n"
"        fn get_current_count(self: @ContractState) -> u128 {\n"
"            return self.counter.read();\n"
"        }\n"
"\n"
"        fn increment(ref self: ContractState) {\n"
"            // Store counter value + 1\n"
"            let counter = self.counter.read() + 1;\n"
"            self.counter.write(counter);\n"
"        }\n"
"        fn decrement(ref self: ContractState) {\n"
"            // Store counter value - 1\n"
"            let counter = self.counter.read() - 1;\n"
"            self.counter.write(counter);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISimpleCounter<TContractState> {\n"
"    fn get_current_count(self: @TContractState) -> u128;\n"
"    fn increment(ref self: TContractState);\n"
"    fn decrement(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleCounter {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Counter variable\n"
"        counter: u128,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_value: u128) {\n"
"        // Store initial value\n"
"        self.counter.write(init_value);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleCounter of super::ISimpleCounter<ContractState> {\n"
"        fn get_current_count(self: @ContractState) -> u128 {\n"
"            return self.counter.read();\n"
"        }\n"
"\n"
"        fn increment(ref self: ContractState) {\n"
"            // Store counter value + 1\n"
"            let counter = self.counter.read() + 1;\n"
"            self.counter.write(counter);\n"
"        }\n"
"        fn decrement(ref self: ContractState) {\n"
"            // Store counter value - 1\n"
"            let counter = self.counter.read() - 1;\n"
"            self.counter.write(counter);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/counter.md:54
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x01664a69Fe701a1df7Bb0ae4A353792d0cf4E27146ee860075cbf6108b1D5718) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/counter/src/contracts.cairo)."
msgstr ""
"Visite el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x01664a69Fe701a1df7Bb0ae4A353792d0cf4E27146ee860075cbf6108b1D5718) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/counter/src/contracts.cairo)."

#: src/ch00/basics/mappings.md:1
msgid "# Mappings"
msgstr "# Mapas"

#: src/ch00/basics/mappings.md:3
msgid ""
"Maps are a key-value data structure used to store data within a smart "
"contract. In Cairo they are implemented using the `LegacyMap` type. It's "
"important to note that the `LegacyMap` type can only be used inside the "
"`Storage` struct of a contract and that it can't be used elsewhere."
msgstr ""
"Los mapas son una estructura de datos de key-value que se utiliza para "
"almacenar datos dentro de un contrato inteligente. En Cairo se implementan "
"utilizando el tipo `LegacyMap`. Es importante tener en cuenta que el tipo "
"`LegacyMap` solo se puede usar dentro de la estructura `Storage` de un "
"contrato y no se puede usar en ningún otro lugar."

#: src/ch00/basics/mappings.md:5
msgid ""
"Here we demonstrate how to use the `LegacyMap` type within a Cairo contract, "
"to map between a key of type `ContractAddress` and value of type `felt252`. "
"The key-value types are specified within angular brackets <>. We write to "
"the map by calling the `write()` method, passing in both the key and value. "
"Similarly, we can read the value associated with a given key by calling the "
"`read()` method and passing in the relevant key."
msgstr ""
"Aquí demostramos cómo usar el tipo `LegacyMap` dentro de un contrato de "
"Cairo, para mapear entre una clave de tipo `ContractAddress` y un valor de "
"tipo `felt252`. Los tipos key-value se especifican entre corchetes angulares "
"<>. Escribimos en el mapa llamando al método `write()`, pasando tanto la "
"clave como el valor. De manera similar, podemos leer el valor asociado con "
"una clave determinada llamando al método `read()` y pasando la clave "
"relevante."

#: src/ch00/basics/mappings.md:7
msgid "Some additional notes:"
msgstr "Algunas notas adicionales:"

#: src/ch00/basics/mappings.md:9
msgid ""
"- More complex key-value mappings are possible, for example we could use "
"`LegacyMap::<(ContractAddress, ContractAddress), felt252>` to create an "
"allowance on an ERC20 token contract.\n"
"\n"
"- In mappings, the address of the value at key `k_1,...,k_n` is `h(..."
"h(h(sn_keccak(variable_name),k_1),k_2),...,k_n)` where `ℎ` is the Pedersen "
"hash and the final value is taken `mod2251−256`. You can learn more about "
"the contract storage layout in the [Starknet Documentation](https://docs."
"starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-"
"storage/#storage_variables)"
msgstr ""
"- Son posibles asignaciones key-value más complejas; por ejemplo, podríamos "
"usar `LegacyMap::<(ContractAddress, ContractAddress), Felt252>` para crear "
"una asignación en un contrato de token ERC20.\n"
"\n"
"- En las asignaciones, la dirección del valor en la clave `k_1,...,k_n` es "
"`h(...h(h(sn_keccak(nombre_variable),k_1),k_2),...,k_n)` donde `ℎ` es el "
"hash de Pedersen y el valor final se toma `mod2251−256`. Puede obtener más "
"información sobre el diseño de almacenamiento por contrato en la "
"[Documentación de Starknet](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-storage/"
"#storage_variables)"

#: src/ch00/basics/mappings.md:13
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IMapContract<TContractState> {\n"
"    fn set(ref self: TContractState, key: ContractAddress, value: felt252);\n"
"    fn get(self: @TContractState, key: ContractAddress) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod MapContract {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // The `LegacyMap` type is only available inside the `Storage` "
"struct.\n"
"        map: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl MapContractImpl of super::IMapContract<ContractState> {\n"
"        fn set(ref self: ContractState, key: ContractAddress, value: "
"felt252) {\n"
"            self.map.write(key, value);\n"
"        }\n"
"\n"
"        fn get(self: @ContractState, key: ContractAddress) -> felt252 {\n"
"            self.map.read(key)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IMapContract<TContractState> {\n"
"    fn set(ref self: TContractState, key: ContractAddress, value: felt252);\n"
"    fn get(self: @TContractState, key: ContractAddress) -> felt252;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod MapContract {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // The `LegacyMap` type is only available inside the `Storage` "
"struct.\n"
"        map: LegacyMap::<ContractAddress, felt252>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl MapContractImpl of super::IMapContract<ContractState> {\n"
"        fn set(ref self: ContractState, key: ContractAddress, value: "
"felt252) {\n"
"            self.map.write(key, value);\n"
"        }\n"
"\n"
"        fn get(self: @ContractState, key: ContractAddress) -> felt252 {\n"
"            self.map.read(key)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/mappings.md:44
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x06214AB4c23Cc545bf2221D465eB83aFb7412779AD498BD48a724B3F645E3505) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/mappings/src/mappings.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x06214AB4c23Cc545bf2221D465eB83aFb7412779AD498BD48a724B3F645E3505) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/mappings/src/mappings.cairo)."

#: src/ch00/basics/mappings.md:46 src/components/how_to.md:175
#: src/components/dependencies.md:504 src/components/collisions.md:121
msgid "<footer id=\"last-change\">Last change: 2023-12-17</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-12-17</footer>"

#: src/ch00/basics/errors.md:1
msgid "# Errors"
msgstr "# Errores"

#: src/ch00/basics/errors.md:3
msgid ""
"Errors can be used to handle validation and other conditions that may occur "
"during the execution of a smart contract.\n"
"If an error is thrown during the execution of a smart contract call, the "
"execution is stopped and any changes made during the transaction are "
"reverted."
msgstr ""
"Los errores se pueden utilizar para manejar la validación y otras "
"condiciones que pueden ocurrir durante la ejecución de un smart contract.\n"
"Si se produce un error durante la ejecución de una llamada de smart "
"contract, la ejecución se detiene y se revierte cualquier cambio realizado "
"durante la transacción."

#: src/ch00/basics/errors.md:6
msgid "To throw an error, use the `assert` or `panic` functions:"
msgstr "Para generar un error, use las funciones `assert` o `panic`:"

#: src/ch00/basics/errors.md:8
msgid ""
"- `assert` is used to validate conditions.\n"
"  If the check fails, an error is thrown along with a specified value, often "
"a message.\n"
"  It's similar to the `require` statement in Solidity.\n"
"\n"
"- `panic` immediately halt the execution with the given error value.\n"
"  It should be used when the condition to check is complex and for internal "
"errors. It's similar to the `revert` statement in Solidity.\n"
"  (Use `panic_with_felt252` to be able to directly pass a felt252 as the "
"error value)"
msgstr ""
"- `assert` se utiliza para validar condiciones.\n"
"   Si la verificación falla, se genera un error junto con un valor "
"específico, a menudo un mensaje.\n"
"   Es similar a la declaración `require` en Solidity.\n"
"\n"
"- `panic` detiene inmediatamente la ejecución con el valor de error dado.\n"
"   Debe utilizarse cuando la condición a comprobar es compleja y para "
"errores internos. Es similar a la declaración `revert` en Solidity.\n"
"   (Utilice `panic_with_felt252` para poder pasar directamente un fieltro252 "
"como valor de error)"

#: src/ch00/basics/errors.md:16
msgid "Here's a simple example that demonstrates the use of these functions:"
msgstr "Aquí hay un ejemplo simple que demuestra el uso de estas funciones:"

#: src/ch00/basics/errors.md:18
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IErrorsExample<TContractState> {\n"
"    fn test_assert(self: @TContractState, i: u256);\n"
"    fn test_panic(self: @TContractState, i: u256);\n"
"}\n"
"#[starknet::contract]\n"
"mod ErrorsExample {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ErrorsExample of super::IErrorsExample<ContractState> {\n"
"        fn test_assert(self: @ContractState, i: u256) {\n"
"            // Assert used to validate a condition\n"
"            // and abort execution if the condition is not met\n"
"            assert(i > 0, 'i must be greater than 0');\n"
"        }\n"
"\n"
"        fn test_panic(self: @ContractState, i: u256) {\n"
"            if (i == 0) {\n"
"                // Panic used to abort execution directly\n"
"                panic_with_felt252('i must not be 0');\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IErrorsExample<TContractState> {\n"
"    fn test_assert(self: @TContractState, i: u256);\n"
"    fn test_panic(self: @TContractState, i: u256);\n"
"}\n"
"#[starknet::contract]\n"
"mod ErrorsExample {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ErrorsExample of super::IErrorsExample<ContractState> {\n"
"        fn test_assert(self: @ContractState, i: u256) {\n"
"            // Assert used to validate a condition\n"
"            // and abort execution if the condition is not met\n"
"            assert(i > 0, 'i must be greater than 0');\n"
"        }\n"
"\n"
"        fn test_panic(self: @ContractState, i: u256) {\n"
"            if (i == 0) {\n"
"                // Panic used to abort execution directly\n"
"                panic_with_felt252('i must not be 0');\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/errors.md:46
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x0022664463FF0b711CC9B549a9E87d65A0882bB1D29338C4108696B8F2216a40) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/errors/src/simple_errors.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x0022664463FF0b711CC9B549a9E87d65A0882bB1D29338C4108696B8F2216a40) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/errors/src/simple_errors.cairo)."

#: src/ch00/basics/errors.md:48
msgid "## Custom errors"
msgstr "## Errores personalizados"

#: src/ch00/basics/errors.md:50
msgid ""
"You can make error handling easier by defining your error codes in a "
"specific module."
msgstr ""
"Puede facilitar el manejo de errores definiendo sus códigos de error en un "
"módulo específico."

#: src/ch00/basics/errors.md:52
msgid ""
"```rust\n"
"mod Errors {\n"
"    const NOT_POSITIVE: felt252 = 'must be greater than 0';\n"
"    const NOT_NULL: felt252 = 'must not be null';\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ICustomErrorsExample<TContractState> {\n"
"    fn test_assert(self: @TContractState, i: u256);\n"
"    fn test_panic(self: @TContractState, i: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod CustomErrorsExample {\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CustomErrorsExample of super::ICustomErrorsExample<ContractState> "
"{\n"
"        fn test_assert(self: @ContractState, i: u256) {\n"
"            assert(i > 0, Errors::NOT_POSITIVE);\n"
"        }\n"
"\n"
"        fn test_panic(self: @ContractState, i: u256) {\n"
"            if (i == 0) {\n"
"                panic_with_felt252(Errors::NOT_NULL);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod Errors {\n"
"    const NOT_POSITIVE: felt252 = 'must be greater than 0';\n"
"    const NOT_NULL: felt252 = 'must not be null';\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ICustomErrorsExample<TContractState> {\n"
"    fn test_assert(self: @TContractState, i: u256);\n"
"    fn test_panic(self: @TContractState, i: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod CustomErrorsExample {\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CustomErrorsExample of super::ICustomErrorsExample<ContractState> "
"{\n"
"        fn test_assert(self: @ContractState, i: u256) {\n"
"            assert(i > 0, Errors::NOT_POSITIVE);\n"
"        }\n"
"\n"
"        fn test_panic(self: @ContractState, i: u256) {\n"
"            if (i == 0) {\n"
"                panic_with_felt252(Errors::NOT_NULL);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/errors.md:85
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x0501CD5da5B453a18515B5A20b8029bd7583DFE7a399ad9f79c284F7829e4A57) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/errors/src/custom_errors.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x0501CD5da5B453a18515B5A20b8029bd7583DFE7a399ad9f79c284F7829e4A57) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/errors/src/custom_errors.cairo)."

#: src/ch00/basics/errors.md:87
msgid "## Vault example"
msgstr "## Ejemplo de Vault"

#: src/ch00/basics/errors.md:89
msgid ""
"Here's another example that demonstrates the use of errors in a more complex "
"contract:"
msgstr ""
"Aquí hay otro ejemplo que demuestra el uso de errores en un contrato más "
"complejo:"

#: src/ch00/basics/errors.md:91
msgid ""
"```rust\n"
"mod VaultErrors {\n"
"    const INSUFFICIENT_BALANCE: felt252 = 'insufficient_balance';\n"
"// you can define more errors here\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IVaultErrorsExample<TContractState> {\n"
"    fn deposit(ref self: TContractState, amount: u256);\n"
"    fn withdraw(ref self: TContractState, amount: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod VaultErrorsExample {\n"
"    use super::VaultErrors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: u256,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl VaultErrorsExample of super::IVaultErrorsExample<ContractState> {\n"
"        fn deposit(ref self: ContractState, amount: u256) {\n"
"            let mut balance = self.balance.read();\n"
"            balance = balance + amount;\n"
"            self.balance.write(balance);\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, amount: u256) {\n"
"            let mut balance = self.balance.read();\n"
"\n"
"            assert(balance >= amount, VaultErrors::INSUFFICIENT_BALANCE);\n"
"\n"
"            // Or using panic:\n"
"            if (balance >= amount) {\n"
"                panic_with_felt252(VaultErrors::INSUFFICIENT_BALANCE);\n"
"            }\n"
"\n"
"            let balance = balance - amount;\n"
"\n"
"            self.balance.write(balance);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"mod VaultErrors {\n"
"    const INSUFFICIENT_BALANCE: felt252 = 'insufficient_balance';\n"
"// you can define more errors here\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IVaultErrorsExample<TContractState> {\n"
"    fn deposit(ref self: TContractState, amount: u256);\n"
"    fn withdraw(ref self: TContractState, amount: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod VaultErrorsExample {\n"
"    use super::VaultErrors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        balance: u256,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl VaultErrorsExample of super::IVaultErrorsExample<ContractState> {\n"
"        fn deposit(ref self: ContractState, amount: u256) {\n"
"            let mut balance = self.balance.read();\n"
"            balance = balance + amount;\n"
"            self.balance.write(balance);\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, amount: u256) {\n"
"            let mut balance = self.balance.read();\n"
"\n"
"            assert(balance >= amount, VaultErrors::INSUFFICIENT_BALANCE);\n"
"\n"
"            // Or using panic:\n"
"            if (balance >= amount) {\n"
"                panic_with_felt252(VaultErrors::INSUFFICIENT_BALANCE);\n"
"            }\n"
"\n"
"            let balance = balance - amount;\n"
"\n"
"            self.balance.write(balance);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/errors.md:137
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x020C2da26F42A28Ef54ED428eF1810FE433784b055f9bF315C5d992b1579C268) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/errors/src/vault_errors.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x020C2da26F42A28Ef54ED428eF1810FE433784b055f9bF315C5d992b1579C268) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/errors/src/vault_errors.cairo)."

#: src/ch00/basics/events.md:1
msgid "# Events"
msgstr "# Eventos"

#: src/ch00/basics/events.md:3
msgid ""
"Events are a way to emit data from a contract. All events must be defined in "
"the `Event` enum, which must be annotated with the `#[event]` attribute.\n"
"An event is defined as struct that derives the `#[starknet::Event]` trait. "
"The fields of that struct correspond to the data that will be emitted. An "
"event can be indexed for easy and fast access when querying the data at a "
"later time. Events data can be indexed by adding a `#[key]` attribute to a "
"field member."
msgstr ""
"Los eventos son una forma de emitir datos de un contrato. Todos los eventos "
"deben definirse en la enumeración `Event`, que debe anotarse con el atributo "
"`#[event]`.\n"
"Un evento se define como una estructura que deriva el trait `#[starknet::"
"Event]`. Los campos de esa estructura corresponden a los datos que se "
"emitirán. Un evento se puede indexar para un acceso fácil y rápido al "
"consultar los datos más adelante. Los datos de eventos se pueden indexar "
"agregando un atributo `#[key]` a un miembro de campo."

#: src/ch00/basics/events.md:6
msgid ""
"Here's a simple example of a contract using events that emit an event each "
"time a counter is incremented by the \"increment\" function:"
msgstr ""
"A continuación se muestra un ejemplo simple de un contrato que utiliza "
"eventos que emiten un evento cada vez que la función `increment` incrementa "
"un contador:"

#: src/ch00/basics/events.md:8
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IEventCounter<TContractState> {\n"
"    fn increment(ref self: TContractState);\n"
"}\n"
"#[starknet::contract]\n"
"mod EventCounter {\n"
"    use starknet::{get_caller_address, ContractAddress};\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Counter value\n"
"        counter: u128,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    // The event enum must be annotated with the `#[event]` attribute.\n"
"    // It must also derive the `Drop` and `starknet::Event` traits.\n"
"    enum Event {\n"
"        CounterIncreased: CounterIncreased,\n"
"        UserIncreaseCounter: UserIncreaseCounter\n"
"    }\n"
"\n"
"    // By deriving the `starknet::Event` trait, we indicate to the compiler "
"that\n"
"    // this struct will be used when emitting events.\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct CounterIncreased {\n"
"        amount: u128\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct UserIncreaseCounter {\n"
"        // The `#[key]` attribute indicates that this event will be "
"indexed.\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        new_value: u128,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl EventCounter of super::IEventCounter<ContractState> {\n"
"        fn increment(ref self: ContractState) {\n"
"            let mut counter = self.counter.read();\n"
"            counter += 1;\n"
"            self.counter.write(counter);\n"
"            // Emit event\n"
"            self.emit(Event::CounterIncreased(CounterIncreased { amount: "
"1 }));\n"
"            self\n"
"                .emit(\n"
"                    Event::UserIncreaseCounter(\n"
"                        UserIncreaseCounter {\n"
"                            user: get_caller_address(), new_value: self."
"counter.read()\n"
"                        }\n"
"                    )\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IEventCounter<TContractState> {\n"
"    fn increment(ref self: TContractState);\n"
"}\n"
"#[starknet::contract]\n"
"mod EventCounter {\n"
"    use starknet::{get_caller_address, ContractAddress};\n"
"    #[storage]\n"
"    struct Storage {\n"
"        // Counter value\n"
"        counter: u128,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    // The event enum must be annotated with the `#[event]` attribute.\n"
"    // It must also derive the `Drop` and `starknet::Event` traits.\n"
"    enum Event {\n"
"        CounterIncreased: CounterIncreased,\n"
"        UserIncreaseCounter: UserIncreaseCounter\n"
"    }\n"
"\n"
"    // By deriving the `starknet::Event` trait, we indicate to the compiler "
"that\n"
"    // this struct will be used when emitting events.\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct CounterIncreased {\n"
"        amount: u128\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct UserIncreaseCounter {\n"
"        // The `#[key]` attribute indicates that this event will be "
"indexed.\n"
"        #[key]\n"
"        user: ContractAddress,\n"
"        new_value: u128,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl EventCounter of super::IEventCounter<ContractState> {\n"
"        fn increment(ref self: ContractState) {\n"
"            let mut counter = self.counter.read();\n"
"            counter += 1;\n"
"            self.counter.write(counter);\n"
"            // Emit event\n"
"            self.emit(Event::CounterIncreased(CounterIncreased { amount: "
"1 }));\n"
"            self\n"
"                .emit(\n"
"                    Event::UserIncreaseCounter(\n"
"                        UserIncreaseCounter {\n"
"                            user: get_caller_address(), new_value: self."
"counter.read()\n"
"                        }\n"
"                    )\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/events.md:66
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x022e3B59518EA04aBb5da671ea04ecC3a154400f226d2Df38eFE146741b9E2F6) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/events/src/counter.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x022e3B59518EA04aBb5da671ea04ecC3a154400f226d2Df38eFE146741b9E2F6) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/ch00-getting-started/events/src/counter.cairo)."

#: src/ch00/basics/events.md:68 src/ch00/testing/contract-testing.md:176
#: src/ch01/upgradeable_contract.md:117
msgid "<footer id=\"last-change\">Last change: 2023-12-21</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-12-21</footer>"

#: src/ch00/basics/syscalls.md:1
msgid "# Syscalls"
msgstr "# Llamadas al Sistema"

#: src/ch00/basics/syscalls.md:3
msgid ""
"At the protocol level, the Starknet Operating System (OS) is the program "
"that manages the whole Starknet network."
msgstr ""
"A nivel de protocolo, el sistema operativo (SO) Starknet es el programa que "
"gestiona toda la red Starknet."

#: src/ch00/basics/syscalls.md:5
msgid ""
"Some of the OS functionalities are exposed to smart contracts through the "
"use of syscalls (system calls). Syscalls can be used to get information "
"about the state of the Starknet network, to interact with/deploy contracts, "
"emit events, send messages, and perform other low-level operations."
msgstr ""
"Algunas de las funcionalidades del sistema operativo están expuestas a smart "
"contracts mediante el uso de syscalls (llamadas al sistema). Las llamadas al "
"sistema se pueden utilizar para obtener información sobre el estado de la "
"red Starknet, para interactuar/implementar contratos, emitir eventos, enviar "
"mensajes y realizar otras operaciones de bajo nivel."

#: src/ch00/basics/syscalls.md:7
msgid ""
"Syscalls return a `SyscallResult` which is either `Sucess` of `Failure`, "
"allowing the contract to handle errors."
msgstr ""
"Las llamadas al sistema devuelven un `SyscallResult` que es `Sucess` o "
"`Failure`, lo que permite que el contrato maneje los errores."

#: src/ch00/basics/syscalls.md:9
msgid "Here's the available syscalls:"
msgstr "Aquí están las llamadas al sistema disponibles:"

#: src/ch00/basics/syscalls.md:10
msgid ""
"- [get_block_hash](#get_block_hash)\n"
"- [get_execution_info](#get_execution_info)\n"
"- [call_contract](#call_contract)\n"
"- [deploy](#deploy)\n"
"- [emit_event](#emit_event)\n"
"- [library_call](#library_call)\n"
"- [send_message_to_L1](#send_message_to_L1)\n"
"- [replace_class](#replace_class)\n"
"- [storage_read](#storage_read)\n"
"- [storage_write](#storage_write)"
msgstr ""
"- [get_block_hash](#get_block_hash)\n"
"- [get_execution_info](#get_execution_info)\n"
"- [call_contract](#call_contract)\n"
"- [deploy](#deploy)\n"
"- [emit_event](#emit_event)\n"
"- [library_call](#library_call)\n"
"- [send_message_to_L1](#send_message_to_L1)\n"
"- [replace_class](#replace_class)\n"
"- [storage_read](#storage_read)\n"
"- [storage_write](#storage_write)"

#: src/ch00/basics/syscalls.md:20
msgid "<!-- - keccak_syscall ? -->"
msgstr "<!-- - keccak_syscall ? -->"

#: src/ch00/basics/syscalls.md:22
msgid "#### get_block_hash"
msgstr "#### get_block_hash"

#: src/ch00/basics/syscalls.md:24
msgid ""
"```rust\n"
"fn get_block_hash_syscall(block_number: u64) -> SyscallResult<felt252>\n"
"```"
msgstr ""
"```rust\n"
"fn get_block_hash_syscall(block_number: u64) -> SyscallResult<felt252>\n"
"```"

#: src/ch00/basics/syscalls.md:28
msgid "Get the hash of the block number `block_number`."
msgstr "Obtenga el hash del número de bloque `block_number`."

#: src/ch00/basics/syscalls.md:30
msgid "Only within the range `[first_v0_12_0_block, current_block - 10]`."
msgstr "Solo dentro del rango `[first_v0_12_0_block, current_block - 10]`."

#: src/ch00/basics/syscalls.md:32
msgid "#### get_execution_info"
msgstr "#### get_execution_info"

#: src/ch00/basics/syscalls.md:34
msgid ""
"```rust\n"
"fn get_execution_info_syscall() -> SyscallResult<Box<starknet::info::"
"ExecutionInfo>>\n"
"```"
msgstr ""
"```rust\n"
"fn get_execution_info_syscall() -> SyscallResult<Box<starknet::info::"
"ExecutionInfo>>\n"
"```"

#: src/ch00/basics/syscalls.md:38
msgid ""
"Get information about the current execution context.\n"
"The returned `ExecutionInfo` is defined as :"
msgstr ""
"Obtenga información sobre el contexto de ejecución actual.\n"
"La `ExecutionInfo` devuelta se define como:"

#: src/ch00/basics/syscalls.md:41
msgid ""
"```rust\n"
"#[derive(Copy, Drop, Debug)]\n"
"pub struct ExecutionInfo {\n"
"    pub block_info: Box<BlockInfo>,\n"
"    pub tx_info: Box<TxInfo>,\n"
"    pub caller_address: ContractAddress,\n"
"    pub contract_address: ContractAddress,\n"
"    pub entry_point_selector: felt252,\n"
"}\n"
"\n"
"#[derive(Copy, Drop, Debug, Serde)]\n"
"pub struct BlockInfo {\n"
"    pub block_number: u64,\n"
"    pub block_timestamp: u64,\n"
"    pub sequencer_address: ContractAddress,\n"
"}\n"
"\n"
"#[derive(Copy, Drop, Debug, Serde)]\n"
"pub struct TxInfo {\n"
"    // The version of the transaction. Always fixed (1)\n"
"    pub version: felt252,\n"
"    // The account contract from which this transaction originates.\n"
"    pub account_contract_address: ContractAddress,\n"
"    // The max_fee field of the transaction.\n"
"    pub max_fee: u128,\n"
"    // The signature of the transaction.\n"
"    pub signature: Span<felt252>,\n"
"    // The hash of the transaction.\n"
"    pub transaction_hash: felt252,\n"
"    // The identifier of the chain.\n"
"    // This field can be used to prevent replay of testnet transactions on "
"mainnet.\n"
"    pub chain_id: felt252,\n"
"    // The transaction's nonce.\n"
"    pub nonce: felt252,\n"
"    // A span of ResourceBounds structs.\n"
"    pub resource_bounds: Span<ResourceBounds>,\n"
"    // The tip.\n"
"    pub tip: u128,\n"
"    // If specified, the paymaster should pay for the execution of the tx.\n"
"    // The data includes the address of the paymaster sponsoring the "
"transaction, followed by\n"
"    // extra data to send to the paymaster.\n"
"    pub paymaster_data: Span<felt252>,\n"
"    // The data availability mode for the nonce.\n"
"    pub nonce_data_availability_mode: u32,\n"
"    // The data availability mode for the account balance from which fee "
"will be taken.\n"
"    pub fee_data_availability_mode: u32,\n"
"    // If nonempty, will contain the required data for deploying and "
"initializing an account\n"
"    // contract: its class hash, address salt and constructor calldata.\n"
"    pub account_deployment_data: Span<felt252>,\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop, Debug)]\n"
"pub struct ExecutionInfo {\n"
"    pub block_info: Box<BlockInfo>,\n"
"    pub tx_info: Box<TxInfo>,\n"
"    pub caller_address: ContractAddress,\n"
"    pub contract_address: ContractAddress,\n"
"    pub entry_point_selector: felt252,\n"
"}\n"
"\n"
"#[derive(Copy, Drop, Debug, Serde)]\n"
"pub struct BlockInfo {\n"
"    pub block_number: u64,\n"
"    pub block_timestamp: u64,\n"
"    pub sequencer_address: ContractAddress,\n"
"}\n"
"\n"
"#[derive(Copy, Drop, Debug, Serde)]\n"
"pub struct TxInfo {\n"
"    // The version of the transaction. Always fixed (1)\n"
"    pub version: felt252,\n"
"    // The account contract from which this transaction originates.\n"
"    pub account_contract_address: ContractAddress,\n"
"    // The max_fee field of the transaction.\n"
"    pub max_fee: u128,\n"
"    // The signature of the transaction.\n"
"    pub signature: Span<felt252>,\n"
"    // The hash of the transaction.\n"
"    pub transaction_hash: felt252,\n"
"    // The identifier of the chain.\n"
"    // This field can be used to prevent replay of testnet transactions on "
"mainnet.\n"
"    pub chain_id: felt252,\n"
"    // The transaction's nonce.\n"
"    pub nonce: felt252,\n"
"    // A span of ResourceBounds structs.\n"
"    pub resource_bounds: Span<ResourceBounds>,\n"
"    // The tip.\n"
"    pub tip: u128,\n"
"    // If specified, the paymaster should pay for the execution of the tx.\n"
"    // The data includes the address of the paymaster sponsoring the "
"transaction, followed by\n"
"    // extra data to send to the paymaster.\n"
"    pub paymaster_data: Span<felt252>,\n"
"    // The data availability mode for the nonce.\n"
"    pub nonce_data_availability_mode: u32,\n"
"    // The data availability mode for the account balance from which fee "
"will be taken.\n"
"    pub fee_data_availability_mode: u32,\n"
"    // If nonempty, will contain the required data for deploying and "
"initializing an account\n"
"    // contract: its class hash, address salt and constructor calldata.\n"
"    pub account_deployment_data: Span<felt252>,\n"
"}\n"
"```"

#: src/ch00/basics/syscalls.md:93
msgid ""
"`starknet::info` provides helper functions to access the `ExecutionInfo` "
"fields in a more convenient way:"
msgstr ""
"`starknet::info` proporciona funciones auxiliares para acceder a los campos "
"`ExecutionInfo` de una manera más conveniente:"

#: src/ch00/basics/syscalls.md:94
msgid ""
"- `get_execution_info() -> Box<ExecutionInfo>`\n"
"- `get_caller_address() -> ContractAddress`\n"
"- `get_contract_address() -> ContractAddress`\n"
"- `get_block_info() -> Box<BlockInfo>`\n"
"- `get_tx_info() -> Box<TxInfo>`\n"
"- `get_block_timestamp() -> u64`\n"
"- `get_block_number() -> u64`"
msgstr ""
"- `get_execution_info() -> Box<ExecutionInfo>`\n"
"- `get_caller_address() -> ContractAddress`\n"
"- `get_contract_address() -> ContractAddress`\n"
"- `get_block_info() -> Box<BlockInfo>`\n"
"- `get_tx_info() -> Box<TxInfo>`\n"
"- `get_block_timestamp() -> u64`\n"
"- `get_block_number() -> u64`"

#: src/ch00/basics/syscalls.md:102
msgid "#### call_contract"
msgstr "#### call_contract"

#: src/ch00/basics/syscalls.md:104
msgid ""
"```rust\n"
"fn call_contract_syscall(\n"
"    address: ContractAddress, entry_point_selector: felt252, calldata: "
"Span<felt252>\n"
") -> SyscallResult<Span<felt252>>\n"
"```"
msgstr ""
"```rust\n"
"fn call_contract_syscall(\n"
"    address: ContractAddress, entry_point_selector: felt252, calldata: "
"Span<felt252>\n"
") -> SyscallResult<Span<felt252>>\n"
"```"

#: src/ch00/basics/syscalls.md:110
msgid ""
"Call a contract at `address` with the given `entry_point_selector` and "
"`calldata`.\n"
"Failure can't be caught for this syscall, if the call fails, the whole "
"transaction will revert."
msgstr ""
"Llame a un contrato en la`address` con el `entry_point_selector` y "
"`calldata`proporcionados.\n"
"No se puede detectar una falla en esta llamada al sistema; si la llamada "
"falla, se revertirá toda la transacción."

#: src/ch00/basics/syscalls.md:113
msgid ""
"This is not the recommended way to call a contract. Instead, use the "
"dispatcher generated from the contract interface as shown in the [Calling "
"other contracts](../interacting/calling_other_contracts.md)."
msgstr ""
"Esta no es la forma recomendada de llamar a un contrato. En su lugar, "
"utilice el despachador (dispatcher) generado desde la interfaz del contrato "
"como se muestra en [Llamar a otros contratos] (../interacting/"
"calling_other_contracts.md)."

#: src/ch00/basics/syscalls.md:115
msgid "<!-- TODO Add example ? / with interact chapter -->"
msgstr "<!-- TODO ¿Agregar ejemplo? / con capítulo de interacción -->"

#: src/ch00/basics/syscalls.md:117
msgid "#### deploy"
msgstr "#### deploy"

#: src/ch00/basics/syscalls.md:119
msgid ""
"```rust\n"
"fn deploy_syscall(\n"
"    class_hash: ClassHash,\n"
"    contract_address_salt: felt252,\n"
"    calldata: Span<felt252>,\n"
"    deploy_from_zero: bool,\n"
") -> SyscallResult<(ContractAddress, Span::<felt252>)>\n"
"```"
msgstr ""
"```rust\n"
"fn deploy_syscall(\n"
"    class_hash: ClassHash,\n"
"    contract_address_salt: felt252,\n"
"    calldata: Span<felt252>,\n"
"    deploy_from_zero: bool,\n"
") -> SyscallResult<(ContractAddress, Span::<felt252>)>\n"
"```"

#: src/ch00/basics/syscalls.md:128
msgid ""
"Deploy a new contract of the predeclared class `class_hash` with "
"`calldata`.\n"
"The success result is a tuple containing the deployed contract address and "
"the return value of the constructor."
msgstr ""
"Implemente un nuevo contrato de la clase predeclarada `class_hash` con "
"`calldata`.\n"
"El resultado exitoso es una tupla que contiene la dirección del contrato "
"implementado y el valor de retorno del constructor."

#: src/ch00/basics/syscalls.md:131
msgid ""
"`contract_address_salt` and `deploy_from_zero` are used to compute the "
"contract address."
msgstr ""
"`contract_address_salt` y `deploy_from_zero` se utilizan para calcular la "
"dirección del contrato."

#: src/ch00/basics/syscalls.md:133
msgid ""
"Example of the usage of the `deploy` syscall from the [Factory pattern](../"
"interacting/factory.md):"
msgstr ""
"Ejemplo del uso de la llamada al sistema `deploy` del [Factory pattern] (../"
"interacting/factory.md):"

#: src/ch00/basics/syscalls.md:135
msgid ""
"```rust\n"
"# use starknet::{ContractAddress, ClassHash};\n"
"# \n"
"# #[starknet::interface]\n"
"# trait ICounterFactory<TContractState> {\n"
"#     /// Create a new counter contract from stored arguments\n"
"#     fn create_counter(ref self: TContractState) -> ContractAddress;\n"
"# \n"
"#     /// Create a new counter contract from the given arguments\n"
"#     fn create_counter_at(ref self: TContractState, init_value: u128) -> "
"ContractAddress;\n"
"# \n"
"#     /// Update the argument\n"
"#     fn update_init_value(ref self: TContractState, init_value: u128);\n"
"# \n"
"#     /// Update the class hash of the Counter contract to deploy when "
"creating a new counter\n"
"#     fn update_counter_class_hash(ref self: TContractState, "
"counter_class_hash: ClassHash);\n"
"# }\n"
"# \n"
"# #[starknet::contract]\n"
"# mod CounterFactory {\n"
"#     use starknet::{ContractAddress, ClassHash};\n"
"#     use starknet::syscalls::deploy_syscall;\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         /// Store the constructor arguments of the contract to deploy\n"
"#         init_value: u128,\n"
"#         /// Store the class hash of the contract to deploy\n"
"#         counter_class_hash: ClassHash,\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, init_value: u128, class_hash: "
"ClassHash) {\n"
"#         self.init_value.write(init_value);\n"
"#         self.counter_class_hash.write(class_hash);\n"
"#     }\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl Factory of super::ICounterFactory<ContractState> {\n"
"        fn create_counter_at(ref self: ContractState, init_value: u128) -> "
"ContractAddress {\n"
"            // Contructor arguments\n"
"            let mut constructor_calldata: Array::<felt252> = array!"
"[init_value.into()];\n"
"\n"
"            // Contract deployment\n"
"            let (deployed_address, _) = deploy_syscall(\n"
"                self.counter_class_hash.read(), 0, constructor_calldata."
"span(), false\n"
"            )\n"
"                .expect('failed to deploy counter');\n"
"\n"
"            deployed_address\n"
"        }\n"
"# \n"
"#         fn create_counter(ref self: ContractState) -> ContractAddress {\n"
"#             self.create_counter_at(self.init_value.read())\n"
"#         }\n"
"# \n"
"#         fn update_init_value(ref self: ContractState, init_value: u128) {\n"
"#             self.init_value.write(init_value);\n"
"#         }\n"
"# \n"
"#         fn update_counter_class_hash(ref self: ContractState, "
"counter_class_hash: ClassHash) {\n"
"#             self.counter_class_hash.write(counter_class_hash);\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use starknet::{ContractAddress, ClassHash};\n"
"# \n"
"# #[starknet::interface]\n"
"# trait ICounterFactory<TContractState> {\n"
"#     /// Create a new counter contract from stored arguments\n"
"#     fn create_counter(ref self: TContractState) -> ContractAddress;\n"
"# \n"
"#     /// Create a new counter contract from the given arguments\n"
"#     fn create_counter_at(ref self: TContractState, init_value: u128) -> "
"ContractAddress;\n"
"# \n"
"#     /// Update the argument\n"
"#     fn update_init_value(ref self: TContractState, init_value: u128);\n"
"# \n"
"#     /// Update the class hash of the Counter contract to deploy when "
"creating a new counter\n"
"#     fn update_counter_class_hash(ref self: TContractState, "
"counter_class_hash: ClassHash);\n"
"# }\n"
"# \n"
"# #[starknet::contract]\n"
"# mod CounterFactory {\n"
"#     use starknet::{ContractAddress, ClassHash};\n"
"#     use starknet::syscalls::deploy_syscall;\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         /// Store the constructor arguments of the contract to deploy\n"
"#         init_value: u128,\n"
"#         /// Store the class hash of the contract to deploy\n"
"#         counter_class_hash: ClassHash,\n"
"#     }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState, init_value: u128, class_hash: "
"ClassHash) {\n"
"#         self.init_value.write(init_value);\n"
"#         self.counter_class_hash.write(class_hash);\n"
"#     }\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl Factory of super::ICounterFactory<ContractState> {\n"
"        fn create_counter_at(ref self: ContractState, init_value: u128) -> "
"ContractAddress {\n"
"            // Contructor arguments\n"
"            let mut constructor_calldata: Array::<felt252> = array!"
"[init_value.into()];\n"
"\n"
"            // Contract deployment\n"
"            let (deployed_address, _) = deploy_syscall(\n"
"                self.counter_class_hash.read(), 0, constructor_calldata."
"span(), false\n"
"            )\n"
"                .expect('failed to deploy counter');\n"
"\n"
"            deployed_address\n"
"        }\n"
"# \n"
"#         fn create_counter(ref self: ContractState) -> ContractAddress {\n"
"#             self.create_counter_at(self.init_value.read())\n"
"#         }\n"
"# \n"
"#         fn update_init_value(ref self: ContractState, init_value: u128) {\n"
"#             self.init_value.write(init_value);\n"
"#         }\n"
"# \n"
"#         fn update_counter_class_hash(ref self: ContractState, "
"counter_class_hash: ClassHash) {\n"
"#             self.counter_class_hash.write(counter_class_hash);\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch00/basics/syscalls.md:204
msgid "#### emit_event"
msgstr "#### emit_event"

#: src/ch00/basics/syscalls.md:206
msgid ""
"```rust\n"
"fn emit_event_syscall(\n"
"    keys: Span<felt252>, data: Span<felt252>\n"
") -> SyscallResult<()>\n"
"```"
msgstr ""
"```rust\n"
"fn emit_event_syscall(\n"
"    keys: Span<felt252>, data: Span<felt252>\n"
") -> SyscallResult<()>\n"
"```"

#: src/ch00/basics/syscalls.md:212
msgid "Emit an event with the given `keys` and `data`."
msgstr "Emite un evento con las `keys` y los `data` proporcionados."

#: src/ch00/basics/syscalls.md:214
msgid ""
"Example of the usage of the `emit_event` syscall from the [Events](../basics/"
"events.md) chapter:"
msgstr ""
"Ejemplo del uso de la llamada al sistema `emit_event` del capítulo [Eventos]"
"(../basics/events.md):"

#: src/ch00/basics/syscalls.md:216
msgid ""
"```rust\n"
"# #[starknet::interface]\n"
"# trait IEventCounter<TContractState> {\n"
"#     fn increment(ref self: TContractState);\n"
"# }\n"
"# #[starknet::contract]\n"
"# mod EventCounter {\n"
"#     use starknet::{get_caller_address, ContractAddress};\n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         // Counter value\n"
"#         counter: u128,\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     // The event enum must be annotated with the `#[event]` attribute.\n"
"#     // It must also derive the `Drop` and `starknet::Event` traits.\n"
"#     enum Event {\n"
"#         CounterIncreased: CounterIncreased,\n"
"#         UserIncreaseCounter: UserIncreaseCounter\n"
"#     }\n"
"# \n"
"#     // By deriving the `starknet::Event` trait, we indicate to the "
"compiler that\n"
"#     // this struct will be used when emitting events.\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct CounterIncreased {\n"
"#         amount: u128\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct UserIncreaseCounter {\n"
"#         // The `#[key]` attribute indicates that this event will be "
"indexed.\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         new_value: u128,\n"
"#     }\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl EventCounter of super::IEventCounter<ContractState> {\n"
"#         fn increment(ref self: ContractState) {\n"
"#             let mut counter = self.counter.read();\n"
"#             counter += 1;\n"
"#             self.counter.write(counter);\n"
"#             // Emit event\n"
"            self.emit(Event::CounterIncreased(CounterIncreased { amount: "
"1 }));\n"
"            self\n"
"                .emit(\n"
"                    Event::UserIncreaseCounter(\n"
"                        UserIncreaseCounter {\n"
"                            user: get_caller_address(), new_value: self."
"counter.read()\n"
"                        }\n"
"                    )\n"
"                );\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# #[starknet::interface]\n"
"# trait IEventCounter<TContractState> {\n"
"#     fn increment(ref self: TContractState);\n"
"# }\n"
"# #[starknet::contract]\n"
"# mod EventCounter {\n"
"#     use starknet::{get_caller_address, ContractAddress};\n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         // Counter value\n"
"#         counter: u128,\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     // The event enum must be annotated with the `#[event]` attribute.\n"
"#     // It must also derive the `Drop` and `starknet::Event` traits.\n"
"#     enum Event {\n"
"#         CounterIncreased: CounterIncreased,\n"
"#         UserIncreaseCounter: UserIncreaseCounter\n"
"#     }\n"
"# \n"
"#     // By deriving the `starknet::Event` trait, we indicate to the "
"compiler that\n"
"#     // this struct will be used when emitting events.\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct CounterIncreased {\n"
"#         amount: u128\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct UserIncreaseCounter {\n"
"#         // The `#[key]` attribute indicates that this event will be "
"indexed.\n"
"#         #[key]\n"
"#         user: ContractAddress,\n"
"#         new_value: u128,\n"
"#     }\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl EventCounter of super::IEventCounter<ContractState> {\n"
"#         fn increment(ref self: ContractState) {\n"
"#             let mut counter = self.counter.read();\n"
"#             counter += 1;\n"
"#             self.counter.write(counter);\n"
"#             // Emit event\n"
"            self.emit(Event::CounterIncreased(CounterIncreased { amount: "
"1 }));\n"
"            self\n"
"                .emit(\n"
"                    Event::UserIncreaseCounter(\n"
"                        UserIncreaseCounter {\n"
"                            user: get_caller_address(), new_value: self."
"counter.read()\n"
"                        }\n"
"                    )\n"
"                );\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch00/basics/syscalls.md:277
msgid ""
"<!-- TODO Add a more low-level example ? -->\n"
"<!-- ```\n"
"let keys = ArrayTrait::new();\n"
"keys.append('key');\n"
"keys.append('deposit');\n"
"let values = ArrayTrait::new();\n"
"values.append(1);\n"
"values.append(2);\n"
"values.append(3);\n"
"emit_event_syscall(keys, values).unwrap_syscall();\n"
"``` -->"
msgstr ""
"<!-- TODO Add a more low-level example ? -->\n"
"<!-- ```\n"
"let keys = ArrayTrait::new();\n"
"keys.append('key');\n"
"keys.append('deposit');\n"
"let values = ArrayTrait::new();\n"
"values.append(1);\n"
"values.append(2);\n"
"values.append(3);\n"
"emit_event_syscall(keys, values).unwrap_syscall();\n"
"``` -->"

#: src/ch00/basics/syscalls.md:289
msgid "#### library_call"
msgstr "#### library_call"

#: src/ch00/basics/syscalls.md:291
msgid ""
"```rust\n"
"fn library_call_syscall(\n"
"    class_hash: ClassHash, function_selector: felt252, calldata: "
"Span<felt252>\n"
") -> SyscallResult<Span<felt252>>\n"
"```"
msgstr ""
"```rust\n"
"fn library_call_syscall(\n"
"    class_hash: ClassHash, function_selector: felt252, calldata: "
"Span<felt252>\n"
") -> SyscallResult<Span<felt252>>\n"
"```"

#: src/ch00/basics/syscalls.md:297
msgid ""
"Call the function `function_selector` of the class `class_hash` with "
"`calldata`.\n"
"This is analogous to a delegate call in Ethereum, but only a single class is "
"called."
msgstr ""
"Llame a la función `function_selector` de la clase `class_hash` con "
"`calldata`.\n"
"Esto es análogo a una llamada de delegado en Ethereum, pero solo se llama a "
"una clase."

#: src/ch00/basics/syscalls.md:300
msgid "<!-- TODO Add example: issue #41 -->"
msgstr "<!-- TODO Add example: issue #41 -->"

#: src/ch00/basics/syscalls.md:302
msgid "#### send_message_to_L1"
msgstr "#### send_message_to_L1"

#: src/ch00/basics/syscalls.md:304
msgid ""
"```rust\n"
"fn send_message_to_l1_syscall(\n"
"    to_address: felt252, payload: Span<felt252>\n"
") -> SyscallResult<()>\n"
"```"
msgstr ""
"```rust\n"
"fn send_message_to_l1_syscall(\n"
"    to_address: felt252, payload: Span<felt252>\n"
") -> SyscallResult<()>\n"
"```"

#: src/ch00/basics/syscalls.md:310
msgid ""
"Send a message to the L1 contract at `to_address` with the given `payload`."
msgstr "Envíe un mensaje al contrato L1 en `to_address` con la `payload` dada."

#: src/ch00/basics/syscalls.md:312
msgid "<!-- TODO - Link to message example page: issue #9 -->"
msgstr "<!-- TODO - Link to message example page: issue #9 -->"

#: src/ch00/basics/syscalls.md:314
msgid "#### replace_class"
msgstr "#### replace_class"

#: src/ch00/basics/syscalls.md:316
msgid ""
"```rust\n"
"fn replace_class_syscall(\n"
"    class_hash: ClassHash\n"
") -> SyscallResult<()>\n"
"```"
msgstr ""
"```rust\n"
"fn replace_class_syscall(\n"
"    class_hash: ClassHash\n"
") -> SyscallResult<()>\n"
"```"

#: src/ch00/basics/syscalls.md:322
msgid "Replace the class of the calling contract with the class `class_hash`."
msgstr "Reemplace la clase del contrato de llamada con la clase `class_hash`."

#: src/ch00/basics/syscalls.md:324
msgid ""
"This is used for contract upgrades. Here's an example from the [Upgradeable "
"Contract](../../ch01/upgradeable_contract.md):"
msgstr ""
"Esto se utiliza para actualizaciones de contratos. Aquí hay un ejemplo del "
"[Contrato actualizable](../../ch01/upgradeable_contract.md):"

#: src/ch00/basics/syscalls.md:326
msgid ""
"```rust\n"
"# use starknet::class_hash::ClassHash;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait IUpgradeableContract<TContractState> {\n"
"#     fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"#     fn version(self: @TContractState) -> u8;\n"
"# }\n"
"# \n"
"# #[starknet::contract]\n"
"# mod UpgradeableContract_V0 {\n"
"#     use starknet::class_hash::ClassHash;\n"
"#     use starknet::SyscallResultTrait;\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {}\n"
"# \n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         Upgraded: Upgraded\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct Upgraded {\n"
"#         implementation: ClassHash\n"
"#     }\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"# \n"
"#         fn version(self: @ContractState) -> u8 {\n"
"#             0\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"
msgstr ""
"```rust\n"
"# use starknet::class_hash::ClassHash;\n"
"# \n"
"# #[starknet::interface]\n"
"# trait IUpgradeableContract<TContractState> {\n"
"#     fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"#     fn version(self: @TContractState) -> u8;\n"
"# }\n"
"# \n"
"# #[starknet::contract]\n"
"# mod UpgradeableContract_V0 {\n"
"#     use starknet::class_hash::ClassHash;\n"
"#     use starknet::SyscallResultTrait;\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {}\n"
"# \n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         Upgraded: Upgraded\n"
"#     }\n"
"# \n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     struct Upgraded {\n"
"#         implementation: ClassHash\n"
"#     }\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"# \n"
"#         fn version(self: @ContractState) -> u8 {\n"
"#             0\n"
"#         }\n"
"#     }\n"
"# }\n"
"# \n"
"# \n"
"```"

#: src/ch00/basics/syscalls.md:372
msgid ""
"The new class code will only be used for future calls to the contract.\n"
"The current transaction containing the `replace_class` syscall will continue "
"to use the old class code. (You can explicitly use the new class code by "
"calling `call_contract` after the `replace_class` syscall in the same "
"transaction)"
msgstr ""
"El nuevo código de clase sólo se utilizará para futuras llamadas al "
"contrato.\n"
"La transacción actual que contiene la llamada al sistema `replace_class` "
"continuará usando el código de clase anterior. (Puede usar explícitamente el "
"nuevo código de clase llamando a `call_contract` después de la llamada al "
"sistema `replace_class` en la misma transacción)"

#: src/ch00/basics/syscalls.md:375
msgid "#### storage_read"
msgstr "#### storage_read"

#: src/ch00/basics/syscalls.md:377
msgid ""
"```rust\n"
"fn storage_read_syscall(\n"
"    address_domain: u32, address: StorageAddress,\n"
") -> SyscallResult<felt252>\n"
"```"
msgstr ""
"```rust\n"
"fn storage_read_syscall(\n"
"    address_domain: u32, address: StorageAddress,\n"
") -> SyscallResult<felt252>\n"
"```"

#: src/ch00/basics/syscalls.md:383
msgid ""
"This low-level syscall is used to get the value in the storage of a specific "
"key at `address` in the `address_domain`."
msgstr ""
"Esta llamada al sistema de bajo nivel se utiliza para obtener el valor en el "
"almacenamiento de una clave específica en la`address` en el `address_domain`."

#: src/ch00/basics/syscalls.md:385
msgid ""
"`address_domain` is used to distinguish between data availability modes.\n"
"Currently, only mode `ONCHAIN` (`0`) is supported."
msgstr ""
"`address_domain` se utiliza para distinguir entre modos de disponibilidad de "
"datos.\n"
"Actualmente, solo se admite el modo `ONCHAIN` (`0`)."

#: src/ch00/basics/syscalls.md:388
msgid "#### storage_write"
msgstr "#### storage_write"

#: src/ch00/basics/syscalls.md:390
msgid ""
"```rust\n"
"fn storage_write_syscall(\n"
"    address_domain: u32, address: StorageAddress, value: felt252\n"
") -> SyscallResult<()>\n"
"```"
msgstr ""
"```rust\n"
"fn storage_write_syscall(\n"
"    address_domain: u32, address: StorageAddress, value: felt252\n"
") -> SyscallResult<()>\n"
"```"

#: src/ch00/basics/syscalls.md:396
msgid ""
"Similar to `storage_read`, this low-level syscall is used to write the value "
"`value` in the storage of a specific key at `address` in the "
"`address_domain`."
msgstr ""
"Similar a `storage_read`, esta llamada al sistema de bajo nivel se usa para "
"escribir el valor `value` en el almacenamiento de una clave específica en "
"`address` en el `address_domain`."

#: src/ch00/basics/syscalls.md:398
msgid "## Documentation"
msgstr "## Documentación"

#: src/ch00/basics/syscalls.md:400
msgid ""
"Syscalls are defined in [`starknet::syscall`](https://github.com/starkware-"
"libs/cairo/blob/ec14a5e2c484190ff40811c973a72a53739cedb7/corelib/src/"
"starknet/syscalls.cairo)"
msgstr ""
"Las llamadas al sistema se definen en [`starknet::syscall`](https://github."
"com/starkware-libs/cairo/blob/ec14a5e2c484190ff40811c973a72a53739cedb7/"
"corelib/src/starknet/syscalls.cairo)"

#: src/ch00/basics/syscalls.md:402
msgid ""
"You can also read the [official documentation page](https://docs.starknet.io/"
"documentation/architecture_and_concepts/Smart_Contracts/system-calls-"
"cairo1/) for more details."
msgstr ""
"También puede leer la [página de documentación oficial](https://docs."
"starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-"
"calls-cairo1/) para obtener más detalles."

#: src/ch00/basics/syscalls.md:404
msgid ""
"<!--\n"
"\n"
"#### Gas cost\n"
"\n"
"```rust\n"
"mod gas_costs {\n"
"    const STEP: usize = 100;\n"
"    const RANGE_CHECK: usize = 70;\n"
"\n"
"    /// Entry point initial gas cost enforced by the compiler.\n"
"    const ENTRY_POINT_INITIAL_BUDGET: usize = 100 * STEP;\n"
"\n"
"    /// OS gas costs.\n"
"    const ENTRY_POINT: usize = ENTRY_POINT_INITIAL_BUDGET + 500 * STEP;\n"
"    // The required gas for each syscall minus the base amount that was pre-"
"charged (by the\n"
"    // compiler).\n"
"    pub const CALL_CONTRACT: usize = 10 * STEP + ENTRY_POINT;\n"
"    pub const DEPLOY: usize = 200 * STEP + ENTRY_POINT;\n"
"    pub const EMIT_EVENT: usize = 10 * STEP;\n"
"    pub const GET_BLOCK_HASH: usize = 50 * STEP;\n"
"    pub const GET_EXECUTION_INFO: usize = 10 * STEP;\n"
"    pub const LIBRARY_CALL: usize = CALL_CONTRACT;\n"
"    pub const REPLACE_CLASS: usize = 50 * STEP;\n"
"    pub const SEND_MESSAGE_TO_L1: usize = 50 * STEP;\n"
"    pub const STORAGE_READ: usize = 50 * STEP;\n"
"    pub const STORAGE_WRITE: usize = 50 * STEP;\n"
"    /// ...\n"
"}\n"
"```\n"
"\n"
"Specific gas cost are defined in this [file](https://github.com/starkware-"
"libs/cairo/blob/ec14a5e2c484190ff40811c973a72a53739cedb7/crates/cairo-lang-"
"runner/src/casm_run/mod.rs#L333) \n"
"-->\n"
"\n"
"<footer id=\"last-change\">Last change: 2023-12-21</footer>"
msgstr ""
"<!--\n"
"\n"
"#### Gas cost\n"
"\n"
"```rust\n"
"mod gas_costs {\n"
"    const STEP: usize = 100;\n"
"    const RANGE_CHECK: usize = 70;\n"
"\n"
"    /// Entry point initial gas cost enforced by the compiler.\n"
"    const ENTRY_POINT_INITIAL_BUDGET: usize = 100 * STEP;\n"
"\n"
"    /// OS gas costs.\n"
"    const ENTRY_POINT: usize = ENTRY_POINT_INITIAL_BUDGET + 500 * STEP;\n"
"    // The required gas for each syscall minus the base amount that was pre-"
"charged (by the\n"
"    // compiler).\n"
"    pub const CALL_CONTRACT: usize = 10 * STEP + ENTRY_POINT;\n"
"    pub const DEPLOY: usize = 200 * STEP + ENTRY_POINT;\n"
"    pub const EMIT_EVENT: usize = 10 * STEP;\n"
"    pub const GET_BLOCK_HASH: usize = 50 * STEP;\n"
"    pub const GET_EXECUTION_INFO: usize = 10 * STEP;\n"
"    pub const LIBRARY_CALL: usize = CALL_CONTRACT;\n"
"    pub const REPLACE_CLASS: usize = 50 * STEP;\n"
"    pub const SEND_MESSAGE_TO_L1: usize = 50 * STEP;\n"
"    pub const STORAGE_READ: usize = 50 * STEP;\n"
"    pub const STORAGE_WRITE: usize = 50 * STEP;\n"
"    /// ...\n"
"}\n"
"```\n"
"\n"
"Specific gas cost are defined in this [file](https://github.com/starkware-"
"libs/cairo/blob/ec14a5e2c484190ff40811c973a72a53739cedb7/crates/cairo-lang-"
"runner/src/casm_run/mod.rs#L333) \n"
"-->\n"
"\n"
"<footer id=\"last-change\">Last change: 2023-12-21</footer>"

#: src/ch00/basics/storing-custom-types.md:1
msgid "# Storing Custom Types"
msgstr "# Almacenamiento de Tipos Personalizados"

#: src/ch00/basics/storing-custom-types.md:3
msgid ""
"While native types can be stored in a contract's storage without any "
"additional work, custom types require a bit more work. This is because at "
"compile time, the compiler does not know how to store custom types in "
"storage. To solve this, we need to implement the `Store` trait for our "
"custom type. Hopefully, we can just derive this trait for our custom type - "
"unless it contains arrays or dictionaries."
msgstr ""
"Si bien los tipos nativos se pueden almacenar en el almacenamiento de un "
"contrato sin ningún trabajo adicional, los tipos personalizados requieren un "
"poco más de trabajo. Esto se debe a que en el momento de la compilación, el "
"compilador no sabe cómo almacenar tipos personalizados en el almacenamiento. "
"Para resolver esto, necesitamos implementar el trait `Store`para nuestro "
"tipo personalizado. Con suerte, podremos derivar este trait para nuestro "
"tipo personalizado, a menos que contenga arrays o diccionarios."

#: src/ch00/basics/storing-custom-types.md:5
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStoringCustomType<TContractState> {\n"
"    fn set_person(ref self: TContractState, person: Person);\n"
"}\n"
"\n"
"// Deriving the starknet::Store trait\n"
"// allows us to store the `Person` struct in the contract's storage.\n"
"#[derive(Drop, Serde, Copy, starknet::Store)]\n"
"struct Person {\n"
"    age: u8,\n"
"    name: felt252\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod StoringCustomType {\n"
"    use super::Person;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        person: Person\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StoringCustomType of super::IStoringCustomType<ContractState> {\n"
"        fn set_person(ref self: ContractState, person: Person) {\n"
"            self.person.write(person);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStoringCustomType<TContractState> {\n"
"    fn set_person(ref self: TContractState, person: Person);\n"
"}\n"
"\n"
"// Deriving the starknet::Store trait\n"
"// allows us to store the `Person` struct in the contract's storage.\n"
"#[derive(Drop, Serde, Copy, starknet::Store)]\n"
"struct Person {\n"
"    age: u8,\n"
"    name: felt252\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod StoringCustomType {\n"
"    use super::Person;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        person: Person\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StoringCustomType of super::IStoringCustomType<ContractState> {\n"
"        fn set_person(ref self: ContractState, person: Person) {\n"
"            self.person.write(person);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/storing-custom-types.md:37
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/storing_custom_types/src/contract.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/storing_custom_types/src/contract.cairo)."

#: src/ch00/basics/custom-types-in-entrypoints.md:1
msgid "# Custom types in entrypoints"
msgstr "# Tipos personalizados en entrypoints"

#: src/ch00/basics/custom-types-in-entrypoints.md:3
msgid ""
"Using custom types in entrypoints requires our type to implement the `Serde` "
"trait. This is because when calling an entrypoint, the input is sent as an "
"array of `felt252` to the entrypoint, and we need to be able to deserialize "
"it into our custom type. Similarly, when returning a custom type from an "
"entrypoint, we need to be able to serialize it into an array of `felt252`.\n"
"Thankfully, we can just derive the `Serde` trait for our custom type."
msgstr ""
"El uso de tipos personalizados en puntos de entrada requiere que nuestro "
"tipo implemente el trait `Serde`. Esto se debe a que cuando se llama a un "
"punto de entrada, la entrada se envía como una matriz de `felt252` al punto "
"de entrada y necesitamos poder deserializarla en nuestro tipo personalizado. "
"De manera similar, al devolver un tipo personalizado desde un punto de "
"entrada, debemos poder serializarlo en una matriz de `felt252`.\n"
"Afortunadamente, podemos derivar el trait `Serde` para nuestro tipo "
"personalizado."

#: src/ch00/basics/custom-types-in-entrypoints.md:6
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISerdeCustomType<TContractState> {\n"
"    fn person_input(ref self: TContractState, person: SerdeCustomType::"
"Person);\n"
"    fn person_output(self: @TContractState) -> SerdeCustomType::Person;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SerdeCustomType {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    // Deriving the `Serde` trait allows us to use\n"
"    // the Person type as an entrypoint parameter and return value\n"
"    #[derive(Drop, Serde)]\n"
"    struct Person {\n"
"        age: u8,\n"
"        name: felt252\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SerdeCustomType of super::ISerdeCustomType<ContractState> {\n"
"        fn person_input(ref self: ContractState, person: Person) {}\n"
"\n"
"        fn person_output(self: @ContractState) -> Person {\n"
"            Person { age: 10, name: 'Joe' }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISerdeCustomType<TContractState> {\n"
"    fn person_input(ref self: TContractState, person: SerdeCustomType::"
"Person);\n"
"    fn person_output(self: @TContractState) -> SerdeCustomType::Person;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SerdeCustomType {\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    // Deriving the `Serde` trait allows us to use\n"
"    // the Person type as an entrypoint parameter and return value\n"
"    #[derive(Drop, Serde)]\n"
"    struct Person {\n"
"        age: u8,\n"
"        name: felt252\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SerdeCustomType of super::ISerdeCustomType<ContractState> {\n"
"        fn person_input(ref self: ContractState, person: Person) {}\n"
"\n"
"        fn person_output(self: @ContractState) -> Person {\n"
"            Person { age: 10, name: 'Joe' }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/basics/custom-types-in-entrypoints.md:37
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/custom_type_serde/src/contract.cairo)."
msgstr ""
"Juega con este contrato en  [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/custom_type_serde/src/contract.cairo)."

#: src/ch00/basics/documentation.md:1
msgid "# Documentation"
msgstr "# Documentación"

#: src/ch00/basics/documentation.md:3
msgid ""
"It's important to take the time to document your code. It will helps "
"developers and users to understand the contract and its functionalities."
msgstr ""
"Es importante tomarse el tiempo para documentar su código. Ayudará a los "
"desarrolladores y usuarios a comprender el contrato y sus funcionalidades."

#: src/ch00/basics/documentation.md:5
msgid "In Cairo, you can add comments with `//`."
msgstr "En Cairo, puedes agregar comentarios con `//`."

#: src/ch00/basics/documentation.md:7
msgid "### Best Practices:"
msgstr "## Mejores Prácticas:"

#: src/ch00/basics/documentation.md:9
msgid ""
"Since Cairo 1, the community has adopted a [Rust-like documentation style]"
"(https://doc.rust-lang.org/rust-by-example/meta/doc.html)."
msgstr ""
"Desde Cairo 1, la comunidad ha adoptado un [estilo de documentación similar "
"a [Rust-like documentation style](https://doc.rust-lang.org/rust-by-example/"
"meta/doc.html)."

#: src/ch00/basics/documentation.md:11
msgid "### Contract Interface:"
msgstr "## Interfaz de Contrato:"

#: src/ch00/basics/documentation.md:13
msgid ""
"In smart contracts, you will often have a trait that defines the contract's "
"interface (with `#[starknet::interface]`).\n"
"This is the perfect place to include detailed documentation explaining the "
"purpose and functionality of the contract entry points. You can follow this "
"template:"
msgstr ""
"En los smart contracts, a menudo tendrá un trait que define la interfaz del "
"contrato (con `#[starknet::interface]`).\n"
"Este es el lugar perfecto para incluir documentación detallada que explique "
"el propósito y la funcionalidad de los puntos de entrada del contrato. "
"Puedes seguir esta plantilla:"

#: src/ch00/basics/documentation.md:16
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IContract<TContractState> {\n"
"    /// High-level description of the function\n"
"    ///\n"
"    /// # Arguments\n"
"    ///\n"
"    /// * `arg_1` - Description of the argument\n"
"    /// * `arg_n` - ...\n"
"    ///\n"
"    /// # Returns\n"
"    ///\n"
"    /// High-level description of the return value\n"
"    fn do_something(ref self: TContractState, arg_1: T_arg_1) -> T_return;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IContract<TContractState> {\n"
"    /// High-level description of the function\n"
"    ///\n"
"    /// # Arguments\n"
"    ///\n"
"    /// * `arg_1` - Description of the argument\n"
"    /// * `arg_n` - ...\n"
"    ///\n"
"    /// # Returns\n"
"    ///\n"
"    /// High-level description of the return value\n"
"    fn do_something(ref self: TContractState, arg_1: T_arg_1) -> T_return;\n"
"}\n"
"```"

#: src/ch00/basics/documentation.md:33
msgid ""
"Keep in mind that this should not describe the implementation details of the "
"function, but rather the high-level purpose and functionality of the "
"contract from the perspective of a user."
msgstr ""
"Tenga en cuenta que esto no debe describir los detalles de implementación de "
"la función, sino más bien el propósito de alto nivel y la funcionalidad del "
"contrato desde la perspectiva de un usuario."

#: src/ch00/basics/documentation.md:35
msgid "### Implementation Details:"
msgstr "### Detalles de Implementación:"

#: src/ch00/basics/documentation.md:37
msgid ""
"When writing the logic of the contract, you can add comments to describe the "
"technical implementation details of the functions."
msgstr ""
"Al escribir la lógica del contrato, puede agregar comentarios para describir "
"los detalles técnicos de implementación de las funciones."

#: src/ch00/basics/documentation.md:39
msgid ""
"> Avoid over-commenting: Comments should provide additional value and "
"clarity."
msgstr ""
"> Evite comentarios excesivos: Los comentarios deben aportar valor y "
"claridad adicionales."

#: src/ch00/basics/documentation.md:41
msgid "<footer id=\"last-change\">Last change: 2023-12-05</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-12-05</footer>"

#: src/ch00/interacting/interacting.md:1
msgid "# Deploy and interact with contracts"
msgstr "# Desplegar contratos e interactuar con ellos"

#: src/ch00/interacting/interacting.md:3
msgid "In this chapter, we will see how to deploy and interact with contracts."
msgstr ""
"En este capítulo, veremos cómo implementar e interactuar con contratos."

#: src/ch00/interacting/interacting.md:4
msgid "<footer id=\"last-change\">Last change: 2023-10-19</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-10-19</footer>"

#: src/ch00/interacting/interfaces-traits.md:1
msgid "# Contract interfaces and Traits generation"
msgstr "# Interfaces de Contratos y generación de Traits"

#: src/ch00/interacting/interfaces-traits.md:3
msgid ""
"Contract interfaces define the structure and behavior of a contract, serving "
"as the contract's public ABI. They list all the function signatures that a "
"contract exposes. For a detailed explanation of interfaces, you can refer to "
"the [Cairo Book](https://book.cairo-lang.org/ch99-01-02-a-simple-contract."
"html)."
msgstr ""
"Las interfaces de contrato definen la estructura y el comportamiento de un "
"contrato y sirven como la ABI pública del contrato. Enumeran todas las "
"firmas de funciones que expone un contrato. Para obtener una explicación "
"detallada de las interfaces, puede consultar el [Cairo Book](https://book."
"cairo-lang.org/ch99-01-02-a-simple-contract.html)."

#: src/ch00/interacting/interfaces-traits.md:5
msgid ""
"In cairo, to specify the interface you need to define a trait annotated with "
"`#[starknet::interface]` and then implement that trait in the contract."
msgstr ""
"En Cairo, para especificar la interfaz es necesario definir un trait anotado "
"con `#[starknet::interface]` y luego implementar ese trait en el contrato."

#: src/ch00/interacting/interfaces-traits.md:7
msgid ""
"When a function needs to access the contract state, it must have a `self` "
"parameter of type `ContractState`. This implies that the corresponding "
"function signature in the interface trait must also take a `TContractState` "
"type as a parameter. It's important to note that every function in the "
"contract interface must have this `self` parameter of type `TContractState`."
msgstr ""
"Cuando una función necesita acceder al estado del contrato, debe tener un "
"parámetro `self` de tipo `ContractState`. Esto implica que la firma de "
"función correspondiente en el trait de interfaz también debe tomar un tipo "
"`TContractState` como parámetro. Es importante tener en cuenta que todas las "
"funciones de la interfaz del contrato deben tener este parámetro `self` de "
"tipo `TContractState`."

#: src/ch00/interacting/interfaces-traits.md:9
msgid ""
"You can use the `#[generate_trait]` attribute to implicitly generate the "
"trait for a specific implementation block. This attribute automatically "
"generates a trait with the same functions as the ones in the implemented "
"block, replacing the `self` parameter with a generic `TContractState` "
"parameter. However, you will need to annotate the block with the "
"`#[abi(per_item)]` attribute, and each function with the appropriate "
"attribute depending on whether it's an external function, a constructor or a "
"l1 handler."
msgstr ""
"Puedes utilizar el atributo `#[generate_trait]` para generar implícitamente "
"el trait para un bloque de implementación específico. Este atributo genera "
"automáticamente un trait con las mismas funciones que las del bloque "
"implementado, sustituyendo el parámetro `self` por un parámetro genérico "
"`TContractState`. Sin embargo, tendrás que anotar el bloque con el atributo "
"`#[abi(per_item)]`, y cada función con el atributo apropiado dependiendo de "
"si es una función externa, un constructor o un manejador l1."

#: src/ch00/interacting/interfaces-traits.md:11
msgid "In summary, there's two ways to handle interfaces:"
msgstr "En resumen, hay dos formas de manejar las interfaces:"

#: src/ch00/interacting/interfaces-traits.md:13
msgid ""
"- Explicitly, by defining a trait annoted with `#[starknet::interface]`\n"
"- Implicitly, by using `#[generate_trait]` combined with the "
"#[abi(per_item)]` attributes, and annotating each function inside the "
"implementation block with the appropriate attribute."
msgstr ""
"- Explícitamente, definiendo un trait anotado con `#[starknet::interface]`\n"
"- Implícitamente, usando `#[generate_trait]` combinado con los atributos "
"#[abi(per_item)]` y anotando cada función dentro del bloque de "
"implementación con el atributo apropiado."

#: src/ch00/interacting/interfaces-traits.md:16
msgid "## Explicit interface"
msgstr "## Interfaz explícita"

#: src/ch00/interacting/interfaces-traits.md:18
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IExplicitInterfaceContract<TContractState> {\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn set_value(ref self: TContractState, value: u32);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ExplicitInterfaceContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ExplicitInterfaceContract of super::"
"IExplicitInterfaceContract<ContractState> {\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IExplicitInterfaceContract<TContractState> {\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn set_value(ref self: TContractState, value: u32);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ExplicitInterfaceContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ExplicitInterfaceContract of super::"
"IExplicitInterfaceContract<ContractState> {\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/interacting/interfaces-traits.md:45
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/interfaces_traits/src/explicit.cairo)."
msgstr ""
"Juega con este contrato en[Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/interfaces_traits/src/explicit.cairo)."

#: src/ch00/interacting/interfaces-traits.md:47
msgid "## Implicit interface"
msgstr "## Interfaz implícita"

#: src/ch00/interacting/interfaces-traits.md:49
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod ImplicitInterfaceContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(per_item)]\n"
"    #[generate_trait]\n"
"    impl ImplicitInterfaceContract of IImplicitInterfaceContract {\n"
"        #[external(v0)]\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        #[external(v0)]\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod ImplicitInterfaceContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[abi(per_item)]\n"
"    #[generate_trait]\n"
"    impl ImplicitInterfaceContract of IImplicitInterfaceContract {\n"
"        #[external(v0)]\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        #[external(v0)]\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/interacting/interfaces-traits.md:73
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/interfaces_traits/src/implicit.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/interfaces_traits/src/implicit.cairo)."

#: src/ch00/interacting/interfaces-traits.md:75
msgid ""
"> Note: You can import an implicitly generated contract interface with `use "
"contract::{GeneratedContractInterface}`. However, the `Dispatcher` will not "
"be generated automatically."
msgstr ""
"> Nota: Puede importar una interfaz de contrato generada implícitamente con "
"`use contract::{GeneratedContractInterface}`. Sin embargo, el `Dispatcher` "
"no se generará automáticamente."

#: src/ch00/interacting/interfaces-traits.md:77
msgid "## Internal functions"
msgstr "## Funciones internas"

#: src/ch00/interacting/interfaces-traits.md:79
msgid ""
"You can also use `#[generate_trait]` for your internal functions.\n"
"Since this trait is generated in the context of the contract, you can define "
"pure functions as well (functions without the `self` parameter)."
msgstr ""
"También puedes usar `#[generate_trait]` para tus funciones internas.\n"
"Dado que este trait se genera en el contexto del contrato, también puedes "
"definir funciones puras (funciones sin el parámetro `self`)."

#: src/ch00/interacting/interfaces-traits.md:82
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IImplicitInternalContract<TContractState> {\n"
"    fn add(ref self: TContractState, nb: u32);\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn get_const(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ImplicitInternalContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"        fn get_const() -> u32 {\n"
"            42\n"
"        }\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.set_value(0);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ImplicitInternalContract of super::"
"IImplicitInternalContract<ContractState> {\n"
"        fn add(ref self: ContractState, nb: u32) {\n"
"            self.set_value(self.value.read() + nb);\n"
"        }\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"        fn get_const(self: @ContractState) -> u32 {\n"
"            self.get_const()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IImplicitInternalContract<TContractState> {\n"
"    fn add(ref self: TContractState, nb: u32);\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn get_const(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ImplicitInternalContract {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalFunctions of InternalFunctionsTrait {\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            self.value.write(value);\n"
"        }\n"
"        fn get_const() -> u32 {\n"
"            42\n"
"        }\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.set_value(0);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ImplicitInternalContract of super::"
"IImplicitInternalContract<ContractState> {\n"
"        fn add(ref self: ContractState, nb: u32) {\n"
"            self.set_value(self.value.read() + nb);\n"
"        }\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"        fn get_const(self: @ContractState) -> u32 {\n"
"            self.get_const()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/interacting/interfaces-traits.md:127
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/interfaces_traits/src/implicit_internal."
"cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/interfaces_traits/src/implicit_internal."
"cairo)."

#: src/ch00/interacting/calling_other_contracts.md:1
msgid "# Calling other contracts"
msgstr "## Llamar a otros contratos"

#: src/ch00/interacting/calling_other_contracts.md:3
msgid "There are two different ways to call other contracts in Cairo."
msgstr "Hay dos formas diferentes de llamar a otros contratos en Cairo."

#: src/ch00/interacting/calling_other_contracts.md:5
msgid ""
"The easiest way to call other contracts is by using the dispatcher of the "
"contract you want to call.\n"
"You can read more about Dispatchers in the [Cairo Book](https://book.cairo-"
"lang.org/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls."
"html#contract-dispatcher)"
msgstr ""
"La forma más sencilla de llamar a otros contratos es utilizar el dispatcher "
"del contrato al que desea llamar.\n"
"Puede leer más sobre los dispatcher en el [Libro de El Cairo](https://book."
"cairo-lang.org/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-"
"calls.html#contract-dispatcher)"

#: src/ch00/interacting/calling_other_contracts.md:8
msgid ""
"The other way is to use the `starknet::call_contract_syscall` syscall "
"yourself. However, this method is not recommended."
msgstr ""
"La otra forma es utilizar la llamada al sistema `starknet::"
"call_contract_syscall`. Sin embargo, este método no es recomendable."

#: src/ch00/interacting/calling_other_contracts.md:10
msgid ""
"In order to call other contracts using dispatchers, you will need to define "
"the called contract's interface as a trait annotated with the `#[starknet::"
"interface]` attribute, and then import the `IContractDispatcher` and "
"`IContractDispatcherTrait` items in your contract."
msgstr ""
"Para llamar a otros contratos utilizando dispatchers, tendrás que definir la "
"interfaz del contrato llamado como un trait anotado con el atributo "
"`#[starknet::interface]`, y luego importar los elementos "
"`IContractDispatcher` e `IContractDispatcherTrait` en tu contrato."

#: src/ch00/interacting/calling_other_contracts.md:12
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ICallee<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Callee {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u128,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ICalleeImpl of super::ICallee<ContractState> {\n"
"        fn set_value(ref self: ContractState, value: u128) -> u128 {\n"
"            self.value.write(value);\n"
"            value\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ICallee<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128) -> u128;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Callee {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u128,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ICalleeImpl of super::ICallee<ContractState> {\n"
"        fn set_value(ref self: ContractState, value: u128) -> u128 {\n"
"            self.value.write(value);\n"
"            value\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/interacting/calling_other_contracts.md:34
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x015c3Bb6D0DE26b64FEAF9A8f4655CfADb5c128bF4510398972704ee12775DB1) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/calling_other_contracts/src/callee.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x015c3Bb6D0DE26b64FEAF9A8f4655CfADb5c128bF4510398972704ee12775DB1) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/calling_other_contracts/src/callee.cairo)."

#: src/ch00/interacting/calling_other_contracts.md:36
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"// We need to have the interface of the callee contract defined\n"
"// so that we can import the Dispatcher.\n"
"#[starknet::interface]\n"
"trait ICallee<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128) -> u128;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ICaller<TContractState> {\n"
"    fn set_value_from_address(ref self: TContractState, addr: "
"ContractAddress, value: u128);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Caller {\n"
"    // We import the Dispatcher of the called contract\n"
"    use super::{ICalleeDispatcher, ICalleeDispatcherTrait};\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ICallerImpl of super::ICaller<ContractState> {\n"
"        fn set_value_from_address(ref self: ContractState, addr: "
"ContractAddress, value: u128) {\n"
"            ICalleeDispatcher { contract_address: addr }.set_value(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"// We need to have the interface of the callee contract defined\n"
"// so that we can import the Dispatcher.\n"
"#[starknet::interface]\n"
"trait ICallee<TContractState> {\n"
"    fn set_value(ref self: TContractState, value: u128) -> u128;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ICaller<TContractState> {\n"
"    fn set_value_from_address(ref self: TContractState, addr: "
"ContractAddress, value: u128);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod Caller {\n"
"    // We import the Dispatcher of the called contract\n"
"    use super::{ICalleeDispatcher, ICalleeDispatcherTrait};\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ICallerImpl of super::ICaller<ContractState> {\n"
"        fn set_value_from_address(ref self: ContractState, addr: "
"ContractAddress, value: u128) {\n"
"            ICalleeDispatcher { contract_address: addr }.set_value(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/interacting/calling_other_contracts.md:68
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x05fa8aF796343d2f22c53C17149386b67B7AC4aB52D9e308Aa507C185aA44778) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/calling_other_contracts/src/caller.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x05fa8aF796343d2f22c53C17149386b67B7AC4aB52D9e308Aa507C185aA44778) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/calling_other_contracts/src/caller.cairo)."

#: src/ch00/interacting/factory.md:1
msgid "# Factory Pattern"
msgstr "# Patrón de la Factory"

#: src/ch00/interacting/factory.md:3
msgid ""
"The factory pattern is a well known pattern in object oriented programming. "
"It provides an abstraction on how to instantiate a class. "
msgstr ""
"El patrón de factory es un patrón bien conocido en la programación orientada "
"a objetos. Proporciona una abstracción sobre cómo instanciar una clase. "

#: src/ch00/interacting/factory.md:5
msgid ""
"In the case of smart contracts, we can use this pattern by defining a "
"factory contract that have the sole responsibility of creating and managing "
"other contracts."
msgstr ""
"En el caso de los smart contracts, podemos utilizar este patrón definiendo "
"un contrato de factory que tenga la responsabilidad exclusiva de crear y "
"gestionar otros contratos."

#: src/ch00/interacting/factory.md:7
msgid "## Class hash and contract instance"
msgstr "# Class hash e instancia de contrato"

#: src/ch00/interacting/factory.md:9
msgid ""
"In Starknet, there's a separation between contract's classes and instances. "
"A contract class serves as a blueprint, defined by the underling Cairo "
"bytecode, contract's entrypoints, ABI and Sierra program hash. The contract "
"class is identified by a class hash. When you want to add a new class to the "
"network, you first need to declare it."
msgstr ""
"En Starknet, hay una separación entre las clases de contrato y las "
"instancias. Una clase de contrato sirve como plano, definido por el código "
"de bytes subyacente de Cairo, los puntos de entrada del contrato, la ABI y "
"el hash del programa Sierra. La clase del contrato es identificada por un "
"hash de clase. Cuando se desea agregar una nueva clase a la red, primero es "
"necesario declararla."

#: src/ch00/interacting/factory.md:11
msgid ""
"When deploying a contract, you need to specify the class hash of the "
"contract you want to deploy. Each instance of a contract has their own "
"storage regardless of the class hash."
msgstr ""
"Cuando se despliega un contrato, es necesario especificar el hash de clase "
"del contrato que se desea desplegar. Cada instancia de un contrato tiene su "
"propio almacenamiento independientemente del hash de clase."

#: src/ch00/interacting/factory.md:13
msgid ""
"Using the factory pattern, we can deploy multiple instances of the same "
"contract class and handle upgrades easily."
msgstr ""
"Utilizando el patrón de factory, podemos desplegar múltiples instancias de "
"la misma clase de contrato y manejar las actualizaciones fácilmente."

#: src/ch00/interacting/factory.md:15
msgid "## Minimal example"
msgstr "## Ejemplo mínimo"

#: src/ch00/interacting/factory.md:17
msgid ""
"Here's a minimal example of a factory contract that deploy the "
"`SimpleCounter` contract:"
msgstr ""
"He aquí un ejemplo mínimo de un contrato de factory que despliega el "
"contrato `SimpleCounter`:"

#: src/ch00/interacting/factory.md:19
msgid ""
"```rust\n"
"use starknet::{ContractAddress, ClassHash};\n"
"\n"
"#[starknet::interface]\n"
"trait ICounterFactory<TContractState> {\n"
"    /// Create a new counter contract from stored arguments\n"
"    fn create_counter(ref self: TContractState) -> ContractAddress;\n"
"\n"
"    /// Create a new counter contract from the given arguments\n"
"    fn create_counter_at(ref self: TContractState, init_value: u128) -> "
"ContractAddress;\n"
"\n"
"    /// Update the argument\n"
"    fn update_init_value(ref self: TContractState, init_value: u128);\n"
"\n"
"    /// Update the class hash of the Counter contract to deploy when "
"creating a new counter\n"
"    fn update_counter_class_hash(ref self: TContractState, "
"counter_class_hash: ClassHash);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod CounterFactory {\n"
"    use starknet::{ContractAddress, ClassHash};\n"
"    use starknet::syscalls::deploy_syscall;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        /// Store the constructor arguments of the contract to deploy\n"
"        init_value: u128,\n"
"        /// Store the class hash of the contract to deploy\n"
"        counter_class_hash: ClassHash,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_value: u128, class_hash: "
"ClassHash) {\n"
"        self.init_value.write(init_value);\n"
"        self.counter_class_hash.write(class_hash);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl Factory of super::ICounterFactory<ContractState> {\n"
"        fn create_counter_at(ref self: ContractState, init_value: u128) -> "
"ContractAddress {\n"
"            // Contructor arguments\n"
"            let mut constructor_calldata: Array::<felt252> = array!"
"[init_value.into()];\n"
"\n"
"            // Contract deployment\n"
"            let (deployed_address, _) = deploy_syscall(\n"
"                self.counter_class_hash.read(), 0, constructor_calldata."
"span(), false\n"
"            )\n"
"                .expect('failed to deploy counter');\n"
"\n"
"            deployed_address\n"
"        }\n"
"\n"
"        fn create_counter(ref self: ContractState) -> ContractAddress {\n"
"            self.create_counter_at(self.init_value.read())\n"
"        }\n"
"\n"
"        fn update_init_value(ref self: ContractState, init_value: u128) {\n"
"            self.init_value.write(init_value);\n"
"        }\n"
"\n"
"        fn update_counter_class_hash(ref self: ContractState, "
"counter_class_hash: ClassHash) {\n"
"            self.counter_class_hash.write(counter_class_hash);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::{ContractAddress, ClassHash};\n"
"\n"
"#[starknet::interface]\n"
"trait ICounterFactory<TContractState> {\n"
"    /// Create a new counter contract from stored arguments\n"
"    fn create_counter(ref self: TContractState) -> ContractAddress;\n"
"\n"
"    /// Create a new counter contract from the given arguments\n"
"    fn create_counter_at(ref self: TContractState, init_value: u128) -> "
"ContractAddress;\n"
"\n"
"    /// Update the argument\n"
"    fn update_init_value(ref self: TContractState, init_value: u128);\n"
"\n"
"    /// Update the class hash of the Counter contract to deploy when "
"creating a new counter\n"
"    fn update_counter_class_hash(ref self: TContractState, "
"counter_class_hash: ClassHash);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod CounterFactory {\n"
"    use starknet::{ContractAddress, ClassHash};\n"
"    use starknet::syscalls::deploy_syscall;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        /// Store the constructor arguments of the contract to deploy\n"
"        init_value: u128,\n"
"        /// Store the class hash of the contract to deploy\n"
"        counter_class_hash: ClassHash,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, init_value: u128, class_hash: "
"ClassHash) {\n"
"        self.init_value.write(init_value);\n"
"        self.counter_class_hash.write(class_hash);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl Factory of super::ICounterFactory<ContractState> {\n"
"        fn create_counter_at(ref self: ContractState, init_value: u128) -> "
"ContractAddress {\n"
"            // Contructor arguments\n"
"            let mut constructor_calldata: Array::<felt252> = array!"
"[init_value.into()];\n"
"\n"
"            // Contract deployment\n"
"            let (deployed_address, _) = deploy_syscall(\n"
"                self.counter_class_hash.read(), 0, constructor_calldata."
"span(), false\n"
"            )\n"
"                .expect('failed to deploy counter');\n"
"\n"
"            deployed_address\n"
"        }\n"
"\n"
"        fn create_counter(ref self: ContractState) -> ContractAddress {\n"
"            self.create_counter_at(self.init_value.read())\n"
"        }\n"
"\n"
"        fn update_init_value(ref self: ContractState, init_value: u128) {\n"
"            self.init_value.write(init_value);\n"
"        }\n"
"\n"
"        fn update_counter_class_hash(ref self: ContractState, "
"counter_class_hash: ClassHash) {\n"
"            self.counter_class_hash.write(counter_class_hash);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/interacting/factory.md:86
msgid ""
"<!-- This is not ready for \"Open in remix\" because we need multiple files "
"-->"
msgstr ""
"<!-- Esto no está listo para \"Abrir en remix\" porque necesitamos varios "
"archivos -->"

#: src/ch00/interacting/factory.md:88
msgid ""
"This factory can be used to deploy multiple instances of the `SimpleCounter` "
"contract by calling the `create_counter` and `create_counter_at` functions."
msgstr ""
"Esta fábrica se puede utilizar para desplegar múltiples instancias del "
"contrato `SimpleCounter` llamando a las funciones `create_counter` y "
"`create_counter_at`."

#: src/ch00/interacting/factory.md:90
msgid ""
"The `SimpleCounter` class hash is stored inside the factory, and can be "
"upgraded with the `update_counter_class_hash` function which allows to reuse "
"the same factory contract when the `SimpleCounter` contract is upgraded."
msgstr ""
"El hash de la clase `SimpleCounter` se almacena dentro de la fábrica, y se "
"puede actualizar con la función `update_counter_class_hash` que permite "
"reutilizar el mismo contrato de fábrica cuando se actualiza el contrato "
"`SimpleCounter`."

#: src/ch00/interacting/factory.md:92
msgid ""
"This minimal example lacks several useful features such as access control, "
"tracking of deployed contracts, events, ..."
msgstr ""
"Este ejemplo mínimo carece de varias funciones útiles, como el control de "
"acceso, el seguimiento de los contratos desplegados, los eventos, ..."

#: src/ch00/interacting/factory.md:94
msgid ""
"<!-- TODO maybe add a more complete example at the end of this section or in "
"the `Applications examples` chapter -->\n"
"\n"
"<footer id=\"last-change\">Last change: 2023-12-21</footer>"
msgstr ""
"<!-- TODO tal vez agregue un ejemplo más completo al final de esta sección o "
"en el capítulo `Ejemplos de aplicaciones` -->\n"
"\n"
"<footer id=\"last-change\">Último cambio: 2023-12-21</footer>"

#: src/ch00/testing/contract-testing.md:1
msgid "# Contract Testing"
msgstr "# Testing de Contrato"

#: src/ch00/testing/contract-testing.md:3
msgid ""
"Testing plays a crucial role in software development, especially for smart "
"contracts. In this section, we'll guide you through the basics of testing a "
"smart contract on Starknet with `scarb`."
msgstr ""
"Las pruebas juegan un papel crucial en el desarrollo de software, "
"especialmente para los smart contracts. En esta sección, te guiaremos a "
"través de los conceptos básicos de las pruebas de un smart contracts en "
"Starknet con `scarb`."

#: src/ch00/testing/contract-testing.md:5
msgid "Let's start with a simple smart contract as an example:"
msgstr "Empecemos con un simple contrato inteligente como ejemplo:"

#: src/ch00/testing/contract-testing.md:6
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait ISimpleContract<TContractState> {\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn get_owner(self: @TContractState) -> ContractAddress;\n"
"    fn set_value(ref self: TContractState, value: u32);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleContract {\n"
"    use starknet::{get_caller_address, ContractAddress};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32,\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, initial_value: u32) {\n"
"        self.value.write(initial_value);\n"
"        self.owner.write(get_caller_address());\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleContract of super::ISimpleContract<ContractState> {\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            assert(self.owner.read() == get_caller_address(), 'Not owner');\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait ISimpleContract<TContractState> {\n"
"    fn get_value(self: @TContractState) -> u32;\n"
"    fn get_owner(self: @TContractState) -> ContractAddress;\n"
"    fn set_value(ref self: TContractState, value: u32);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleContract {\n"
"    use starknet::{get_caller_address, ContractAddress};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        value: u32,\n"
"        owner: ContractAddress\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, initial_value: u32) {\n"
"        self.value.write(initial_value);\n"
"        self.owner.write(get_caller_address());\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleContract of super::ISimpleContract<ContractState> {\n"
"        fn get_value(self: @ContractState) -> u32 {\n"
"            self.value.read()\n"
"        }\n"
"\n"
"        fn get_owner(self: @ContractState) -> ContractAddress {\n"
"            self.owner.read()\n"
"        }\n"
"\n"
"        fn set_value(ref self: ContractState, value: u32) {\n"
"            assert(self.owner.read() == get_caller_address(), 'Not owner');\n"
"            self.value.write(value);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/testing/contract-testing.md:50
msgid "Now, take a look at the tests for this contract:"
msgstr "Ahora, eche un vistazo a las pruebas de este contrato:"

#: src/ch00/testing/contract-testing.md:51
msgid ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    // Import the interface and dispatcher to be able to interact with the "
"contract.\n"
"    use testing_how_to::contract::{\n"
"        ISimpleContract, SimpleContract, ISimpleContractDispatcher, "
"ISimpleContractDispatcherTrait\n"
"    };\n"
"\n"
"    // Import the deploy syscall to be able to deploy the contract.\n"
"    use starknet::class_hash::Felt252TryIntoClassHash;\n"
"    use starknet::{\n"
"        deploy_syscall, ContractAddress, get_caller_address, "
"get_contract_address,\n"
"        contract_address_const\n"
"    };\n"
"\n"
"    // Use starknet test utils to fake the transaction context.\n"
"    use starknet::testing::{set_caller_address, set_contract_address};\n"
"\n"
"    // Deploy the contract and return its dispatcher.\n"
"    fn deploy(initial_value: u32) -> ISimpleContractDispatcher {\n"
"        // Set up constructor arguments.\n"
"        let mut calldata = ArrayTrait::new();\n"
"        initial_value.serialize(ref calldata);\n"
"\n"
"        // Declare and deploy\n"
"        let (contract_address, _) = deploy_syscall(\n"
"            SimpleContract::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata."
"span(), false\n"
"        )\n"
"            .unwrap();\n"
"\n"
"        // Return the dispatcher.\n"
"        // The dispatcher allows to interact with the contract based on its "
"interface.\n"
"        ISimpleContractDispatcher { contract_address }\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_deploy() {\n"
"        let initial_value: u32 = 10;\n"
"        let contract = deploy(initial_value);\n"
"\n"
"        assert(contract.get_value() == initial_value, 'wrong initial "
"value');\n"
"        assert(contract.get_owner() == get_contract_address(), 'wrong "
"owner');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_set_as_owner() {\n"
"        // Fake the caller address to address 1\n"
"        let owner = contract_address_const::<1>();\n"
"        set_contract_address(owner);\n"
"\n"
"        let contract = deploy(10);\n"
"        assert(contract.get_owner() == owner, 'wrong owner');\n"
"\n"
"        // Fake the contract address to address 1\n"
"        set_contract_address(owner);\n"
"        let new_value: u32 = 20;\n"
"        contract.set_value(new_value);\n"
"\n"
"        assert(contract.get_value() == new_value, 'wrong value');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_set_not_owner() {\n"
"        let owner = contract_address_const::<1>();\n"
"        set_contract_address(owner);\n"
"\n"
"        let contract = deploy(10);\n"
"\n"
"        let not_owner = contract_address_const::<2>();\n"
"        set_contract_address(not_owner);\n"
"\n"
"        let new_value: u32 = 20;\n"
"        contract.set_value(new_value);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    // Import the interface and dispatcher to be able to interact with the "
"contract.\n"
"    use testing_how_to::contract::{\n"
"        ISimpleContract, SimpleContract, ISimpleContractDispatcher, "
"ISimpleContractDispatcherTrait\n"
"    };\n"
"\n"
"    // Import the deploy syscall to be able to deploy the contract.\n"
"    use starknet::class_hash::Felt252TryIntoClassHash;\n"
"    use starknet::{\n"
"        deploy_syscall, ContractAddress, get_caller_address, "
"get_contract_address,\n"
"        contract_address_const\n"
"    };\n"
"\n"
"    // Use starknet test utils to fake the transaction context.\n"
"    use starknet::testing::{set_caller_address, set_contract_address};\n"
"\n"
"    // Deploy the contract and return its dispatcher.\n"
"    fn deploy(initial_value: u32) -> ISimpleContractDispatcher {\n"
"        // Set up constructor arguments.\n"
"        let mut calldata = ArrayTrait::new();\n"
"        initial_value.serialize(ref calldata);\n"
"\n"
"        // Declare and deploy\n"
"        let (contract_address, _) = deploy_syscall(\n"
"            SimpleContract::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata."
"span(), false\n"
"        )\n"
"            .unwrap();\n"
"\n"
"        // Return the dispatcher.\n"
"        // The dispatcher allows to interact with the contract based on its "
"interface.\n"
"        ISimpleContractDispatcher { contract_address }\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_deploy() {\n"
"        let initial_value: u32 = 10;\n"
"        let contract = deploy(initial_value);\n"
"\n"
"        assert(contract.get_value() == initial_value, 'wrong initial "
"value');\n"
"        assert(contract.get_owner() == get_contract_address(), 'wrong "
"owner');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_set_as_owner() {\n"
"        // Fake the caller address to address 1\n"
"        let owner = contract_address_const::<1>();\n"
"        set_contract_address(owner);\n"
"\n"
"        let contract = deploy(10);\n"
"        assert(contract.get_owner() == owner, 'wrong owner');\n"
"\n"
"        // Fake the contract address to address 1\n"
"        set_contract_address(owner);\n"
"        let new_value: u32 = 20;\n"
"        contract.set_value(new_value);\n"
"\n"
"        assert(contract.get_value() == new_value, 'wrong value');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic]\n"
"    #[available_gas(2000000000)]\n"
"    fn test_set_not_owner() {\n"
"        let owner = contract_address_const::<1>();\n"
"        set_contract_address(owner);\n"
"\n"
"        let contract = deploy(10);\n"
"\n"
"        let not_owner = contract_address_const::<2>();\n"
"        set_contract_address(not_owner);\n"
"\n"
"        let new_value: u32 = 20;\n"
"        contract.set_value(new_value);\n"
"    }\n"
"}\n"
"```"

#: src/ch00/testing/contract-testing.md:132
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/testing_how_to/src/lib.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/getting-started/testing_how_to/src/lib.cairo)."

#: src/ch00/testing/contract-testing.md:134
msgid ""
"To define our test, we use scarb, which allows us to create a separate "
"module guarded with `#[cfg(test)]`. This ensures that the test module is "
"only compiled when running tests using `scarb test`."
msgstr ""
"Para definir nuestro test, usamos scarb, que nos permite crear un módulo "
"separado protegido con `#[cfg(test)]`. Esto asegura que el módulo de prueba "
"sólo se compila cuando se ejecutan pruebas utilizando `scarb test`."

#: src/ch00/testing/contract-testing.md:136
msgid ""
"Each test is defined as a function with the `#[test]` attribute. You can "
"also check if a test panics using the `#[should_panic]` attribute."
msgstr ""
"Cada prueba se define como una función con el atributo `#[test]`. También "
"puede comprobar si una prueba entra en pánico utilizando el atributo "
"`#[should_panic]`."

#: src/ch00/testing/contract-testing.md:138
msgid ""
"As we are in the context of a smart contract, it's essential to set up the "
"gas limit. You do this by using the `#[available_gas(X)]` attribute to "
"specify the gas limit for a test. This is also a great way to ensure that "
"your contract's features stay under a certain gas limit!"
msgstr ""
"Como estamos en el contexto de un smart contract, es esencial establecer el "
"límite de gas. Esto se hace utilizando el atributo `#[available_gas(X)]` "
"para especificar el límite de gas para una prueba. ¡Esta es también una gran "
"manera de asegurar que las funciones de tu contrato se mantienen por debajo "
"de un cierto límite de gas!"

#: src/ch00/testing/contract-testing.md:140
msgid "> Note: The term \"gas\" here refers to Sierra gas, not L1 gas"
msgstr ">Nota: El término \"gas\" se refiere aquí al gas Sierra, no al gas L1"

#: src/ch00/testing/contract-testing.md:142
msgid "Now, let's move on to the testing process:"
msgstr "Pasemos ahora al proceso de prueba:"

#: src/ch00/testing/contract-testing.md:143
msgid ""
"- Use the `deploy` function logic to declare and deploy your contract.\n"
"- Use `assert` to verify that the contract behaves as expected in the given "
"context."
msgstr ""
"- Utilice la lógica de la función `deploy` para declarar e implementar su "
"contrato.\n"
"- Utilice `assert` para verificar que el contrato se comporta como se espera "
"en el contexto dado."

#: src/ch00/testing/contract-testing.md:146
msgid ""
"To make testing more convenient, the `testing` module of the corelib "
"provides some helpful functions:"
msgstr ""
"Para que las pruebas resulten más cómodas, el módulo `testing` de corelib "
"proporciona algunas funciones útiles:"

#: src/ch00/testing/contract-testing.md:147
msgid ""
"- `set_caller_address(address: ContractAddress)`\n"
"- `set_contract_address(address: ContractAddress)`\n"
"- `set_block_number(block_number: u64)`\n"
"- `set_block_timestamp(block_timestamp: u64)`\n"
"- `set_account_contract_address(address: ContractAddress)`\n"
"- `set_max_fee(fee: u128)`"
msgstr ""
"- `set_caller_address(address: ContractAddress)`\n"
"- `set_contract_address(address: ContractAddress)`\n"
"- `set_block_number(block_number: u64)`\n"
"- `set_block_timestamp(block_timestamp: u64)`\n"
"- `set_account_contract_address(address: ContractAddress)`\n"
"- `set_max_fee(fee: u128)`"

#: src/ch00/testing/contract-testing.md:154
msgid ""
"You may also need the `info` module from the corelib, which allows you to "
"access information about the current execution context (see [syscalls](../"
"basics/syscalls.md)):"
msgstr ""
"Es posible que también necesite el módulo `info` de corelib, que le permite "
"acceder a información sobre el contexto de ejecución actual (consulte "
"[syscalls](../basics/syscalls.md)):"

#: src/ch00/testing/contract-testing.md:155
msgid ""
"- `get_caller_address() -> ContractAddress`\n"
"- `get_contract_address() -> ContractAddress`\n"
"- `get_block_info() -> Box<BlockInfo>`\n"
"- `get_tx_info() -> Box<TxInfo>`\n"
"- `get_block_timestamp() -> u64`\n"
"- `get_block_number() -> u64`"
msgstr ""
"- `get_caller_address() -> ContractAddress`\n"
"- `get_contract_address() -> ContractAddress`\n"
"- `get_block_info() -> Box<BlockInfo>`\n"
"- `get_tx_info() -> Box<TxInfo>`\n"
"- `get_block_timestamp() -> u64`\n"
"- `get_block_number() -> u64`"

#: src/ch00/testing/contract-testing.md:163
msgid ""
"You can found the full list of functions in the [Starknet Corelib repo]"
"(https://github.com/starkware-libs/cairo/tree/main/corelib/src/starknet).\n"
"You can also find a detailled explaination of testing in cairo in the [Cairo "
"book - Chapter 9](https://book.cairo-lang.org/ch09-01-how-to-write-tests."
"html)."
msgstr ""
"Puede encontrar la lista completa de funciones en el [repositorio de "
"Starknet Corelib](https://github.com/starkware-libs/cairo/tree/main/corelib/"
"src/starknet).\n"
"También puede encontrar una explicación detallada de las pruebas en Cairo en "
"el [Libro de Cairo - Capítulo 9](https://book.cairo-lang.org/ch09-01-how-to-"
"write-tests.html)."

#: src/ch00/testing/contract-testing.md:166
msgid "## Starknet Foundry"
msgstr "## Starknet Foundry"

#: src/ch00/testing/contract-testing.md:168
msgid "<!-- TODO update this when Starknet Foundry is more mature. -->"
msgstr "<!-- TODO actualice esto cuando Starknet Foundry esté más maduro. -->"

#: src/ch00/testing/contract-testing.md:170
msgid ""
"Starknet Foundry is a powerful toolkit for developing smart contracts on "
"Starknet. It offers support for testing Starknet smart contracts on top of "
"`scarb` with the `Forge` tool."
msgstr ""
"Starknet Foundry es un potente conjunto de herramientas para el desarrollo "
"de contratos inteligentes en Starknet. Ofrece soporte para probar contratos "
"inteligentes Starknet sobre `scarb` con la herramienta `Forge`."

#: src/ch00/testing/contract-testing.md:172
msgid ""
"Testing with `snforge` is similar to the process we just described but "
"simplified. Moreover, additional features are on the way, including "
"cheatcodes or parallel tests execution. We highly recommend exploring "
"Starknet Foundry and incorporating it into your projects."
msgstr ""
"Probar con `snforge` es similar al proceso que acabamos de describir, pero "
"simplificado. Además, hay características adicionales en camino, incluyendo "
"cheatcodes o ejecución de pruebas en paralelo. Recomendamos encarecidamente "
"explorar Starknet Foundry e incorporarlo a tus proyectos."

#: src/ch00/testing/contract-testing.md:174
msgid ""
"For more detailed information about testing contracts with Starknet Foundry, "
"check out the [Starknet Foundry Book - Testing Contracts](https://foundry-rs."
"github.io/starknet-foundry/testing/contracts.html)."
msgstr ""
"Si desea información más detallada sobre los contratos de pruebas con "
"Starknet Foundry, consulte el [Starknet Foundry Book - Testing Contracts]"
"(https://foundry-rs.github.io/starknet-foundry/testing/contracts.html)."

#: src/ch00/cairo_cheatsheet/cairo_cheatsheet.md:1
msgid "# Cairo Cheatsheet"
msgstr "# Hoja de ruta de Cairo"

#: src/ch00/cairo_cheatsheet/cairo_cheatsheet.md:3
msgid ""
"This chapter aims to provide a quick reference for the most common Cairo "
"constructs."
msgstr ""
"Este capítulo pretende ofrecer una referencia rápida para las construcciones "
"más comunes de Cairo."

#: src/ch00/cairo_cheatsheet/cairo_cheatsheet.md:5
msgid "<footer id=\"last-change\">Last change: 2023-10-31</footer>"
msgstr "<footer id=\"last-change\">Último cambio: 2023-10-31</footer>"

#: src/ch00/cairo_cheatsheet/felt.md:1
msgid "# Felt252"
msgstr "# Felt252"

#: src/ch00/cairo_cheatsheet/felt.md:3
msgid ""
"Felt252 is a fundamental data type in Cairo from which all other data types "
"are derived.\n"
"Felt252 can also be used to store short-string representations with a "
"maximum length of 31 characters."
msgstr ""
"Felt252 es un tipo de datos fundamental en Cairo del que se derivan todos "
"los demás tipos de datos.\n"
"Felt252 también se puede utilizar para almacenar representaciones de cadenas "
"cortas con una longitud máxima de 31 caracteres."

#: src/ch00/cairo_cheatsheet/felt.md:6 src/ch00/cairo_cheatsheet/arrays.md:20
#: src/ch02/hash-solidity-compatible.md:5
msgid "For example:"
msgstr "Por ejemplo:"

#: src/ch00/cairo_cheatsheet/felt.md:8
msgid ""
"```rust\n"
"    let felt: felt252 = 100;\n"
"    let felt_as_str = 'Hello Starknet!';\n"
"\n"
"    let felt = felt + felt_as_str;\n"
"```"
msgstr ""
"```rust\n"
"    let felt: felt252 = 100;\n"
"    let felt_as_str = 'Hello Starknet!';\n"
"\n"
"    let felt = felt + felt_as_str;\n"
"```"

#: src/ch00/cairo_cheatsheet/mapping.md:1
msgid "# Mapping"
msgstr "# Mapping"

#: src/ch00/cairo_cheatsheet/mapping.md:3
msgid ""
"The ```LegacyMap``` type can be used to represent a collection of key-value."
msgstr ""
"El tipo ```LegacyMap``` se puede utilizar para representar una colección de "
"key-value."

#: src/ch00/cairo_cheatsheet/mapping.md:5
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IMappingExample<TContractState> {\n"
"    fn register_user(ref self: TContractState, student_add: ContractAddress, "
"studentName: felt252);\n"
"    fn record_student_score(\n"
"        ref self: TContractState, student_add: ContractAddress, subject: "
"felt252, score: u16\n"
"    );\n"
"    fn view_student_name(self: @TContractState, student_add: "
"ContractAddress) -> felt252;\n"
"    fn view_student_score(\n"
"        self: @TContractState, student_add: ContractAddress, subject: "
"felt252\n"
"    ) -> u16;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod MappingContract {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        students_name: LegacyMap::<ContractAddress, felt252>,\n"
"        students_result_record: LegacyMap::<(ContractAddress, felt252), "
"u16>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl External of super::IMappingExample<ContractState> {\n"
"        fn register_user(\n"
"            ref self: ContractState, student_add: ContractAddress, "
"studentName: felt252\n"
"        ) {\n"
"            self.students_name.write(student_add, studentName);\n"
"        }\n"
"\n"
"        fn record_student_score(\n"
"            ref self: ContractState, student_add: ContractAddress, subject: "
"felt252, score: u16\n"
"        ) {\n"
"            self.students_result_record.write((student_add, subject), "
"score);\n"
"        }\n"
"\n"
"        fn view_student_name(self: @ContractState, student_add: "
"ContractAddress) -> felt252 {\n"
"            self.students_name.read(student_add)\n"
"        }\n"
"\n"
"        fn view_student_score(\n"
"            self: @ContractState, student_add: ContractAddress, subject: "
"felt252\n"
"        ) -> u16 {\n"
"            // for a 2D mapping its important to take note of the amount of "
"brackets being used.\n"
"            self.students_result_record.read((student_add, subject))\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IMappingExample<TContractState> {\n"
"    fn register_user(ref self: TContractState, student_add: ContractAddress, "
"studentName: felt252);\n"
"    fn record_student_score(\n"
"        ref self: TContractState, student_add: ContractAddress, subject: "
"felt252, score: u16\n"
"    );\n"
"    fn view_student_name(self: @TContractState, student_add: "
"ContractAddress) -> felt252;\n"
"    fn view_student_score(\n"
"        self: @TContractState, student_add: ContractAddress, subject: "
"felt252\n"
"    ) -> u16;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod MappingContract {\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        students_name: LegacyMap::<ContractAddress, felt252>,\n"
"        students_result_record: LegacyMap::<(ContractAddress, felt252), "
"u16>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl External of super::IMappingExample<ContractState> {\n"
"        fn register_user(\n"
"            ref self: ContractState, student_add: ContractAddress, "
"studentName: felt252\n"
"        ) {\n"
"            self.students_name.write(student_add, studentName);\n"
"        }\n"
"\n"
"        fn record_student_score(\n"
"            ref self: ContractState, student_add: ContractAddress, subject: "
"felt252, score: u16\n"
"        ) {\n"
"            self.students_result_record.write((student_add, subject), "
"score);\n"
"        }\n"
"\n"
"        fn view_student_name(self: @ContractState, student_add: "
"ContractAddress) -> felt252 {\n"
"            self.students_name.read(student_add)\n"
"        }\n"
"\n"
"        fn view_student_score(\n"
"            self: @ContractState, student_add: ContractAddress, subject: "
"felt252\n"
"        ) -> u16 {\n"
"            // for a 2D mapping its important to take note of the amount of "
"brackets being used.\n"
"            self.students_result_record.read((student_add, subject))\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch00/cairo_cheatsheet/arrays.md:1
msgid "# Arrays"
msgstr "# Arrays"

#: src/ch00/cairo_cheatsheet/arrays.md:3
msgid ""
"Arrays are collections of elements of the same type.\n"
"The possible operations on arrays are defined with the `array::ArrayTrait` "
"of the corelib:"
msgstr ""
"Los arrays son colecciones de elementos del mismo tipo.\n"
"Las posibles operaciones sobre arrays se definen con el `array::ArrayTrait` "
"de corelib:"

#: src/ch00/cairo_cheatsheet/arrays.md:6
msgid ""
"```rust\n"
"trait ArrayTrait<T> {\n"
"    fn new() -> Array<T>;\n"
"    fn append(ref self: Array<T>, value: T);\n"
"    fn pop_front(ref self: Array<T>) -> Option<T> nopanic;\n"
"    fn pop_front_consume(self: Array<T>) -> Option<(Array<T>, T)> nopanic;\n"
"    fn get(self: @Array<T>, index: usize) -> Option<Box<@T>>;\n"
"    fn at(self: @Array<T>, index: usize) -> @T;\n"
"    fn len(self: @Array<T>) -> usize;\n"
"    fn is_empty(self: @Array<T>) -> bool;\n"
"    fn span(self: @Array<T>) -> Span<T>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait ArrayTrait<T> {\n"
"    fn new() -> Array<T>;\n"
"    fn append(ref self: Array<T>, value: T);\n"
"    fn pop_front(ref self: Array<T>) -> Option<T> nopanic;\n"
"    fn pop_front_consume(self: Array<T>) -> Option<(Array<T>, T)> nopanic;\n"
"    fn get(self: @Array<T>, index: usize) -> Option<Box<@T>>;\n"
"    fn at(self: @Array<T>, index: usize) -> @T;\n"
"    fn len(self: @Array<T>) -> usize;\n"
"    fn is_empty(self: @Array<T>) -> bool;\n"
"    fn span(self: @Array<T>) -> Span<T>;\n"
"}\n"
"```"

#: src/ch00/cairo_cheatsheet/arrays.md:22
msgid ""
"```rust\n"
"fn array() -> bool {\n"
"    let mut arr = ArrayTrait::<u32>::new();\n"
"    arr.append(10);\n"
"    arr.append(20);\n"
"    arr.append(30);\n"
"\n"
"    assert(arr.len() == 3, 'array length should be 3');\n"
"\n"
"    let first_value = arr.pop_front().unwrap();\n"
"    assert(first_value == 10, 'first value should match');\n"
"\n"
"    let second_value = *arr.at(0);\n"
"    assert(second_value == 20, 'second value should match');\n"
"\n"
"    // Returns true if an array is empty, then false if it isn't.\n"
"    arr.is_empty()\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"fn array() -> bool {\n"
"    let mut arr = ArrayTrait::<u32>::new();\n"
"    arr.append(10);\n"
"    arr.append(20);\n"
"    arr.append(30);\n"
"\n"
"    assert(arr.len() == 3, 'array length should be 3');\n"
"\n"
"    let first_value = arr.pop_front().unwrap();\n"
"    assert(first_value == 10, 'first value should match');\n"
"\n"
"    let second_value = *arr.at(0);\n"
"    assert(second_value == 20, 'second value should match');\n"
"\n"
"    // Returns true if an array is empty, then false if it isn't.\n"
"    arr.is_empty()\n"
"}\n"
"```"

#: src/ch00/cairo_cheatsheet/loop.md:1
msgid "# Loop"
msgstr "# Loop"

#: src/ch00/cairo_cheatsheet/loop.md:3
msgid ""
"A loop specifies a block of code that will run repetitively until a halting "
"condition is encountered.\n"
"For example:"
msgstr ""
"Un bucle especifica un bloque de código que se ejecutará repetitivamente "
"hasta que se encuentre una condición de detención.\n"
"Por ejemplo:"

#: src/ch00/cairo_cheatsheet/loop.md:6
msgid ""
"```rust\n"
"    let mut arr = ArrayTrait::new();\n"
"\n"
"    // Same as ~ while (i < 10) arr.append(i++);\n"
"    let mut i: u32 = 0;\n"
"    let limit = 10;\n"
"    loop {\n"
"        if i == limit {\n"
"            break;\n"
"        };\n"
"\n"
"        arr.append(i);\n"
"\n"
"        i += 1;\n"
"    };\n"
"```"
msgstr ""
"```rust\n"
"    let mut arr = ArrayTrait::new();\n"
"\n"
"    // Same as ~ while (i < 10) arr.append(i++);\n"
"    let mut i: u32 = 0;\n"
"    let limit = 10;\n"
"    loop {\n"
"        if i == limit {\n"
"            break;\n"
"        };\n"
"\n"
"        arr.append(i);\n"
"\n"
"        i += 1;\n"
"    };\n"
"```"

#: src/ch00/cairo_cheatsheet/match.md:1
msgid "# Match"
msgstr "# Match"

#: src/ch00/cairo_cheatsheet/match.md:3
msgid ""
"The \"match\" expression in Cairo allows us to control the flow of our code "
"by comparing a felt data type or an enum against various patterns and then "
"running specific code based on the pattern that matches.\n"
"For example:"
msgstr ""
"La expresión \"match\" en Cairo nos permite controlar el flujo de nuestro "
"código comparando un tipo de datos sentido o una enumeración con varios "
"patrones y luego ejecutando código específico basado en el patrón que "
"coincide.\n"
"Por ejemplo:"

#: src/ch00/cairo_cheatsheet/match.md:6
msgid ""
"```rust\n"
"#[derive(Drop, Serde)]\n"
"enum Colour {\n"
"    Red,\n"
"    Blue,\n"
"    Green,\n"
"    Orange,\n"
"    Black\n"
"}\n"
"\n"
"#[derive(Drop, Serde)]\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter,\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"\n"
"fn specified_colour(colour: Colour) -> felt252 {\n"
"    let mut response: felt252 = '';\n"
"\n"
"    match colour {\n"
"        Colour::Red => { response = 'You passed in Red'; },\n"
"        Colour::Blue => { response = 'You passed in Blue'; },\n"
"        Colour::Green => { response = 'You passed in Green'; },\n"
"        Colour::Orange => { response = 'You passed in Orange'; },\n"
"        Colour::Black => { response = 'You passed in Black'; },\n"
"    };\n"
"\n"
"    response\n"
"}\n"
"\n"
"fn quiz(num: felt252) -> felt252 {\n"
"    let mut response: felt252 = '';\n"
"\n"
"    match num {\n"
"        0 => { response = 'You failed' },\n"
"        _ => { response = 'You Passed' },\n"
"    };\n"
"\n"
"    response\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Drop, Serde)]\n"
"enum Colour {\n"
"    Red,\n"
"    Blue,\n"
"    Green,\n"
"    Orange,\n"
"    Black\n"
"}\n"
"\n"
"#[derive(Drop, Serde)]\n"
"enum Coin {\n"
"    Penny,\n"
"    Nickel,\n"
"    Dime,\n"
"    Quarter,\n"
"}\n"
"\n"
"fn value_in_cents(coin: Coin) -> felt252 {\n"
"    match coin {\n"
"        Coin::Penny => 1,\n"
"        Coin::Nickel => 5,\n"
"        Coin::Dime => 10,\n"
"        Coin::Quarter => 25,\n"
"    }\n"
"}\n"
"\n"
"fn specified_colour(colour: Colour) -> felt252 {\n"
"    let mut response: felt252 = '';\n"
"\n"
"    match colour {\n"
"        Colour::Red => { response = 'You passed in Red'; },\n"
"        Colour::Blue => { response = 'You passed in Blue'; },\n"
"        Colour::Green => { response = 'You passed in Green'; },\n"
"        Colour::Orange => { response = 'You passed in Orange'; },\n"
"        Colour::Black => { response = 'You passed in Black'; },\n"
"    };\n"
"\n"
"    response\n"
"}\n"
"\n"
"fn quiz(num: felt252) -> felt252 {\n"
"    let mut response: felt252 = '';\n"
"\n"
"    match num {\n"
"        0 => { response = 'You failed' },\n"
"        _ => { response = 'You Passed' },\n"
"    };\n"
"\n"
"    response\n"
"}\n"
"```"

#: src/ch00/cairo_cheatsheet/tuples.md:1
msgid "# Tuples"
msgstr "# Tuples"

#: src/ch00/cairo_cheatsheet/tuples.md:3
msgid ""
"Tuples is a data type to group a fixed number of items of potentially "
"different types into a single compound structure. Unlike arrays, tuples have "
"a set length and can contain elements of varying types. Once a tuple is "
"created, its size cannot change.\n"
"For example:"
msgstr ""
"Las Tuplas es un tipo de datos para agrupar un número fijo de elementos de "
"tipos potencialmente diferentes en una única estructura compuesta. A "
"diferencia de las arrays, las tuplas tienen una longitud determinada y "
"pueden contener elementos de distintos tipos. Una vez creada una tupla, su "
"tamaño no puede cambiar.\n"
"Por ejemplo:"

#: src/ch00/cairo_cheatsheet/tuples.md:6
msgid ""
"```rust\n"
"    let address = \"0x000\";\n"
"    let age = 20;\n"
"    let active = true;\n"
"\n"
"    // Create tuple\n"
"    let user_tuple = (address, age, active);\n"
"\n"
"    // Access tuple\n"
"    let (address, age, active) = stored_tuple;\n"
"```"
msgstr ""
"```rust\n"
"    let address = \"0x000\";\n"
"    let age = 20;\n"
"    let active = true;\n"
"\n"
"    // Create tuple\n"
"    let user_tuple = (address, age, active);\n"
"\n"
"    // Access tuple\n"
"    let (address, age, active) = stored_tuple;\n"
"```"

#: src/ch00/cairo_cheatsheet/struct.md:1
msgid "# Struct"
msgstr "# Struct"

#: src/ch00/cairo_cheatsheet/struct.md:3
msgid ""
"A struct is a data type similar to tuple. Like tuples they can be used to "
"hold data of different types.\n"
"For example:"
msgstr ""
"Una estructura es un tipo de datos similar a una tupla. Al igual que las "
"tuplas, se pueden utilizar para contener datos de diferentes tipos.Por "
"ejemplo:"

#: src/ch00/cairo_cheatsheet/struct.md:6
msgid ""
"```rust\n"
"// With Store, you can store Data's structs in the storage part of "
"contracts.\n"
"#[derive(Drop, starknet::Store)]\n"
"struct Data {\n"
"    address: starknet::ContractAddress,\n"
"    age: u8\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// With Store, you can store Data's structs in the storage part of "
"contracts.\n"
"#[derive(Drop, starknet::Store)]\n"
"struct Data {\n"
"    address: starknet::ContractAddress,\n"
"    age: u8\n"
"}\n"
"```"

#: src/ch00/cairo_cheatsheet/type_casting.md:1
msgid "# Type casting"
msgstr "# Conversión de Tipos"

#: src/ch00/cairo_cheatsheet/type_casting.md:3
msgid ""
"Cairo supports the conversion from one scalar types to another by using the "
"into and try_into methods.\n"
"`traits::Into` is used for conversion from a smaller data type to a larger "
"data type, while `traits::TryInto` is used when converting from a larger to "
"a smaller type that might not fit. \n"
"For example:"
msgstr ""
"Cairo admite la conversión de un tipo escalar a otro mediante el uso de los "
"métodos into y try_into.\n"
"`traits::Into` se usa para la conversión de un tipo de datos más pequeño a "
"un tipo de datos más grande, mientras que `traits::TryInto` se usa para "
"convertir de un tipo más grande a uno más pequeño que podría no encajar.\n"
"Por ejemplo:"

#: src/ch00/cairo_cheatsheet/type_casting.md:7
msgid ""
"```rust\n"
"    let a_number: u32 = 15;\n"
"    let my_felt252 = 15;\n"
"\n"
"    // Since a u32 might not fit in a u8 and a u16, we need to use "
"try_into,\n"
"    // then unwrap the Option<T> type thats returned.\n"
"    let new_u8: u8 = a_number.try_into().unwrap();\n"
"    let new_u16: u16 = a_number.try_into().unwrap();\n"
"\n"
"    // since new_u32 is the of the same type (u32) as rand_number, we can "
"directly assign them,\n"
"    // or use the .into() method.\n"
"    let new_u32: u32 = a_number;\n"
"\n"
"    // When typecasting from a smaller size to an equal or larger size we "
"use the .into() method.\n"
"    // Note: u64 and u128 are larger than u32, so a u32 type will always fit "
"into them.\n"
"    let new_u64: u64 = a_number.into();\n"
"    let new_u128: u128 = a_number.into();\n"
"\n"
"    // Since a felt252 is smaller than a u256, we can use the into() method\n"
"    let new_u256: u256 = my_felt252.into();\n"
"    let new_felt252: felt252 = new_u16.into();\n"
"\n"
"    //note a usize is smaller than a felt so we use the try_into\n"
"    let new_usize: usize = my_felt252.try_into().unwrap();\n"
"```"
msgstr ""
"```rust\n"
"    let a_number: u32 = 15;\n"
"    let my_felt252 = 15;\n"
"\n"
"    // Since a u32 might not fit in a u8 and a u16, we need to use "
"try_into,\n"
"    // then unwrap the Option<T> type thats returned.\n"
"    let new_u8: u8 = a_number.try_into().unwrap();\n"
"    let new_u16: u16 = a_number.try_into().unwrap();\n"
"\n"
"    // since new_u32 is the of the same type (u32) as rand_number, we can "
"directly assign them,\n"
"    // or use the .into() method.\n"
"    let new_u32: u32 = a_number;\n"
"\n"
"    // When typecasting from a smaller size to an equal or larger size we "
"use the .into() method.\n"
"    // Note: u64 and u128 are larger than u32, so a u32 type will always fit "
"into them.\n"
"    let new_u64: u64 = a_number.into();\n"
"    let new_u128: u128 = a_number.into();\n"
"\n"
"    // Since a felt252 is smaller than a u256, we can use the into() method\n"
"    let new_u256: u256 = my_felt252.into();\n"
"    let new_felt252: felt252 = new_u16.into();\n"
"\n"
"    //note a usize is smaller than a felt so we use the try_into\n"
"    let new_usize: usize = my_felt252.try_into().unwrap();\n"
"```"

#: src/components/how_to.md:1
msgid "# Components How-To"
msgstr "# Cómo hacer Componentes"

#: src/components/how_to.md:3
msgid ""
"Components are like modular addons that can be snapped into contracts to add "
"reusable logic, storage, and events.\n"
"They are used to separate the core logic from common functionalities, "
"simplifying the contract's code and making it easier to read and maintain.\n"
"It also reduces the risk of bugs and vulnerabilities by using well-tested "
"components."
msgstr ""
"Los componentes son como complementos modulares que se pueden integrar en "
"contratos para agregar lógica, almacenamiento y eventos reutilizables.\n"
"Se utilizan para separar la lógica central de las funcionalidades comunes, "
"simplificando el código del contrato y haciéndolo más fácil de leer y "
"mantener.\n"
"También reduce el riesgo de errores y vulnerabilidades mediante el uso de "
"componentes bien probados."

#: src/components/how_to.md:7
msgid "Key characteristics:"
msgstr "Caracteristicas claves:"

#: src/components/how_to.md:8
msgid ""
"- Modularity: Easily pluggable into multiple contracts.\n"
"- Reusable Logic: Encapsulates specific functionalities.\n"
"- Not Standalone: Cannot be declared or deployed independently."
msgstr ""
"- Modularidad: Fácilmente conectable a múltiples contratos.\n"
"- Lógica Reutilizable: Encapsula funcionalidades específicas.\n"
"- No autónomo: no se puede declarar ni implementar de forma independiente."

#: src/components/how_to.md:12
msgid "## How to create a component"
msgstr "## Cómo crear un componente"

#: src/components/how_to.md:14
msgid ""
"The following example shows a simple `Switchable` component that can be used "
"to add a switch that can be either on or off.\n"
"It contains a storage variable `switchable_value`, a function `switch` and "
"an event `Switch`."
msgstr ""
"El siguiente ejemplo muestra un componente `Switchable` simple que se puede "
"usar para agregar un interruptor que puede estar encendido o apagado.\n"
"Contiene una variable de almacenamiento `switchable_value`, una función "
"`switch` y un evento `Switch`."

#: src/components/how_to.md:17
msgid ""
"> It is a good practice to prefix the component storage variables with the "
"component name to [avoid collisions](./collisions.md)."
msgstr ""
"> Es una buena práctica anteponer las variables de almacenamiento del "
"componente con el nombre del componente para [evitar colisiones] (./"
"collisions.md)."

#: src/components/how_to.md:19
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISwitchable<TContractState> {\n"
"    fn is_on(self: @TContractState) -> bool;\n"
"    fn switch(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::component]\n"
"mod switchable_component {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        switchable_value: bool,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct SwitchEvent {}\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        SwitchEvent: SwitchEvent,\n"
"    }\n"
"\n"
"    #[embeddable_as(Switchable)]\n"
"    impl SwitchableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::ISwitchable<ComponentState<TContractState>> {\n"
"        fn is_on(self: @ComponentState<TContractState>) -> bool {\n"
"            self.switchable_value.read()\n"
"        }\n"
"\n"
"        fn switch(ref self: ComponentState<TContractState>) {\n"
"            self.switchable_value.write(!self.switchable_value.read());\n"
"            self.emit(Event::SwitchEvent(SwitchEvent {}));\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl SwitchableInternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of SwitchableInternalTrait<TContractState> {\n"
"        fn _off(ref self: ComponentState<TContractState>) {\n"
"            self.switchable_value.write(false);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISwitchable<TContractState> {\n"
"    fn is_on(self: @TContractState) -> bool;\n"
"    fn switch(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::component]\n"
"mod switchable_component {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        switchable_value: bool,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct SwitchEvent {}\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        SwitchEvent: SwitchEvent,\n"
"    }\n"
"\n"
"    #[embeddable_as(Switchable)]\n"
"    impl SwitchableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::ISwitchable<ComponentState<TContractState>> {\n"
"        fn is_on(self: @ComponentState<TContractState>) -> bool {\n"
"            self.switchable_value.read()\n"
"        }\n"
"\n"
"        fn switch(ref self: ComponentState<TContractState>) {\n"
"            self.switchable_value.write(!self.switchable_value.read());\n"
"            self.emit(Event::SwitchEvent(SwitchEvent {}));\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl SwitchableInternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of SwitchableInternalTrait<TContractState> {\n"
"        fn _off(ref self: ComponentState<TContractState>) {\n"
"            self.switchable_value.write(false);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/components/how_to.md:67
msgid ""
"A component in itself is really similar to a contract, it *can* also have:"
msgstr ""
"Un componente en sí mismo es muy similar a un contrato, *puede* también "
"tener:"

#: src/components/how_to.md:68
msgid ""
"- An interface defining entrypoints "
"(`ISwitchableComponent<TContractState>`)\n"
"- A Storage struct\n"
"- Events\n"
"- Internal functions"
msgstr ""
"- Una interfaz que define puntos de entrada "
"(`ISwitchableComponent<TContractState>`)\n"
"- Una estructura de Storage\n"
"- Eventos\n"
"- Funciones internas"

#: src/components/how_to.md:73
msgid ""
"It don't have a constructor, but you can create a `_init` internal function "
"and call it from the contract's constructor. In the previous example, the "
"`_off` function is used this way."
msgstr ""
"No tiene constructor, pero puedes crear una función interna `_init` y "
"llamarla desde el constructor del contrato. En el ejemplo anterior, la "
"función `_off` se usa de esta manera."

#: src/components/how_to.md:75
msgid ""
"> It's currently not possible to use the same component multiple times in "
"the same contract.\n"
"> This is a known limitation that may be lifted in the future.\n"
"> \n"
"> For now, you can view components as an implementation of a specific "
"interface/feature (`Ownable`, `Upgradeable`, ... `~able`).\n"
"> This is why we called it `Switchable` and not `Switch`; The contract *is "
"switchable*, not *has a switch*."
msgstr ""
"> Actualmente no es posible utilizar el mismo componente varias veces en el "
"mismo contrato.\n"
"> Esta es una limitación conocida que puede eliminarse en el futuro.\n"
">\n"
"> Por ahora, puede ver los componentes como una implementación de una "
"interfaz/función específica (`Ownable`, `Upgradeable`, ... `~able`).\n"
"> Por eso lo llamamos `Switchable` y no `Switch`; El contrato *es "
"switchable*, no *tiene un switch*."

#: src/components/how_to.md:81
msgid "## How to use a component"
msgstr "## Cómo utilizar un componente"

#: src/components/how_to.md:83
msgid ""
"Now that we have a component, we can use it in a contract.\n"
"The following contract incorporates the `Switchable` component:"
msgstr ""
"Ahora que tenemos un componente, podemos usarlo en un contrato.\n"
"El siguiente contrato incorpora el componente `Switchable`:"

#: src/components/how_to.md:86
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod SwitchContract {\n"
"    use components::switchable::switchable_component;\n"
"\n"
"    component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SwitchableImpl = switchable_component::Switchable<ContractState>;\n"
"    impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch._off();\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        SwitchableEvent: switchable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use components::switchable::switchable_component::"
"SwitchableInternalTrait;\n"
"#     use components::switchable::ISwitchable;\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use super::SwitchContract;\n"
"# \n"
"#     fn STATE() -> SwitchContract::ContractState {\n"
"#         SwitchContract::contract_state_for_testing()\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let state = STATE();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_switch() {\n"
"#         let mut state = STATE();\n"
"# \n"
"#         state.switch();\n"
"#         assert(state.is_on() == true, 'The switch should be on');\n"
"# \n"
"#         state.switch();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_value() {\n"
"#         let mut state = STATE();\n"
"#         assert(state.is_on() == state.switch.switchable_value.read(), "
"'Wrong value');\n"
"# \n"
"#         state.switch.switch();\n"
"#         assert(state.is_on() == state.switch.switchable_value.read(), "
"'Wrong value');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_internal_off() {\n"
"#         let mut state = STATE();\n"
"# \n"
"#         state.switch._off();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"# \n"
"#         state.switch();\n"
"#         state.switch._off();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod SwitchContract {\n"
"    use components::switchable::switchable_component;\n"
"\n"
"    component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SwitchableImpl = switchable_component::Switchable<ContractState>;\n"
"    impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch._off();\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        SwitchableEvent: switchable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use components::switchable::switchable_component::"
"SwitchableInternalTrait;\n"
"#     use components::switchable::ISwitchable;\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use super::SwitchContract;\n"
"# \n"
"#     fn STATE() -> SwitchContract::ContractState {\n"
"#         SwitchContract::contract_state_for_testing()\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let state = STATE();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_switch() {\n"
"#         let mut state = STATE();\n"
"# \n"
"#         state.switch();\n"
"#         assert(state.is_on() == true, 'The switch should be on');\n"
"# \n"
"#         state.switch();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_value() {\n"
"#         let mut state = STATE();\n"
"#         assert(state.is_on() == state.switch.switchable_value.read(), "
"'Wrong value');\n"
"# \n"
"#         state.switch.switch();\n"
"#         assert(state.is_on() == state.switch.switchable_value.read(), "
"'Wrong value');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_internal_off() {\n"
"#         let mut state = STATE();\n"
"# \n"
"#         state.switch._off();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"# \n"
"#         state.switch();\n"
"#         state.switch._off();\n"
"#         assert(state.is_on() == false, 'The switch should be off');\n"
"#     }\n"
"# }\n"
"```"

#: src/components/how_to.md:171
msgid "## Deep dive into components"
msgstr "## Profundización en los componentes"

#: src/components/how_to.md:173
msgid ""
"You can find more in-depth information about components in the [Cairo book - "
"Components](https://book.cairo-lang.org/ch99-01-05-00-components.html)."
msgstr ""
"Puede encontrar información más detallada sobre los componentes en el [Cairo "
"book - Components](https://book.cairo-lang.org/ch99-01-05-00-components."
"html)."

#: src/components/dependencies.md:1
msgid "# Components Dependencies"
msgstr "# Dependencias de Componentes"

#: src/components/dependencies.md:3
msgid ""
"A component with a dependency on a trait T can be used in a contract as long "
"as the contract implements the trait T."
msgstr ""
"Un componente que depende de un trait T se puede utilizar en un contrato "
"siempre que el contrato implemente el trait T."

#: src/components/dependencies.md:5
msgid "We will use a new `Countable` component as an example:"
msgstr "Usaremos un nuevo componente `Countable` como ejemplo:"

#: src/components/dependencies.md:7
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ICountable<TContractState> {\n"
"    fn get(self: @TContractState) -> u32;\n"
"    fn increment(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::component]\n"
"mod countable_component {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        countable_value: u32,\n"
"    }\n"
"\n"
"    #[embeddable_as(Countable)]\n"
"    impl CountableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::ICountable<ComponentState<TContractState>> {\n"
"        fn get(self: @ComponentState<TContractState>) -> u32 {\n"
"            self.countable_value.read()\n"
"        }\n"
"\n"
"        fn increment(ref self: ComponentState<TContractState>) {\n"
"            self.countable_value.write(self.countable_value.read() + 1);\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ICountable<TContractState> {\n"
"    fn get(self: @TContractState) -> u32;\n"
"    fn increment(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::component]\n"
"mod countable_component {\n"
"    #[storage]\n"
"    struct Storage {\n"
"        countable_value: u32,\n"
"    }\n"
"\n"
"    #[embeddable_as(Countable)]\n"
"    impl CountableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::ICountable<ComponentState<TContractState>> {\n"
"        fn get(self: @ComponentState<TContractState>) -> u32 {\n"
"            self.countable_value.read()\n"
"        }\n"
"\n"
"        fn increment(ref self: ComponentState<TContractState>) {\n"
"            self.countable_value.write(self.countable_value.read() + 1);\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/components/dependencies.md:36
msgid ""
"We want to add a way to enable or disable the counter, in a way that calling "
"`increment` on a disabled counter will not increment the counter.\n"
"But we don't want to add this switch logic to the `Countable` component "
"itself.\n"
"We instead add the trait `Switchable` as a dependency to the `Countable` "
"component."
msgstr ""
"Queremos agregar una forma de habilitar o deshabilitar el contador, de "
"manera que llamar a `increment` en un contador deshabilitado no incremente "
"el contador.\n"
"Pero no queremos agregar esta lógica de cambio al componente`Countable`.\n"
"En su lugar, agregamos el trait `Switchable` como una dependencia del "
"componente `Countable`."

#: src/components/dependencies.md:40
msgid "#### Implementation of the trait in the contract"
msgstr "#### Implementación del trait en el contrato"

#: src/components/dependencies.md:42
msgid "We first define the `ISwitchable` trait:"
msgstr "Primero definimos el trait `ISwitchable`:"

#: src/components/dependencies.md:44
msgid ""
"```rust\n"
"trait ISwitchable<TContractState> {\n"
"    fn is_on(self: @TContractState) -> bool;\n"
"    fn switch(ref self: TContractState);\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait ISwitchable<TContractState> {\n"
"    fn is_on(self: @TContractState) -> bool;\n"
"    fn switch(ref self: TContractState);\n"
"}\n"
"```"

#: src/components/dependencies.md:51
msgid ""
"Then we can modify the implementation of the `Countable` component to depend "
"on the `ISwitchable` trait:"
msgstr ""
"Luego podemos modificar la implementación del componente `Countable` para "
"que dependa del rasgo `ISwitchable`:"

#: src/components/dependencies.md:53
msgid ""
"```rust\n"
"# #[starknet::component]\n"
"# mod countable_component {\n"
"#     use components::countable::ICountable;\n"
"#     use components::switchable::ISwitchable;\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         countable_value: u32,\n"
"#     }\n"
"# \n"
"    #[embeddable_as(Countable)]\n"
"    impl CountableImpl<\n"
"        TContractState, +HasComponent<TContractState>, "
"+ISwitchable<TContractState>\n"
"    > of ICountable<ComponentState<TContractState>> {\n"
"        fn get(self: @ComponentState<TContractState>) -> u32 {\n"
"            self.countable_value.read()\n"
"        }\n"
"\n"
"        fn increment(ref self: ComponentState<TContractState>) {\n"
"            if (self.get_contract().is_on()) {\n"
"                self.countable_value.write(self.countable_value.read() + "
"1);\n"
"            }\n"
"        }\n"
"    }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# #[starknet::component]\n"
"# mod countable_component {\n"
"#     use components::countable::ICountable;\n"
"#     use components::switchable::ISwitchable;\n"
"# \n"
"#     #[storage]\n"
"#     struct Storage {\n"
"#         countable_value: u32,\n"
"#     }\n"
"# \n"
"    #[embeddable_as(Countable)]\n"
"    impl CountableImpl<\n"
"        TContractState, +HasComponent<TContractState>, "
"+ISwitchable<TContractState>\n"
"    > of ICountable<ComponentState<TContractState>> {\n"
"        fn get(self: @ComponentState<TContractState>) -> u32 {\n"
"            self.countable_value.read()\n"
"        }\n"
"\n"
"        fn increment(ref self: ComponentState<TContractState>) {\n"
"            if (self.get_contract().is_on()) {\n"
"                self.countable_value.write(self.countable_value.read() + "
"1);\n"
"            }\n"
"        }\n"
"    }\n"
"# }\n"
"```"

#: src/components/dependencies.md:81
msgid ""
"A contract that uses the `Countable` component must implement the "
"`ISwitchable` trait:"
msgstr ""
"Un contrato que utilice el componente `Countable` debe implementar el trait "
"`ISwitchable`:"

#: src/components/dependencies.md:83
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod CountableContract {\n"
"    use components_dependencies::countable_dep_switch::countable_component;\n"
"    use components::switchable::ISwitchable;\n"
"\n"
"    component!(path: countable_component, storage: counter, event: "
"CountableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CountableImpl = countable_component::Countable<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        counter: countable_component::Storage,\n"
"        switch: bool\n"
"    }\n"
"\n"
"    // Implementation of the dependency:\n"
"    #[abi(embed_v0)]\n"
"    impl Switchable of ISwitchable<ContractState> {\n"
"        fn switch(ref self: ContractState) {\n"
"            self.switch.write(!self.switch.read());\n"
"        }\n"
"\n"
"        fn is_on(self: @ContractState) -> bool {\n"
"            self.switch.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch.write(false);\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        CountableEvent: countable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::CountableContract;\n"
"#     use components::countable::{ICountable, ICountableDispatcher, "
"ICountableDispatcherTrait};\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, "
"array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (ICountableDispatcher { contract_address }, ISwitchableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         assert(counter.get() == 0, 'Counter != 0');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_off() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 0, 'Counter incremented');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_on() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"#         assert(switch.is_on() == true, 'Switch != true');\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_multiple_switches() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 3, 'Counter did not increment');\n"
"# \n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 6, 'Counter did not increment');\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod CountableContract {\n"
"    use components_dependencies::countable_dep_switch::countable_component;\n"
"    use components::switchable::ISwitchable;\n"
"\n"
"    component!(path: countable_component, storage: counter, event: "
"CountableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CountableImpl = countable_component::Countable<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        counter: countable_component::Storage,\n"
"        switch: bool\n"
"    }\n"
"\n"
"    // Implementation of the dependency:\n"
"    #[abi(embed_v0)]\n"
"    impl Switchable of ISwitchable<ContractState> {\n"
"        fn switch(ref self: ContractState) {\n"
"            self.switch.write(!self.switch.read());\n"
"        }\n"
"\n"
"        fn is_on(self: @ContractState) -> bool {\n"
"            self.switch.read()\n"
"        }\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch.write(false);\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        CountableEvent: countable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::CountableContract;\n"
"#     use components::countable::{ICountable, ICountableDispatcher, "
"ICountableDispatcherTrait};\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, "
"array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (ICountableDispatcher { contract_address }, ISwitchableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         assert(counter.get() == 0, 'Counter != 0');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_off() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 0, 'Counter incremented');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_on() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"#         assert(switch.is_on() == true, 'Switch != true');\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_multiple_switches() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 3, 'Counter did not increment');\n"
"# \n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 6, 'Counter did not increment');\n"
"#     }\n"
"# }\n"
"```"

#: src/components/dependencies.md:201
msgid "#### Implementation of the trait in another component"
msgstr "#### Implementación del trait en otro componente"

#: src/components/dependencies.md:203
msgid ""
"In the previous example, we implemented the `ISwitchable` trait in the "
"contract."
msgstr ""
"En el ejemplo anterior, implementamos el rasgo `ISwitchable` en el contrato."

#: src/components/dependencies.md:205
msgid ""
"We already implemented a [`Switchable`](./how_to.md) component that provide "
"an implementation of the `ISwitchable` trait.\n"
"By using the `Switchable` component in a contract, we embed the "
"implementation of the `ISwitchable` trait in the contract and resolve the "
"dependency on the `ISwitchable` trait."
msgstr ""
"Ya hemos implementado un componente [`Switchable`](./how_to.md) que "
"proporciona una implementación del trait `ISwitchable`.\n"
"Al utilizar el componente `Switchable` en un contrato, incrustamos la "
"implementación del trait `ISwitchable` en el contrato y resolvemos la "
"dependencia del trait `ISwitchable`."

#: src/components/dependencies.md:208
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod CountableContract {\n"
"    use components_dependencies::countable_dep_switch::countable_component;\n"
"    use components::switchable::switchable_component;\n"
"\n"
"    component!(path: countable_component, storage: counter, event: "
"CountableEvent);\n"
"    component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CountableImpl = countable_component::Countable<ContractState>;\n"
"    #[abi(embed_v0)]\n"
"    impl SwitchableImpl = switchable_component::Switchable<ContractState>;\n"
"    impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        counter: countable_component::Storage,\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch._off();\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        CountableEvent: countable_component::Event,\n"
"        SwitchableEvent: switchable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::CountableContract;\n"
"#     use components::countable::{ICountable, ICountableDispatcher, "
"ICountableDispatcherTrait};\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, "
"array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (ICountableDispatcher { contract_address }, ISwitchableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         assert(counter.get() == 0, 'Counter != 0');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_off() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 0, 'Counter incremented');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_on() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"#         assert(switch.is_on() == true, 'Switch != true');\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(3000000)]\n"
"#     fn test_increment_multiple_switches() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 3, 'Counter did not increment');\n"
"# \n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 6, 'Counter did not increment');\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod CountableContract {\n"
"    use components_dependencies::countable_dep_switch::countable_component;\n"
"    use components::switchable::switchable_component;\n"
"\n"
"    component!(path: countable_component, storage: counter, event: "
"CountableEvent);\n"
"    component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CountableImpl = countable_component::Countable<ContractState>;\n"
"    #[abi(embed_v0)]\n"
"    impl SwitchableImpl = switchable_component::Switchable<ContractState>;\n"
"    impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        counter: countable_component::Storage,\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch._off();\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        CountableEvent: countable_component::Event,\n"
"        SwitchableEvent: switchable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::CountableContract;\n"
"#     use components::countable::{ICountable, ICountableDispatcher, "
"ICountableDispatcherTrait};\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, "
"array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (ICountableDispatcher { contract_address }, ISwitchableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         assert(counter.get() == 0, 'Counter != 0');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_off() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 0, 'Counter incremented');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_on() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"#         assert(switch.is_on() == true, 'Switch != true');\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(3000000)]\n"
"#     fn test_increment_multiple_switches() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 3, 'Counter did not increment');\n"
"# \n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 6, 'Counter did not increment');\n"
"#     }\n"
"# }\n"
"```"

#: src/components/dependencies.md:320
msgid "#### Dependency on other components internal functions"
msgstr "#### Dependencia de funciones internas de otros componentes"

#: src/components/dependencies.md:322
msgid ""
"The previous example shows how to use the `ISwitchable` trait implementation "
"from the `Switchable` component inside the `Countable` component by "
"embedding the implementation in the contract.\n"
"However, suppose we would like to turn off the switch after each increment. "
"There's no `set` function in the `ISwitchable` trait, so we can't do it "
"directly."
msgstr ""
"El ejemplo anterior muestra cómo utilizar la implementación del rasgo "
"`ISwitchable` del componente `Switchable` dentro del componente `Countable` "
"incrustando la implementación en el contrato.\n"
"Sin embargo, supongamos que queremos apagar el interruptor después de cada "
"incremento. No hay función `set` en el trait `ISwitchable`, así que no "
"podemos hacerlo directamente."

#: src/components/dependencies.md:325
msgid ""
"But the Switchable component implements the internal function `_off` from "
"the `SwitchableInternalTrait` that set the switch to `false`.\n"
"We can't embed `SwitchableInternalImpl`, but we can add `switchable::"
"HasComponent<TContractState>` as a dependency inside `CountableImpl`."
msgstr ""
"Pero el componente Switchable implementa la función interna `_off` del "
"`SwitchableInternalTrait` que establece el interruptor a `false`.\n"
"No podemos incrustar `SwitchableInternalImpl`, pero podemos añadir "
"`switchable::HasComponent<TContractState>` como dependencia dentro de "
"`CountableImpl`."

#: src/components/dependencies.md:328
msgid ""
"We make the `Countable` component depend on the `Switchable` component.\n"
"This will allow to do `switchable::ComponentState<TContractState>` -> "
"`TContractState` -> `countable::ComponentState<TcontractState>` and access "
"the internal functions of the `Switchable` component inside the `Countable` "
"component:"
msgstr ""
"Hacemos que el componente `Countable` dependa del componente `Switchable`.\n"
"Esto permitirá hacer `switchable::ComponentState<TContractState>` -> "
"`TContractState` -> `countable::ComponentState<TcontractState>` y acceder a "
"las funciones internas del componente `Switchable` dentro del componente "
"`Countable`:"

#: src/components/dependencies.md:331
msgid ""
"```rust\n"
"#[starknet::component]\n"
"mod countable_component {\n"
"    use components::countable::ICountable;\n"
"    use components::switchable::ISwitchable;\n"
"\n"
"    // Explicitly depends on a component and not a trait\n"
"    use components::switchable::switchable_component;\n"
"    use switchable_component::{SwitchableInternalImpl, "
"SwitchableInternalTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        countable_value: u32,\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl GetSwitchable<\n"
"        TContractState,\n"
"        +HasComponent<TContractState>,\n"
"        +switchable_component::HasComponent<TContractState>,\n"
"        +Drop<TContractState>\n"
"    > of GetSwitchableTrait<TContractState> {\n"
"        fn get_switchable(\n"
"            self: @ComponentState<TContractState>\n"
"        ) -> @switchable_component::ComponentState<TContractState> {\n"
"            let contract = self.get_contract();\n"
"            switchable_component::HasComponent::<TContractState>::"
"get_component(contract)\n"
"        }\n"
"\n"
"        fn get_switchable_mut(\n"
"            ref self: ComponentState<TContractState>\n"
"        ) -> switchable_component::ComponentState<TContractState> {\n"
"            let mut contract = self.get_contract_mut();\n"
"            switchable_component::HasComponent::<TContractState>::"
"get_component_mut(ref contract)\n"
"        }\n"
"    }\n"
"\n"
"    #[embeddable_as(Countable)]\n"
"    impl CountableImpl<\n"
"        TContractState,\n"
"        +HasComponent<TContractState>,\n"
"        +ISwitchable<TContractState>,\n"
"        +switchable_component::HasComponent<TContractState>,\n"
"        +Drop<TContractState>\n"
"    > of ICountable<ComponentState<TContractState>> {\n"
"        fn get(self: @ComponentState<TContractState>) -> u32 {\n"
"            self.countable_value.read()\n"
"        }\n"
"\n"
"        fn increment(ref self: ComponentState<TContractState>) {\n"
"            if (self.get_contract().is_on()) {\n"
"                self.countable_value.write(self.countable_value.read() + "
"1);\n"
"\n"
"                // use the switchable component internal function\n"
"                let mut switch = self.get_switchable_mut();\n"
"                switch._off();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::component]\n"
"mod countable_component {\n"
"    use components::countable::ICountable;\n"
"    use components::switchable::ISwitchable;\n"
"\n"
"    // Explicitly depends on a component and not a trait\n"
"    use components::switchable::switchable_component;\n"
"    use switchable_component::{SwitchableInternalImpl, "
"SwitchableInternalTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        countable_value: u32,\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl GetSwitchable<\n"
"        TContractState,\n"
"        +HasComponent<TContractState>,\n"
"        +switchable_component::HasComponent<TContractState>,\n"
"        +Drop<TContractState>\n"
"    > of GetSwitchableTrait<TContractState> {\n"
"        fn get_switchable(\n"
"            self: @ComponentState<TContractState>\n"
"        ) -> @switchable_component::ComponentState<TContractState> {\n"
"            let contract = self.get_contract();\n"
"            switchable_component::HasComponent::<TContractState>::"
"get_component(contract)\n"
"        }\n"
"\n"
"        fn get_switchable_mut(\n"
"            ref self: ComponentState<TContractState>\n"
"        ) -> switchable_component::ComponentState<TContractState> {\n"
"            let mut contract = self.get_contract_mut();\n"
"            switchable_component::HasComponent::<TContractState>::"
"get_component_mut(ref contract)\n"
"        }\n"
"    }\n"
"\n"
"    #[embeddable_as(Countable)]\n"
"    impl CountableImpl<\n"
"        TContractState,\n"
"        +HasComponent<TContractState>,\n"
"        +ISwitchable<TContractState>,\n"
"        +switchable_component::HasComponent<TContractState>,\n"
"        +Drop<TContractState>\n"
"    > of ICountable<ComponentState<TContractState>> {\n"
"        fn get(self: @ComponentState<TContractState>) -> u32 {\n"
"            self.countable_value.read()\n"
"        }\n"
"\n"
"        fn increment(ref self: ComponentState<TContractState>) {\n"
"            if (self.get_contract().is_on()) {\n"
"                self.countable_value.write(self.countable_value.read() + "
"1);\n"
"\n"
"                // use the switchable component internal function\n"
"                let mut switch = self.get_switchable_mut();\n"
"                switch._off();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/components/dependencies.md:393
msgid ""
"The contract remains the same that the previous example, but the "
"implementation of the `Countable` component is different:"
msgstr ""
"El contrato sigue siendo el mismo que en el ejemplo anterior, pero la "
"implementación del componente `Countable` es diferente:"

#: src/components/dependencies.md:394
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod CountableContract {\n"
"    use components_dependencies::countable_internal_dep_switch::"
"countable_component;\n"
"    use components::switchable::switchable_component;\n"
"\n"
"    component!(path: countable_component, storage: counter, event: "
"CountableEvent);\n"
"    component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CountableImpl = countable_component::Countable<ContractState>;\n"
"    #[abi(embed_v0)]\n"
"    impl SwitchableImpl = switchable_component::Switchable<ContractState>;\n"
"    impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        counter: countable_component::Storage,\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch._off();\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        CountableEvent: countable_component::Event,\n"
"        SwitchableEvent: switchable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::CountableContract;\n"
"#     use components::countable::{ICountable, ICountableDispatcher, "
"ICountableDispatcherTrait};\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, "
"array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (ICountableDispatcher { contract_address }, ISwitchableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         assert(counter.get() == 0, 'Counter != 0');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_off() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 0, 'Counter incremented');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_on() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"#         assert(switch.is_on() == true, 'Switch != true');\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"# \n"
"#         // The counter turned the switch off.\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(3000000)]\n"
"#     fn test_increment_multiple_switches() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment(); // off\n"
"#         counter.increment(); // off\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"# \n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 3, 'Counter did not increment');\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod CountableContract {\n"
"    use components_dependencies::countable_internal_dep_switch::"
"countable_component;\n"
"    use components::switchable::switchable_component;\n"
"\n"
"    component!(path: countable_component, storage: counter, event: "
"CountableEvent);\n"
"    component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl CountableImpl = countable_component::Countable<ContractState>;\n"
"    #[abi(embed_v0)]\n"
"    impl SwitchableImpl = switchable_component::Switchable<ContractState>;\n"
"    impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        counter: countable_component::Storage,\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.switch._off();\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        CountableEvent: countable_component::Event,\n"
"        SwitchableEvent: switchable_component::Event,\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::CountableContract;\n"
"#     use components::countable::{ICountable, ICountableDispatcher, "
"ICountableDispatcherTrait};\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ICountableDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             CountableContract::TEST_CLASS_HASH.try_into().unwrap(), 0, "
"array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (ICountableDispatcher { contract_address }, ISwitchableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         assert(counter.get() == 0, 'Counter != 0');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_off() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 0, 'Counter incremented');\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_increment_switch_on() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"#         assert(switch.is_on() == true, 'Switch != true');\n"
"# \n"
"#         counter.increment();\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"# \n"
"#         // The counter turned the switch off.\n"
"#         assert(switch.is_on() == false, 'Switch != false');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(3000000)]\n"
"#     fn test_increment_multiple_switches() {\n"
"#         let (mut counter, mut switch) = deploy();\n"
"# \n"
"#         switch.switch();\n"
"# \n"
"#         counter.increment();\n"
"#         counter.increment(); // off\n"
"#         counter.increment(); // off\n"
"#         assert(counter.get() == 1, 'Counter did not increment');\n"
"# \n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         switch.switch();\n"
"#         counter.increment();\n"
"#         counter.increment();\n"
"#         assert(counter.get() == 3, 'Counter did not increment');\n"
"#     }\n"
"# }\n"
"```"

#: src/components/collisions.md:1
msgid "# Component-Contract Storage Collisions"
msgstr "# Colisiones Componente-Contrato de Almacenamiento"

#: src/components/collisions.md:3
msgid "Components can declare their own storage variables."
msgstr ""
"Los componentes pueden declarar sus propias variables de almacenamiento."

#: src/components/collisions.md:5
msgid ""
"When a contract use a component, the component storage is merged with the "
"contract storage.\n"
"The storage layout is only determined by the variables names, so variables "
"with the same name will collide."
msgstr ""
"Cuando un contrato utiliza un componente, el almacenamiento del componente "
"se fusiona con el almacenamiento del contrato.\n"
"La disposición del almacenamiento sólo está determinada por los nombres de "
"las variables, por lo que las variables con el mismo nombre colisionarán."

#: src/components/collisions.md:8
msgid ""
"> In a future release, the `#[substorage(v1)]` will determine the storage "
"layout based on the component as well, so collisions will be avoided."
msgstr ""
"> En una futura versión, el `#[substorage(v1)]` determinará la disposición "
"del almacenamiento basándose también en el componente, por lo que se "
"evitarán colisiones."

#: src/components/collisions.md:10
msgid ""
"A good practice is to prefix the component storage variables with the "
"component name, as shown in the [Switchable component example](./how_to.md)."
msgstr ""
"Una buena práctica es anteponer a las variables de almacenamiento del "
"componente el nombre del componente, como se muestra en el [Ejemplo de "
"componente conmutable](./how_to.md)."

#: src/components/collisions.md:12
msgid "#### Example"
msgstr "#### Ejemplo"

#: src/components/collisions.md:14
msgid ""
"Here's an example of a collision on the `switchable_value` storage variable "
"of the `Switchable` component."
msgstr ""
"He aquí un ejemplo de colisión en la variable de almacenamiento "
"`switchable_value` del componente `Switchable`."

#: src/components/collisions.md:16
msgid "Interface:"
msgstr "Interface:"

#: src/components/collisions.md:17
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISwitchCollision<TContractState> {\n"
"    fn set(ref self: TContractState, value: bool);\n"
"    fn get(ref self: TContractState) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISwitchCollision<TContractState> {\n"
"    fn set(ref self: TContractState, value: bool);\n"
"    fn get(ref self: TContractState) -> bool;\n"
"}\n"
"```"

#: src/components/collisions.md:25
msgid ""
"Here's the storage of the contract (you can expand the code snippet to see "
"the full contract):"
msgstr ""
"Aquí tienes el almacenamiento del contrato (puedes ampliar el fragmento de "
"código para ver el contrato completo):"

#: src/components/collisions.md:26
msgid ""
"```rust\n"
"# #[starknet::interface]\n"
"# trait ISwitchCollision<TContractState> {\n"
"#     fn set(ref self: TContractState, value: bool);\n"
"#     fn get(ref self: TContractState) -> bool;\n"
"# }\n"
"# \n"
"# #[starknet::contract]\n"
"# mod SwitchCollisionContract {\n"
"#     use components::switchable::switchable_component;\n"
"# \n"
"#     component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl SwitchableImpl = switchable_component::"
"Switchable<ContractState>;\n"
"#     impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"# \n"
"    #[storage]\n"
"    struct Storage {\n"
"        switchable_value: bool,\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage,\n"
"    }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState) {\n"
"#         self.switch._off();\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         SwitchableEvent: switchable_component::Event,\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl SwitchCollisionContract of super::ISwitchCollision<ContractState> "
"{\n"
"#         fn set(ref self: ContractState, value: bool) {\n"
"#             self.switchable_value.write(value);\n"
"#         }\n"
"# \n"
"#         fn get(ref self: ContractState) -> bool {\n"
"#             self.switchable_value.read()\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# #[starknet::interface]\n"
"# trait ISwitchCollision<TContractState> {\n"
"#     fn set(ref self: TContractState, value: bool);\n"
"#     fn get(ref self: TContractState) -> bool;\n"
"# }\n"
"# \n"
"# #[starknet::contract]\n"
"# mod SwitchCollisionContract {\n"
"#     use components::switchable::switchable_component;\n"
"# \n"
"#     component!(path: switchable_component, storage: switch, event: "
"SwitchableEvent);\n"
"# \n"
"#     #[abi(embed_v0)]\n"
"#     impl SwitchableImpl = switchable_component::"
"Switchable<ContractState>;\n"
"#     impl SwitchableInternalImpl = switchable_component::"
"SwitchableInternalImpl<ContractState>;\n"
"# \n"
"    #[storage]\n"
"    struct Storage {\n"
"        switchable_value: bool,\n"
"        #[substorage(v0)]\n"
"        switch: switchable_component::Storage,\n"
"    }\n"
"# \n"
"#     #[constructor]\n"
"#     fn constructor(ref self: ContractState) {\n"
"#         self.switch._off();\n"
"#     }\n"
"# \n"
"#     #[event]\n"
"#     #[derive(Drop, starknet::Event)]\n"
"#     enum Event {\n"
"#         SwitchableEvent: switchable_component::Event,\n"
"#     }\n"
"# \n"
"#     #[external(v0)]\n"
"#     impl SwitchCollisionContract of super::ISwitchCollision<ContractState> "
"{\n"
"#         fn set(ref self: ContractState, value: bool) {\n"
"#             self.switchable_value.write(value);\n"
"#         }\n"
"# \n"
"#         fn get(ref self: ContractState) -> bool {\n"
"#             self.switchable_value.read()\n"
"#         }\n"
"#     }\n"
"# }\n"
"```"

#: src/components/collisions.md:74
msgid ""
"Both the contract and the component have a `switchable_value` storage "
"variable, so they collide:"
msgstr ""
"Tanto el contrato como el componente tienen una variable de almacenamiento "
"`switchable_value`, por lo que colisionan:"

#: src/components/collisions.md:76
msgid ""
"```rust\n"
"# mod switch_collision_tests {\n"
"#     use components::switchable::switchable_component::"
"SwitchableInternalTrait;\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use components::contracts::switch_collision::{\n"
"#         SwitchCollisionContract, ISwitchCollisionDispatcher, "
"ISwitchCollisionDispatcherTrait\n"
"#     };\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ISwitchCollisionDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             SwitchCollisionContract::TEST_CLASS_HASH.try_into().unwrap(), "
"0, array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (\n"
"#             ISwitchCollisionDispatcher { contract_address },\n"
"#             ISwitchableDispatcher { contract_address },\n"
"#         )\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"    fn test_collision() {\n"
"        let (mut contract, mut contract_iswitch) = deploy();\n"
"\n"
"        assert(contract.get() == false, 'value !off');\n"
"        assert(contract_iswitch.is_on() == false, 'switch !off');\n"
"\n"
"        contract_iswitch.switch();\n"
"        assert(contract_iswitch.is_on() == true, 'switch !on');\n"
"        assert(contract.get() == true, 'value !on');\n"
"\n"
"        // `collision` between component storage 'value' and contract "
"storage 'value'\n"
"        assert(contract.get() == contract_iswitch.is_on(), 'value != "
"switch');\n"
"\n"
"        contract.set(false);\n"
"        assert(contract.get() == contract_iswitch.is_on(), 'value != "
"switch');\n"
"    }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# mod switch_collision_tests {\n"
"#     use components::switchable::switchable_component::"
"SwitchableInternalTrait;\n"
"#     use components::switchable::{ISwitchable, ISwitchableDispatcher, "
"ISwitchableDispatcherTrait};\n"
"# \n"
"#     use components::contracts::switch_collision::{\n"
"#         SwitchCollisionContract, ISwitchCollisionDispatcher, "
"ISwitchCollisionDispatcherTrait\n"
"#     };\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (ISwitchCollisionDispatcher, ISwitchableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             SwitchCollisionContract::TEST_CLASS_HASH.try_into().unwrap(), "
"0, array![].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (\n"
"#             ISwitchCollisionDispatcher { contract_address },\n"
"#             ISwitchableDispatcher { contract_address },\n"
"#         )\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"    fn test_collision() {\n"
"        let (mut contract, mut contract_iswitch) = deploy();\n"
"\n"
"        assert(contract.get() == false, 'value !off');\n"
"        assert(contract_iswitch.is_on() == false, 'switch !off');\n"
"\n"
"        contract_iswitch.switch();\n"
"        assert(contract_iswitch.is_on() == true, 'switch !on');\n"
"        assert(contract.get() == true, 'value !on');\n"
"\n"
"        // `collision` between component storage 'value' and contract "
"storage 'value'\n"
"        assert(contract.get() == contract_iswitch.is_on(), 'value != "
"switch');\n"
"\n"
"        contract.set(false);\n"
"        assert(contract.get() == contract_iswitch.is_on(), 'value != "
"switch');\n"
"    }\n"
"# }\n"
"```"

#: src/components/ownable.md:1
msgid "# Ownable"
msgstr "# Ownable"

#: src/components/ownable.md:3
msgid ""
"The following `Ownable` component is a simple component that allows the "
"contract to set an owner and provides a `_assert_is_owner` function that can "
"be used to ensure that the caller is the owner."
msgstr ""
"El siguiente componente `Ownable` es un componente simple que permite al "
"contrato establecer un propietario y proporciona una función "
"`_assert_is_owner` que se puede utilizar para asegurarse de que el llamante "
"es el propietario."

#: src/components/ownable.md:5
msgid ""
"It can also be used to renounce ownership of a contract, meaning that no one "
"will be able to satisfy the `_assert_is_owner` function."
msgstr ""
"También se puede utilizar para renunciar a la propiedad de un contrato, lo "
"que significa que nadie podrá satisfacer la función `_assert_is_owner`."

#: src/components/ownable.md:7
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IOwnable<TContractState> {\n"
"    fn owner(self: @TContractState) -> ContractAddress;\n"
"    fn transfer_ownership(ref self: TContractState, new: ContractAddress);\n"
"    fn renounce_ownership(ref self: TContractState);\n"
"}\n"
"\n"
"mod Errors {\n"
"    const UNAUTHORIZED: felt252 = 'Not owner';\n"
"    const ZERO_ADDRESS_OWNER: felt252 = 'Owner cannot be zero';\n"
"    const ZERO_ADDRESS_CALLER: felt252 = 'Caller cannot be zero';\n"
"}\n"
"\n"
"#[starknet::component]\n"
"mod ownable_component {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        ownable_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferredEvent {\n"
"        previous: ContractAddress,\n"
"        new: ContractAddress\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipRenouncedEvent {\n"
"        previous: ContractAddress\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnershipTransferredEvent: OwnershipTransferredEvent,\n"
"        OwnershipRenouncedEvent: OwnershipRenouncedEvent\n"
"    }\n"
"\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::IOwnable<ComponentState<TContractState>> {\n"
"        fn owner(self: @ComponentState<TContractState>) -> ContractAddress "
"{\n"
"            self.ownable_owner.read()\n"
"        }\n"
"\n"
"        fn transfer_ownership(ref self: ComponentState<TContractState>, new: "
"ContractAddress) {\n"
"            self._assert_only_owner();\n"
"            self._transfer_ownership(new);\n"
"        }\n"
"\n"
"        fn renounce_ownership(ref self: ComponentState<TContractState>) {\n"
"            self._assert_only_owner();\n"
"            self._renounce_ownership();\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl OwnableInternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of OwnableInternalTrait<TContractState> {\n"
"        fn _assert_only_owner(self: @ComponentState<TContractState>) {\n"
"            let caller = get_caller_address();\n"
"            assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);\n"
"            assert(caller == self.ownable_owner.read(), Errors::"
"UNAUTHORIZED);\n"
"        }\n"
"\n"
"        fn _init(ref self: ComponentState<TContractState>, owner: "
"ContractAddress) {\n"
"            assert(!owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);\n"
"            self.ownable_owner.write(owner);\n"
"        }\n"
"\n"
"        fn _transfer_ownership(ref self: ComponentState<TContractState>, "
"new: ContractAddress) {\n"
"            assert(!new.is_zero(), Errors::ZERO_ADDRESS_OWNER);\n"
"            let previous = self.ownable_owner.read();\n"
"            self.ownable_owner.write(new);\n"
"            self\n"
"                .emit(\n"
"                    Event::"
"OwnershipTransferredEvent(OwnershipTransferredEvent { previous, new })\n"
"                );\n"
"        }\n"
"\n"
"        fn _renounce_ownership(ref self: ComponentState<TContractState>) {\n"
"            let previous = self.ownable_owner.read();\n"
"            self.ownable_owner.write(Zeroable::zero());\n"
"            self.emit(Event::OwnershipRenouncedEvent(OwnershipRenouncedEvent "
"{ previous }));\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IOwnable<TContractState> {\n"
"    fn owner(self: @TContractState) -> ContractAddress;\n"
"    fn transfer_ownership(ref self: TContractState, new: ContractAddress);\n"
"    fn renounce_ownership(ref self: TContractState);\n"
"}\n"
"\n"
"mod Errors {\n"
"    const UNAUTHORIZED: felt252 = 'Not owner';\n"
"    const ZERO_ADDRESS_OWNER: felt252 = 'Owner cannot be zero';\n"
"    const ZERO_ADDRESS_CALLER: felt252 = 'Caller cannot be zero';\n"
"}\n"
"\n"
"#[starknet::component]\n"
"mod ownable_component {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use super::Errors;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        ownable_owner: ContractAddress,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipTransferredEvent {\n"
"        previous: ContractAddress,\n"
"        new: ContractAddress\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct OwnershipRenouncedEvent {\n"
"        previous: ContractAddress\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnershipTransferredEvent: OwnershipTransferredEvent,\n"
"        OwnershipRenouncedEvent: OwnershipRenouncedEvent\n"
"    }\n"
"\n"
"    #[embeddable_as(Ownable)]\n"
"    impl OwnableImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of super::IOwnable<ComponentState<TContractState>> {\n"
"        fn owner(self: @ComponentState<TContractState>) -> ContractAddress "
"{\n"
"            self.ownable_owner.read()\n"
"        }\n"
"\n"
"        fn transfer_ownership(ref self: ComponentState<TContractState>, new: "
"ContractAddress) {\n"
"            self._assert_only_owner();\n"
"            self._transfer_ownership(new);\n"
"        }\n"
"\n"
"        fn renounce_ownership(ref self: ComponentState<TContractState>) {\n"
"            self._assert_only_owner();\n"
"            self._renounce_ownership();\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl OwnableInternalImpl<\n"
"        TContractState, +HasComponent<TContractState>\n"
"    > of OwnableInternalTrait<TContractState> {\n"
"        fn _assert_only_owner(self: @ComponentState<TContractState>) {\n"
"            let caller = get_caller_address();\n"
"            assert(!caller.is_zero(), Errors::ZERO_ADDRESS_CALLER);\n"
"            assert(caller == self.ownable_owner.read(), Errors::"
"UNAUTHORIZED);\n"
"        }\n"
"\n"
"        fn _init(ref self: ComponentState<TContractState>, owner: "
"ContractAddress) {\n"
"            assert(!owner.is_zero(), Errors::ZERO_ADDRESS_OWNER);\n"
"            self.ownable_owner.write(owner);\n"
"        }\n"
"\n"
"        fn _transfer_ownership(ref self: ComponentState<TContractState>, "
"new: ContractAddress) {\n"
"            assert(!new.is_zero(), Errors::ZERO_ADDRESS_OWNER);\n"
"            let previous = self.ownable_owner.read();\n"
"            self.ownable_owner.write(new);\n"
"            self\n"
"                .emit(\n"
"                    Event::"
"OwnershipTransferredEvent(OwnershipTransferredEvent { previous, new })\n"
"                );\n"
"        }\n"
"\n"
"        fn _renounce_ownership(ref self: ComponentState<TContractState>) {\n"
"            let previous = self.ownable_owner.read();\n"
"            self.ownable_owner.write(Zeroable::zero());\n"
"            self.emit(Event::OwnershipRenouncedEvent(OwnershipRenouncedEvent "
"{ previous }));\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/components/ownable.md:104
msgid "A mock contract that uses the `Ownable` component:"
msgstr "Un contrato simulado que utiliza el componente `Ownable`:"

#: src/components/ownable.md:106
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IOwned<TContractState> {\n"
"    fn do_something(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod OwnedContract {\n"
"    use components::ownable::IOwnable;\n"
"    use components::ownable::ownable_component::OwnableInternalTrait;\n"
"    use components::ownable::ownable_component;\n"
"\n"
"    component!(path: ownable_component, storage: ownable, event: "
"OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"    impl OwnableInternalImpl = ownable_component::"
"OwnableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.ownable._init(starknet::get_caller_address());\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnableEvent: ownable_component::Event,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl Owned of super::IOwned<ContractState> {\n"
"        fn do_something(ref self: ContractState) {\n"
"            self.ownable._assert_only_owner();\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::{OwnedContract, IOwnedDispatcher, IOwnedDispatcherTrait};\n"
"#     use components::ownable::{IOwnable, IOwnableDispatcher, "
"IOwnableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"# \n"
"#     use starknet::{contract_address_const, ContractAddress};\n"
"#     use starknet::testing::{set_caller_address, set_contract_address};\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (IOwnedDispatcher, IOwnableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             OwnedContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array!"
"[].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (IOwnedDispatcher { contract_address }, IOwnableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let owner = contract_address_const::<'owner'>();\n"
"#         set_contract_address(owner);\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         assert(ownable.owner() == owner, 'wrong_owner');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_wrong_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         let not_owner = contract_address_const::<'not_owner'>();\n"
"#         assert(ownable.owner() != not_owner, 'wrong_owner');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_do_something() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (contract, _) = deploy();\n"
"# \n"
"#         contract.do_something();\n"
"#     // Should not panic\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_do_something_not_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (contract, _) = deploy();\n"
"# \n"
"#         set_contract_address(contract_address_const::<'not_owner'>());\n"
"#         contract.do_something();\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_transfer_ownership() {\n"
"#         set_contract_address(contract_address_const::<'initial'>());\n"
"#         let (contract, ownable) = deploy();\n"
"# \n"
"#         let new_owner = contract_address_const::<'new_owner'>();\n"
"#         ownable.transfer_ownership(new_owner);\n"
"# \n"
"#         assert(ownable.owner() == new_owner, 'wrong_owner');\n"
"# \n"
"#         set_contract_address(new_owner);\n"
"#         contract.do_something();\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_transfer_ownership_not_owner() {\n"
"#         set_contract_address(contract_address_const::<'initial'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         set_contract_address(contract_address_const::<'not_owner'>());\n"
"#         ownable.transfer_ownership(contract_address_const::"
"<'new_owner'>());\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_transfer_ownership_zero_error() {\n"
"#         set_contract_address(contract_address_const::<'initial'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         ownable.transfer_ownership(Zeroable::zero());\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_renounce_ownership() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         ownable.renounce_ownership();\n"
"#         assert(ownable.owner() == Zeroable::zero(), 'not_zero_owner');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_renounce_ownership_not_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         set_contract_address(contract_address_const::<'not_owner'>());\n"
"#         ownable.renounce_ownership();\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_renounce_ownership_previous_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (contract, ownable) = deploy();\n"
"# \n"
"#         ownable.renounce_ownership();\n"
"# \n"
"#         contract.do_something();\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IOwned<TContractState> {\n"
"    fn do_something(ref self: TContractState);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod OwnedContract {\n"
"    use components::ownable::IOwnable;\n"
"    use components::ownable::ownable_component::OwnableInternalTrait;\n"
"    use components::ownable::ownable_component;\n"
"\n"
"    component!(path: ownable_component, storage: ownable, event: "
"OwnableEvent);\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl OwnableImpl = ownable_component::Ownable<ContractState>;\n"
"    impl OwnableInternalImpl = ownable_component::"
"OwnableInternalImpl<ContractState>;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        #[substorage(v0)]\n"
"        ownable: ownable_component::Storage,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState) {\n"
"        self.ownable._init(starknet::get_caller_address());\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        OwnableEvent: ownable_component::Event,\n"
"    }\n"
"\n"
"    #[external(v0)]\n"
"    impl Owned of super::IOwned<ContractState> {\n"
"        fn do_something(ref self: ContractState) {\n"
"            self.ownable._assert_only_owner();\n"
"        // ...\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::{OwnedContract, IOwnedDispatcher, IOwnedDispatcherTrait};\n"
"#     use components::ownable::{IOwnable, IOwnableDispatcher, "
"IOwnableDispatcherTrait};\n"
"# \n"
"#     use core::starknet::storage::StorageMemberAccessTrait;\n"
"# \n"
"#     use starknet::{contract_address_const, ContractAddress};\n"
"#     use starknet::testing::{set_caller_address, set_contract_address};\n"
"#     use starknet::deploy_syscall;\n"
"# \n"
"#     fn deploy() -> (IOwnedDispatcher, IOwnableDispatcher) {\n"
"#         let (contract_address, _) = deploy_syscall(\n"
"#             OwnedContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array!"
"[].span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"# \n"
"#         (IOwnedDispatcher { contract_address }, IOwnableDispatcher "
"{ contract_address },)\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_init() {\n"
"#         let owner = contract_address_const::<'owner'>();\n"
"#         set_contract_address(owner);\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         assert(ownable.owner() == owner, 'wrong_owner');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_wrong_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         let not_owner = contract_address_const::<'not_owner'>();\n"
"#         assert(ownable.owner() != not_owner, 'wrong_owner');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_do_something() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (contract, _) = deploy();\n"
"# \n"
"#         contract.do_something();\n"
"#     // Should not panic\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_do_something_not_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (contract, _) = deploy();\n"
"# \n"
"#         set_contract_address(contract_address_const::<'not_owner'>());\n"
"#         contract.do_something();\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_transfer_ownership() {\n"
"#         set_contract_address(contract_address_const::<'initial'>());\n"
"#         let (contract, ownable) = deploy();\n"
"# \n"
"#         let new_owner = contract_address_const::<'new_owner'>();\n"
"#         ownable.transfer_ownership(new_owner);\n"
"# \n"
"#         assert(ownable.owner() == new_owner, 'wrong_owner');\n"
"# \n"
"#         set_contract_address(new_owner);\n"
"#         contract.do_something();\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_transfer_ownership_not_owner() {\n"
"#         set_contract_address(contract_address_const::<'initial'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         set_contract_address(contract_address_const::<'not_owner'>());\n"
"#         ownable.transfer_ownership(contract_address_const::"
"<'new_owner'>());\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_transfer_ownership_zero_error() {\n"
"#         set_contract_address(contract_address_const::<'initial'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         ownable.transfer_ownership(Zeroable::zero());\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     fn test_renounce_ownership() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         ownable.renounce_ownership();\n"
"#         assert(ownable.owner() == Zeroable::zero(), 'not_zero_owner');\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_renounce_ownership_not_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (_, ownable) = deploy();\n"
"# \n"
"#         set_contract_address(contract_address_const::<'not_owner'>());\n"
"#         ownable.renounce_ownership();\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(2000000)]\n"
"#     #[should_panic]\n"
"#     fn test_renounce_ownership_previous_owner() {\n"
"#         set_contract_address(contract_address_const::<'owner'>());\n"
"#         let (contract, ownable) = deploy();\n"
"# \n"
"#         ownable.renounce_ownership();\n"
"# \n"
"#         contract.do_something();\n"
"#     }\n"
"# }\n"
"```"

#: src/components/ownable.md:282 src/ch02/hashing.md:133
msgid "<footer id=\"last-change\">Last change: 2024-01-05</footer>"
msgstr "<footer id=\"last-change\">Última modificación: 2024-01-05</footer>"

#: src/ch01/upgradeable_contract.md:1
msgid "# Upgradeable Contract"
msgstr "# Contratos Actualizables"

#: src/ch01/upgradeable_contract.md:3
msgid ""
"In Starknet, contracts are divided into two parts: contract classes and "
"contract\n"
"instances. This division follows a similar concept used in object-oriented\n"
"programming languages, where we distinguish between the definition and "
"implementation\n"
"of objects."
msgstr ""
"En Starknet, los contratos se dividen en dos partes: clases de contratos e "
"instancias de contratos.\n"
"Esta división sigue un concepto similar al utilizado en los lenguajes de "
"programación orientados a objetos, en los que se distingue entre definición "
"e implementación de objetos."

#: src/ch01/upgradeable_contract.md:8
msgid ""
"A contract class is the definition of a contract: it specifies how the "
"contract\n"
"behaves. It contains essential information like the Cairo byte code, hint\n"
"information, entry point names, and everything that defines its semantics\n"
"unambiguously."
msgstr ""
"Una clase de contrato es la definición de un contrato: especifica cómo se "
"comporta el contrato.\n"
"Contiene información esencial como el código de bytes de Cairo, información "
"de pistas,\n"
"nombres de puntos de entrada y todo lo que define su semántica\n"
"sin ambigüedades."

#: src/ch01/upgradeable_contract.md:13
msgid ""
"To identify different contract classes, Starknet assigns a unique identifier "
"to each\n"
"class: the class hash. A contract instance is a deployed contract that "
"corresponds to\n"
"a specific contract class. Think of it as an instance of an object in "
"languages like\n"
"Java."
msgstr ""
"Para identificar las diferentes clases de contratos, Starknet asigna un "
"identificador único a cada clase: el hash de la clase. Una instancia de "
"contrato es un contrato desplegado que corresponde a una clase de contrato "
"específica. Piense en ello como una instancia de un objeto en lenguajes como "
"Java."

#: src/ch01/upgradeable_contract.md:18
msgid ""
"Each class is identified by its class hash, which is analogous to a class "
"name in an object-oriented programming language. A contract instance is a "
"deployed contract corresponding to a class."
msgstr ""
"Cada clase se identifica por su hash de clase, que es análogo a un nombre de "
"clase en un lenguaje de programación orientado a objetos. Una instancia de "
"contrato es un contrato desplegado correspondiente a una clase."

#: src/ch01/upgradeable_contract.md:20
msgid ""
"You can upgrade a deployed contract to a newer version by calling the "
"`replace_class_syscall` function. By using this function, you can update the "
"class hash associated with a deployed contract, effectively upgrading its "
"implementation. However, this will not modify the contract's storage, so all "
"the data stored in the contract will remain the same."
msgstr ""
"Puedes actualizar un contrato desplegado a una versión más reciente llamando "
"a la función `replace_class_syscall`. Usando esta función, puedes actualizar "
"el hash de clase asociado con un contrato desplegado, actualizando "
"efectivamente su implementación. Sin embargo, esto no modificará el "
"almacenamiento del contrato, por lo que todos los datos almacenados en el "
"contrato seguirán siendo los mismos."

#: src/ch01/upgradeable_contract.md:22
msgid ""
"To illustrate this concept, let's consider an example with two contracts: "
"`UpgradeableContract_V0`, and `UpgradeableContract_V1`.\n"
"Start by deploying `UpgradeableContract_V0` as the initial version. Next, "
"send a transaction that invokes the `upgrade` function, with the class hash "
"of `UpgradeableContract_V1` as parameter to upgrade the class hash of the "
"deployed contract to the `UpgradeableContract_V1` one. Then, call the "
"`version` method on the contract to see that the contract was upgraded to "
"the V1 version."
msgstr ""
"Para ilustrar este concepto, consideremos un ejemplo con dos contratos: "
"Contrato Actualizable V0 y Contrato Actualizable V1.\n"
"Comience desplegando `UpgradeableContract_V0` como versión inicial. A "
"continuación, envía una transacción que invoque a la función `upgrade`, con "
"el hash de clase del `UpgradeableContract_V1` como parámetro para actualizar "
"el hash de clase del contrato desplegado al del `UpgradeableContract_V1`. "
"Luego, llama al método `version` en el contrato para ver que el contrato fue "
"actualizado a la versión V1."

#: src/ch01/upgradeable_contract.md:25
msgid ""
"```rust\n"
"use starknet::class_hash::ClassHash;\n"
"\n"
"#[starknet::interface]\n"
"trait IUpgradeableContract<TContractState> {\n"
"    fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"    fn version(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod UpgradeableContract_V0 {\n"
"    use starknet::class_hash::ClassHash;\n"
"    use starknet::SyscallResultTrait;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Upgraded: Upgraded\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Upgraded {\n"
"        implementation: ClassHash\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"\n"
"        fn version(self: @ContractState) -> u8 {\n"
"            0\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::class_hash::ClassHash;\n"
"\n"
"#[starknet::interface]\n"
"trait IUpgradeableContract<TContractState> {\n"
"    fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"    fn version(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod UpgradeableContract_V0 {\n"
"    use starknet::class_hash::ClassHash;\n"
"    use starknet::SyscallResultTrait;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Upgraded: Upgraded\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Upgraded {\n"
"        implementation: ClassHash\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"\n"
"        fn version(self: @ContractState) -> u8 {\n"
"            0\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch01/upgradeable_contract.md:68
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x005300003ade5d10447d941a42d48b7141074cd8bade2b16520684896a5090ea) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/upgradeable_contract/src/"
"upgradeable_contract_v0.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x005300003ade5d10447d941a42d48b7141074cd8bade2b16520684896a5090ea) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/upgradeable_contract/src/"
"upgradeable_contract_v0.cairo)."

#: src/ch01/upgradeable_contract.md:71
msgid ""
"```rust\n"
"use starknet::class_hash::ClassHash;\n"
"\n"
"#[starknet::interface]\n"
"trait IUpgradeableContract<TContractState> {\n"
"    fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"    fn version(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod UpgradeableContract_V1 {\n"
"    use starknet::class_hash::ClassHash;\n"
"    use starknet::SyscallResultTrait;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Upgraded: Upgraded\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Upgraded {\n"
"        implementation: ClassHash\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"\n"
"        fn version(self: @ContractState) -> u8 {\n"
"            1\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::class_hash::ClassHash;\n"
"\n"
"#[starknet::interface]\n"
"trait IUpgradeableContract<TContractState> {\n"
"    fn upgrade(ref self: TContractState, impl_hash: ClassHash);\n"
"    fn version(self: @TContractState) -> u8;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod UpgradeableContract_V1 {\n"
"    use starknet::class_hash::ClassHash;\n"
"    use starknet::SyscallResultTrait;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Upgraded: Upgraded\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Upgraded {\n"
"        implementation: ClassHash\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl UpgradeableContract of super::IUpgradeableContract<ContractState> "
"{\n"
"        fn upgrade(ref self: ContractState, impl_hash: ClassHash) {\n"
"            assert(!impl_hash.is_zero(), 'Class hash cannot be zero');\n"
"            starknet::replace_class_syscall(impl_hash).unwrap_syscall();\n"
"            self.emit(Event::Upgraded(Upgraded { implementation: "
"impl_hash }))\n"
"        }\n"
"\n"
"        fn version(self: @ContractState) -> u8 {\n"
"            1\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch01/upgradeable_contract.md:114
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x017c86152badd1d665b9836571bd6b0a484f028748aa13d9b2d5d9c9192fafc6) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/upgradeable_contract/src/"
"upgradeable_contract_v1.cairo)."
msgstr ""
"Visita el contrato en  [Voyager](https://goerli.voyager.online/"
"contract/0x017c86152badd1d665b9836571bd6b0a484f028748aa13d9b2d5d9c9192fafc6) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/upgradeable_contract/src/"
"upgradeable_contract_v1.cairo)."

#: src/ch01/simple_vault.md:1
msgid "# Simple Defi Vault"
msgstr "# Simple Defi Vault"

#: src/ch01/simple_vault.md:3
msgid ""
"This is the Cairo adaptation of the [Solidity by example Vault](https://"
"solidity-by-example.org/defi/vault/).\n"
"Here's how it works:"
msgstr ""
"Se trata de la adaptación cairota de la [Solidity by example Vault](https://"
"solidity-by-example.org/defi/vault/).\n"
"Funciona de la siguiente manera:"

#: src/ch01/simple_vault.md:6
msgid ""
"- When a user deposits a token, the contract calculates the amount of shares "
"to mint.\n"
"\n"
"- When a user withdraws, the contract burns their shares, calculates the "
"yield, and withdraw both the yield and the initial amount of token deposited."
msgstr ""
"- Cuando un usuario deposita un token, el contrato calcula la cantidad de "
"acciones a acuñar.\n"
"\n"
"- Cuando un usuario retira, el contrato quema sus acciones, calcula el "
"rendimiento y retira tanto el rendimiento como la cantidad inicial de token "
"depositada."

#: src/ch01/simple_vault.md:10
msgid ""
"```rust\n"
"use starknet::{ContractAddress};\n"
"\n"
"// In order to make contract calls within our Vault,\n"
"// we need to have the interface of the remote ERC20 contract defined to "
"import the Dispatcher.\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn name(self: @TContractState) -> felt252;\n"
"    fn symbol(self: @TContractState) -> felt252;\n"
"    fn decimals(self: @TContractState) -> u8;\n"
"    fn total_supply(self: @TContractState) -> u256;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: u256) -> bool;\n"
"    fn transfer_from(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: "
"ContractAddress, amount: u256\n"
"    ) -> bool;\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ISimpleVault<TContractState> {\n"
"    fn deposit(ref self: TContractState, amount: u256);\n"
"    fn withdraw(ref self: TContractState, shares: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleVault {\n"
"    use super::{IERC20Dispatcher, IERC20DispatcherTrait};\n"
"    use starknet::{ContractAddress, get_caller_address, "
"get_contract_address};\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token: IERC20Dispatcher,\n"
"        total_supply: u256,\n"
"        balance_of: LegacyMap<ContractAddress, u256>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, token: ContractAddress) {\n"
"        self.token.write(IERC20Dispatcher { contract_address: token });\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        fn _mint(ref self: ContractState, to: ContractAddress, shares: u256) "
"{\n"
"            self.total_supply.write(self.total_supply.read() + shares);\n"
"            self.balance_of.write(to, self.balance_of.read(to) + shares);\n"
"        }\n"
"\n"
"        fn _burn(ref self: ContractState, from: ContractAddress, shares: "
"u256) {\n"
"            self.total_supply.write(self.total_supply.read() - shares);\n"
"            self.balance_of.write(from, self.balance_of.read(from) - "
"shares);\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleVault of super::ISimpleVault<ContractState> {\n"
"        fn deposit(ref self: ContractState, amount: u256) {\n"
"            // a = amount\n"
"            // B = balance of token before deposit\n"
"            // T = total supply\n"
"            // s = shares to mint\n"
"            //\n"
"            // (T + s) / T = (a + B) / B \n"
"            //\n"
"            // s = aT / B\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"\n"
"            let mut shares = 0;\n"
"            if self.total_supply.read() == 0 {\n"
"                shares = amount;\n"
"            } else {\n"
"                let balance = self.token.read().balance_of(this);\n"
"                shares = (amount * self.total_supply.read()) / balance;\n"
"            }\n"
"\n"
"            PrivateFunctions::_mint(ref self, caller, shares);\n"
"            self.token.read().transfer_from(caller, this, amount);\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, shares: u256) {\n"
"            // a = amount\n"
"            // B = balance of token before withdraw\n"
"            // T = total supply\n"
"            // s = shares to burn\n"
"            //\n"
"            // (T - s) / T = (B - a) / B \n"
"            //\n"
"            // a = sB / T\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"\n"
"            let balance = self.token.read().balance_of(this);\n"
"            let amount = (shares * balance) / self.total_supply.read();\n"
"            PrivateFunctions::_burn(ref self, caller, shares);\n"
"            self.token.read().transfer(caller, amount);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"use starknet::{ContractAddress};\n"
"\n"
"// In order to make contract calls within our Vault,\n"
"// we need to have the interface of the remote ERC20 contract defined to "
"import the Dispatcher.\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn name(self: @TContractState) -> felt252;\n"
"    fn symbol(self: @TContractState) -> felt252;\n"
"    fn decimals(self: @TContractState) -> u8;\n"
"    fn total_supply(self: @TContractState) -> u256;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: u256) -> bool;\n"
"    fn transfer_from(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: "
"ContractAddress, amount: u256\n"
"    ) -> bool;\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait ISimpleVault<TContractState> {\n"
"    fn deposit(ref self: TContractState, amount: u256);\n"
"    fn withdraw(ref self: TContractState, shares: u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod SimpleVault {\n"
"    use super::{IERC20Dispatcher, IERC20DispatcherTrait};\n"
"    use starknet::{ContractAddress, get_caller_address, "
"get_contract_address};\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token: IERC20Dispatcher,\n"
"        total_supply: u256,\n"
"        balance_of: LegacyMap<ContractAddress, u256>\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, token: ContractAddress) {\n"
"        self.token.write(IERC20Dispatcher { contract_address: token });\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        fn _mint(ref self: ContractState, to: ContractAddress, shares: u256) "
"{\n"
"            self.total_supply.write(self.total_supply.read() + shares);\n"
"            self.balance_of.write(to, self.balance_of.read(to) + shares);\n"
"        }\n"
"\n"
"        fn _burn(ref self: ContractState, from: ContractAddress, shares: "
"u256) {\n"
"            self.total_supply.write(self.total_supply.read() - shares);\n"
"            self.balance_of.write(from, self.balance_of.read(from) - "
"shares);\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SimpleVault of super::ISimpleVault<ContractState> {\n"
"        fn deposit(ref self: ContractState, amount: u256) {\n"
"            // a = amount\n"
"            // B = balance of token before deposit\n"
"            // T = total supply\n"
"            // s = shares to mint\n"
"            //\n"
"            // (T + s) / T = (a + B) / B \n"
"            //\n"
"            // s = aT / B\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"\n"
"            let mut shares = 0;\n"
"            if self.total_supply.read() == 0 {\n"
"                shares = amount;\n"
"            } else {\n"
"                let balance = self.token.read().balance_of(this);\n"
"                shares = (amount * self.total_supply.read()) / balance;\n"
"            }\n"
"\n"
"            PrivateFunctions::_mint(ref self, caller, shares);\n"
"            self.token.read().transfer_from(caller, this, amount);\n"
"        }\n"
"\n"
"        fn withdraw(ref self: ContractState, shares: u256) {\n"
"            // a = amount\n"
"            // B = balance of token before withdraw\n"
"            // T = total supply\n"
"            // s = shares to burn\n"
"            //\n"
"            // (T - s) / T = (B - a) / B \n"
"            //\n"
"            // a = sB / T\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"\n"
"            let balance = self.token.read().balance_of(this);\n"
"            let amount = (shares * balance) / self.total_supply.read();\n"
"            PrivateFunctions::_burn(ref self, caller, shares);\n"
"            self.token.read().transfer(caller, amount);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/ch01/simple_vault.md:113
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/simple_vault/src/simple_vault.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/simple_vault/src/simple_vault.cairo)."

#: src/ch01/erc20.md:1
msgid "# ERC20 Token"
msgstr "# Token ERC20"

#: src/ch01/erc20.md:3
msgid ""
"Contracts that follow the [ERC20 Standard](https://eips.ethereum.org/EIPS/"
"eip-20) are called ERC20 tokens. They are used to represent fungible assets."
msgstr ""
"Los contratos que siguen el [Standard ERC20](https://eips.ethereum.org/EIPS/"
"eip-20) se denominan tokens ERC20. Se utilizan para representar activos "
"fungibles."

#: src/ch01/erc20.md:5
msgid ""
"To create an ERC20 conctract, it must implement the following interface:"
msgstr "Para crear un contrato ERC20, debe implementar la siguiente interfaz:"

#: src/ch01/erc20.md:7
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn get_name(self: @TContractState) -> felt252;\n"
"    fn get_symbol(self: @TContractState) -> felt252;\n"
"    fn get_decimals(self: @TContractState) -> u8;\n"
"    fn get_total_supply(self: @TContractState) -> felt252;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> "
"felt252;\n"
"    fn allowance(\n"
"        self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress\n"
"    ) -> felt252;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: felt252);\n"
"    fn transfer_from(\n"
"        ref self: TContractState,\n"
"        sender: ContractAddress,\n"
"        recipient: ContractAddress,\n"
"        amount: felt252\n"
"    );\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"felt252);\n"
"    fn increase_allowance(ref self: TContractState, spender: "
"ContractAddress, added_value: felt252);\n"
"    fn decrease_allowance(\n"
"        ref self: TContractState, spender: ContractAddress, "
"subtracted_value: felt252\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn get_name(self: @TContractState) -> felt252;\n"
"    fn get_symbol(self: @TContractState) -> felt252;\n"
"    fn get_decimals(self: @TContractState) -> u8;\n"
"    fn get_total_supply(self: @TContractState) -> felt252;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> "
"felt252;\n"
"    fn allowance(\n"
"        self: @TContractState, owner: ContractAddress, spender: "
"ContractAddress\n"
"    ) -> felt252;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, "
"amount: felt252);\n"
"    fn transfer_from(\n"
"        ref self: TContractState,\n"
"        sender: ContractAddress,\n"
"        recipient: ContractAddress,\n"
"        amount: felt252\n"
"    );\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: "
"felt252);\n"
"    fn increase_allowance(ref self: TContractState, spender: "
"ContractAddress, added_value: felt252);\n"
"    fn decrease_allowance(\n"
"        ref self: TContractState, spender: ContractAddress, "
"subtracted_value: felt252\n"
"    );\n"
"}\n"
"```"

#: src/ch01/erc20.md:33
msgid ""
"In Starknet, function names should be written in *snake_case*. This is not "
"the case in Solidity, where function names are written in *camelCase*.\n"
"The Starknet ERC20 interface is therefore slightly different from the "
"Solidity ERC20 interface."
msgstr ""
"En Starknet, los nombres de las funciones deben escribirse en *snake_case*. "
"Este no es el caso en Solidity, donde los nombres de las funciones se "
"escriben en *camelCase*.\n"
"Por lo tanto, la interfaz ERC20 de Starknet es ligeramente diferente de la "
"interfaz ERC20 de Solidity."

#: src/ch01/erc20.md:36
msgid "Here's an implementation of the ERC20 interface in Cairo:"
msgstr "He aquí una implementación de la interfaz ERC20 en Cairo:"

#: src/ch01/erc20.md:38
msgid ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use zeroable::Zeroable;\n"
"    use starknet::get_caller_address;\n"
"    use starknet::contract_address_const;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"        symbol: felt252,\n"
"        decimals: u8,\n"
"        total_supply: felt252,\n"
"        balances: LegacyMap::<ContractAddress, felt252>,\n"
"        allowances: LegacyMap::<(ContractAddress, ContractAddress), "
"felt252>,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Transfer: Transfer,\n"
"        Approval: Approval,\n"
"    }\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Transfer {\n"
"        from: ContractAddress,\n"
"        to: ContractAddress,\n"
"        value: felt252,\n"
"    }\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Approval {\n"
"        owner: ContractAddress,\n"
"        spender: ContractAddress,\n"
"        value: felt252,\n"
"    }\n"
"\n"
"    mod Errors {\n"
"        const APPROVE_FROM_ZERO: felt252 = 'ERC20: approve from 0';\n"
"        const APPROVE_TO_ZERO: felt252 = 'ERC20: approve to 0';\n"
"        const TRANSFER_FROM_ZERO: felt252 = 'ERC20: transfer from 0';\n"
"        const TRANSFER_TO_ZERO: felt252 = 'ERC20: transfer to 0';\n"
"        const BURN_FROM_ZERO: felt252 = 'ERC20: burn from 0';\n"
"        const MINT_TO_ZERO: felt252 = 'ERC20: mint to 0';\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        recipient: ContractAddress,\n"
"        name: felt252,\n"
"        decimals: u8,\n"
"        initial_supply: felt252,\n"
"        symbol: felt252\n"
"    ) {\n"
"        self.name.write(name);\n"
"        self.symbol.write(symbol);\n"
"        self.decimals.write(decimals);\n"
"        self.mint(recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl IERC20Impl of super::IERC20<ContractState> {\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"\n"
"        fn get_symbol(self: @ContractState) -> felt252 {\n"
"            self.symbol.read()\n"
"        }\n"
"\n"
"        fn get_decimals(self: @ContractState) -> u8 {\n"
"            self.decimals.read()\n"
"        }\n"
"\n"
"        fn get_total_supply(self: @ContractState) -> felt252 {\n"
"            self.total_supply.read()\n"
"        }\n"
"\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> "
"felt252 {\n"
"            self.balances.read(account)\n"
"        }\n"
"\n"
"        fn allowance(\n"
"            self: @ContractState, owner: ContractAddress, spender: "
"ContractAddress\n"
"        ) -> felt252 {\n"
"            self.allowances.read((owner, spender))\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, "
"amount: felt252) {\n"
"            let sender = get_caller_address();\n"
"            self._transfer(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn transfer_from(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self.spend_allowance(sender, caller, amount);\n"
"            self._transfer(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn approve(ref self: ContractState, spender: ContractAddress, "
"amount: felt252) {\n"
"            let caller = get_caller_address();\n"
"            self.approve_helper(caller, spender, amount);\n"
"        }\n"
"\n"
"        fn increase_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, added_value: "
"felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) "
"+ added_value\n"
"                );\n"
"        }\n"
"\n"
"        fn decrease_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, "
"subtracted_value: felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) "
"- subtracted_value\n"
"                );\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl of InternalTrait {\n"
"        fn _transfer(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            assert(!sender.is_zero(), Errors::TRANSFER_FROM_ZERO);\n"
"            assert(!recipient.is_zero(), Errors::TRANSFER_TO_ZERO);\n"
"            self.balances.write(sender, self.balances.read(sender) - "
"amount);\n"
"            self.balances.write(recipient, self.balances.read(recipient) + "
"amount);\n"
"            self.emit(Transfer { from: sender, to: recipient, value: "
"amount });\n"
"        }\n"
"\n"
"        fn spend_allowance(\n"
"            ref self: ContractState,\n"
"            owner: ContractAddress,\n"
"            spender: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            let allowance = self.allowances.read((owner, spender));\n"
"            self.allowances.write((owner, spender), allowance - amount);\n"
"        }\n"
"\n"
"        fn approve_helper(\n"
"            ref self: ContractState,\n"
"            owner: ContractAddress,\n"
"            spender: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            assert(!spender.is_zero(), Errors::APPROVE_TO_ZERO);\n"
"            self.allowances.write((owner, spender), amount);\n"
"            self.emit(Approval { owner, spender, value: amount });\n"
"        }\n"
"\n"
"        fn mint(ref self: ContractState, recipient: ContractAddress, amount: "
"felt252) {\n"
"            assert(!recipient.is_zero(), Errors::MINT_TO_ZERO);\n"
"            let supply = self.total_supply.read() + amount; // What can go "
"wrong here?\n"
"            self.total_supply.write(supply);\n"
"            let balance = self.balances.read(recipient) + amount;\n"
"            self.balances.write(recipient, amount);\n"
"            self\n"
"                .emit(\n"
"                    Event::Transfer(\n"
"                        Transfer {\n"
"                            from: contract_address_const::<0>(), to: "
"recipient, value: amount\n"
"                        }\n"
"                    )\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod erc20 {\n"
"    use zeroable::Zeroable;\n"
"    use starknet::get_caller_address;\n"
"    use starknet::contract_address_const;\n"
"    use starknet::ContractAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"        symbol: felt252,\n"
"        decimals: u8,\n"
"        total_supply: felt252,\n"
"        balances: LegacyMap::<ContractAddress, felt252>,\n"
"        allowances: LegacyMap::<(ContractAddress, ContractAddress), "
"felt252>,\n"
"    }\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Transfer: Transfer,\n"
"        Approval: Approval,\n"
"    }\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Transfer {\n"
"        from: ContractAddress,\n"
"        to: ContractAddress,\n"
"        value: felt252,\n"
"    }\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Approval {\n"
"        owner: ContractAddress,\n"
"        spender: ContractAddress,\n"
"        value: felt252,\n"
"    }\n"
"\n"
"    mod Errors {\n"
"        const APPROVE_FROM_ZERO: felt252 = 'ERC20: approve from 0';\n"
"        const APPROVE_TO_ZERO: felt252 = 'ERC20: approve to 0';\n"
"        const TRANSFER_FROM_ZERO: felt252 = 'ERC20: transfer from 0';\n"
"        const TRANSFER_TO_ZERO: felt252 = 'ERC20: transfer to 0';\n"
"        const BURN_FROM_ZERO: felt252 = 'ERC20: burn from 0';\n"
"        const MINT_TO_ZERO: felt252 = 'ERC20: mint to 0';\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState,\n"
"        recipient: ContractAddress,\n"
"        name: felt252,\n"
"        decimals: u8,\n"
"        initial_supply: felt252,\n"
"        symbol: felt252\n"
"    ) {\n"
"        self.name.write(name);\n"
"        self.symbol.write(symbol);\n"
"        self.decimals.write(decimals);\n"
"        self.mint(recipient, initial_supply);\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl IERC20Impl of super::IERC20<ContractState> {\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"\n"
"        fn get_symbol(self: @ContractState) -> felt252 {\n"
"            self.symbol.read()\n"
"        }\n"
"\n"
"        fn get_decimals(self: @ContractState) -> u8 {\n"
"            self.decimals.read()\n"
"        }\n"
"\n"
"        fn get_total_supply(self: @ContractState) -> felt252 {\n"
"            self.total_supply.read()\n"
"        }\n"
"\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> "
"felt252 {\n"
"            self.balances.read(account)\n"
"        }\n"
"\n"
"        fn allowance(\n"
"            self: @ContractState, owner: ContractAddress, spender: "
"ContractAddress\n"
"        ) -> felt252 {\n"
"            self.allowances.read((owner, spender))\n"
"        }\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, "
"amount: felt252) {\n"
"            let sender = get_caller_address();\n"
"            self._transfer(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn transfer_from(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self.spend_allowance(sender, caller, amount);\n"
"            self._transfer(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn approve(ref self: ContractState, spender: ContractAddress, "
"amount: felt252) {\n"
"            let caller = get_caller_address();\n"
"            self.approve_helper(caller, spender, amount);\n"
"        }\n"
"\n"
"        fn increase_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, added_value: "
"felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) "
"+ added_value\n"
"                );\n"
"        }\n"
"\n"
"        fn decrease_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, "
"subtracted_value: felt252\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) "
"- subtracted_value\n"
"                );\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl InternalImpl of InternalTrait {\n"
"        fn _transfer(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            assert(!sender.is_zero(), Errors::TRANSFER_FROM_ZERO);\n"
"            assert(!recipient.is_zero(), Errors::TRANSFER_TO_ZERO);\n"
"            self.balances.write(sender, self.balances.read(sender) - "
"amount);\n"
"            self.balances.write(recipient, self.balances.read(recipient) + "
"amount);\n"
"            self.emit(Transfer { from: sender, to: recipient, value: "
"amount });\n"
"        }\n"
"\n"
"        fn spend_allowance(\n"
"            ref self: ContractState,\n"
"            owner: ContractAddress,\n"
"            spender: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            let allowance = self.allowances.read((owner, spender));\n"
"            self.allowances.write((owner, spender), allowance - amount);\n"
"        }\n"
"\n"
"        fn approve_helper(\n"
"            ref self: ContractState,\n"
"            owner: ContractAddress,\n"
"            spender: ContractAddress,\n"
"            amount: felt252\n"
"        ) {\n"
"            assert(!spender.is_zero(), Errors::APPROVE_TO_ZERO);\n"
"            self.allowances.write((owner, spender), amount);\n"
"            self.emit(Approval { owner, spender, value: amount });\n"
"        }\n"
"\n"
"        fn mint(ref self: ContractState, recipient: ContractAddress, amount: "
"felt252) {\n"
"            assert(!recipient.is_zero(), Errors::MINT_TO_ZERO);\n"
"            let supply = self.total_supply.read() + amount; // What can go "
"wrong here?\n"
"            self.total_supply.write(supply);\n"
"            let balance = self.balances.read(recipient) + amount;\n"
"            self.balances.write(recipient, amount);\n"
"            self\n"
"                .emit(\n"
"                    Event::Transfer(\n"
"                        Transfer {\n"
"                            from: contract_address_const::<0>(), to: "
"recipient, value: amount\n"
"                        }\n"
"                    )\n"
"                );\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch01/erc20.md:224
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/erc20/src/token.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/erc20/src/token.cairo)."

#: src/ch01/erc20.md:226
msgid ""
"There's several other implementations, such as the [Open Zeppelin](https://"
"docs.openzeppelin.com/contracts-cairo/0.7.0/erc20) or the [Cairo By Example]"
"(https://cairo-by-example.com/examples/erc20/) ones."
msgstr ""
"Existen otras implementaciones, como la [Open Zeppelin](https://docs."
"openzeppelin.com/contracts-cairo/0.7.0/erc20) o la [Cairo By Example]"
"(https://cairo-by-example.com/examples/erc20/)."

#: src/ch01/constant-product-amm.md:1
msgid "# Constant Product AMM"
msgstr "# AMM de Producto Constante"

#: src/ch01/constant-product-amm.md:3
msgid ""
"This is the Cairo adaptation of the [Solidity by example Constant Product "
"AMM](https://solidity-by-example.org/defi/constant-product-amm/)."
msgstr ""
"Se trata de la adaptación cairota de la [Solidez por ejemplo Producto "
"Constante AMM](https://solidity-by-example.org/defi/constant-product-amm/)."

#: src/ch01/constant-product-amm.md:5
msgid ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IConstantProductAmm<TContractState> {\n"
"    fn swap(ref self: TContractState, token_in: ContractAddress, amount_in: "
"u256) -> u256;\n"
"    fn add_liquidity(ref self: TContractState, amount0: u256, amount1: u256) "
"-> u256;\n"
"    fn remove_liquidity(ref self: TContractState, shares: u256) -> (u256, "
"u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ConstantProductAmm {\n"
"    use core::traits::Into;\n"
"    use openzeppelin::token::erc20::interface::{IERC20Dispatcher, "
"IERC20DispatcherTrait};\n"
"    use starknet::{\n"
"        ContractAddress, get_caller_address, get_contract_address, "
"contract_address_const\n"
"    };\n"
"    use integer::u256_sqrt;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token0: IERC20Dispatcher,\n"
"        token1: IERC20Dispatcher,\n"
"        reserve0: u256,\n"
"        reserve1: u256,\n"
"        total_supply: u256,\n"
"        balance_of: LegacyMap::<ContractAddress, u256>,\n"
"        // Fee 0 - 1000 (0% - 100%, 1 decimal places)\n"
"        // E.g. 3 = 0.3%\n"
"        fee: u16,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState, token0: ContractAddress, token1: "
"ContractAddress, fee: u16\n"
"    ) {\n"
"        // assert(fee <= 1000, 'fee > 1000');\n"
"        self.token0.write(IERC20Dispatcher { contract_address: token0 });\n"
"        self.token1.write(IERC20Dispatcher { contract_address: token1 });\n"
"        self.fee.write(fee);\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        fn _mint(ref self: ContractState, to: ContractAddress, amount: u256) "
"{\n"
"            self.balance_of.write(to, self.balance_of.read(to) + amount);\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"\n"
"        fn _burn(ref self: ContractState, from: ContractAddress, amount: "
"u256) {\n"
"            self.balance_of.write(from, self.balance_of.read(from) - "
"amount);\n"
"            self.total_supply.write(self.total_supply.read() - amount);\n"
"        }\n"
"\n"
"        fn _update(ref self: ContractState, reserve0: u256, reserve1: u256) "
"{\n"
"            self.reserve0.write(reserve0);\n"
"            self.reserve1.write(reserve1);\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn select_token(self: @ContractState, token: ContractAddress) -> "
"bool {\n"
"            assert(\n"
"                token == self.token0.read().contract_address\n"
"                    || token == self.token1.read().contract_address,\n"
"                'invalid token'\n"
"            );\n"
"            token == self.token0.read().contract_address\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn min(x: u256, y: u256) -> u256 {\n"
"            if (x <= y) {\n"
"                x\n"
"            } else {\n"
"                y\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ConstantProductAmm of super::IConstantProductAmm<ContractState> {\n"
"        fn swap(ref self: ContractState, token_in: ContractAddress, "
"amount_in: u256) -> u256 {\n"
"            assert(amount_in > 0, 'amount in = 0');\n"
"            let is_token0: bool = self.select_token(token_in);\n"
"\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"            let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), "
"self.reserve1.read());\n"
"            let (\n"
"                token_in, token_out, reserve_in, reserve_out\n"
"            ): (IERC20Dispatcher, IERC20Dispatcher, u256, u256) =\n"
"                if (is_token0) {\n"
"                (token0, token1, reserve0, reserve1)\n"
"            } else {\n"
"                (token1, token0, reserve1, reserve0)\n"
"            };\n"
"\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            token_in.transfer_from(caller, this, amount_in);\n"
"\n"
"            // How much dy for dx?\n"
"            // xy = k\n"
"            // (x + dx)(y - dy) = k\n"
"            // y - dy = k / (x + dx)\n"
"            // y - k / (x + dx) = dy\n"
"            // y - xy / (x + dx) = dy\n"
"            // (yx + ydx - xy) / (x + dx) = dy\n"
"            // ydx / (x + dx) = dy\n"
"\n"
"            let amount_in_with_fee = (amount_in * (1000 - self.fee.read()."
"into()) / 1000);\n"
"            let amount_out = (reserve_out * amount_in_with_fee) / "
"(reserve_in + amount_in_with_fee);\n"
"\n"
"            token_out.transfer(caller, amount_out);\n"
"\n"
"            self._update(self.token0.read().balance_of(this), self.token1."
"read().balance_of(this));\n"
"            amount_out\n"
"        }\n"
"\n"
"        fn add_liquidity(ref self: ContractState, amount0: u256, amount1: "
"u256) -> u256 {\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"\n"
"            token0.transfer_from(caller, this, amount0);\n"
"            token1.transfer_from(caller, this, amount1);\n"
"\n"
"            // How much dx, dy to add?\n"
"            //\n"
"            // xy = k\n"
"            // (x + dx)(y + dy) = k'\n"
"            //\n"
"            // No price change, before and after adding liquidity\n"
"            // x / y = (x + dx) / (y + dy)\n"
"            //\n"
"            // x(y + dy) = y(x + dx)\n"
"            // x * dy = y * dx\n"
"            //\n"
"            // x / y = dx / dy\n"
"            // dy = y / x * dx\n"
"\n"
"            let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), "
"self.reserve1.read());\n"
"            if (reserve0 > 0 || reserve1 > 0) {\n"
"                assert(reserve0 * amount1 == reserve1 * amount0, 'x / y != "
"dx / dy');\n"
"            }\n"
"\n"
"            // How much shares to mint?\n"
"            //\n"
"            // f(x, y) = value of liquidity\n"
"            // We will define f(x, y) = sqrt(xy)\n"
"            //\n"
"            // L0 = f(x, y)\n"
"            // L1 = f(x + dx, y + dy)\n"
"            // T = total shares\n"
"            // s = shares to mint\n"
"            //\n"
"            // Total shares should increase proportional to increase in "
"liquidity\n"
"            // L1 / L0 = (T + s) / T\n"
"            //\n"
"            // L1 * T = L0 * (T + s)\n"
"            //\n"
"            // (L1 - L0) * T / L0 = s\n"
"\n"
"            // Claim\n"
"            // (L1 - L0) / L0 = dx / x = dy / y\n"
"            //\n"
"            // Proof\n"
"            // --- Equation 1 ---\n"
"            // (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / "
"sqrt(xy)\n"
"            //\n"
"            // dx / dy = x / y so replace dy = dx * y / x\n"
"            //\n"
"            // --- Equation 2 ---\n"
"            // Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / "
"sqrt(xy)\n"
"            //\n"
"            // Multiply by sqrt(x) / sqrt(x)\n"
"            // Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / "
"sqrt(x^2y)\n"
"            //            = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
"(sqrt(y)sqrt(x^2))\n"
"            // sqrt(y) on top and bottom cancels out\n"
"            //\n"
"            // --- Equation 3 ---\n"
"            // Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
"(sqrt(x^2)\n"
"            // = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n"
"            // = ((x + dx) - x) / x\n"
"            // = dx / x\n"
"            // Since dx / dy = x / y,\n"
"            // dx / x = dy / y\n"
"            //\n"
"            // Finally\n"
"            // (L1 - L0) / L0 = dx / x = dy / y\n"
"\n"
"            let total_supply = self.total_supply.read();\n"
"            let shares = if (total_supply == 0) {\n"
"                u256_sqrt(amount0 * amount1).into()\n"
"            } else {\n"
"                PrivateFunctions::min(\n"
"                    amount0 * total_supply / reserve0, amount1 * "
"total_supply / reserve1\n"
"                )\n"
"            };\n"
"            assert(shares > 0, 'shares = 0');\n"
"            self._mint(caller, shares);\n"
"\n"
"            self._update(self.token0.read().balance_of(this), self.token1."
"read().balance_of(this));\n"
"            shares\n"
"        }\n"
"\n"
"        fn remove_liquidity(ref self: ContractState, shares: u256) -> (u256, "
"u256) {\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"\n"
"            // Claim\n"
"            // dx, dy = amount of liquidity to remove\n"
"            // dx = s / T * x\n"
"            // dy = s / T * y\n"
"            //\n"
"            // Proof\n"
"            // Let's find dx, dy such that\n"
"            // v / L = s / T\n"
"            //\n"
"            // where\n"
"            // v = f(dx, dy) = sqrt(dxdy)\n"
"            // L = total liquidity = sqrt(xy)\n"
"            // s = shares\n"
"            // T = total supply\n"
"            //\n"
"            // --- Equation 1 ---\n"
"            // v = s / T * L\n"
"            // sqrt(dxdy) = s / T * sqrt(xy)\n"
"            //\n"
"            // Amount of liquidity to remove must not change price so\n"
"            // dx / dy = x / y\n"
"            //\n"
"            // replace dy = dx * y / x\n"
"            // sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n"
"            //\n"
"            // Divide both sides of Equation 1 with sqrt(y / x)\n"
"            // dx = s / T * sqrt(xy) / sqrt(y / x)\n"
"            // = s / T * sqrt(x^2) = s / T * x\n"
"            //\n"
"            // Likewise\n"
"            // dy = s / T * y\n"
"\n"
"            // bal0 >= reserve0\n"
"            // bal1 >= reserve1\n"
"            let (bal0, bal1): (u256, u256) = (token0.balance_of(this), "
"token1.balance_of(this));\n"
"\n"
"            let total_supply = self.total_supply.read();\n"
"            let (amount0, amount1): (u256, u256) = (\n"
"                (shares * bal0) / total_supply, (shares * bal1) / "
"total_supply\n"
"            );\n"
"            assert(amount0 > 0 && amount1 > 0, 'amount0 or amount1 = 0');\n"
"\n"
"            self._burn(caller, shares);\n"
"            self._update(bal0 - amount0, bal1 - amount1);\n"
"\n"
"            token0.transfer(caller, amount0);\n"
"            token1.transfer(caller, amount1);\n"
"            (amount0, amount1)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"use starknet::ContractAddress;\n"
"\n"
"#[starknet::interface]\n"
"trait IConstantProductAmm<TContractState> {\n"
"    fn swap(ref self: TContractState, token_in: ContractAddress, amount_in: "
"u256) -> u256;\n"
"    fn add_liquidity(ref self: TContractState, amount0: u256, amount1: u256) "
"-> u256;\n"
"    fn remove_liquidity(ref self: TContractState, shares: u256) -> (u256, "
"u256);\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ConstantProductAmm {\n"
"    use core::traits::Into;\n"
"    use openzeppelin::token::erc20::interface::{IERC20Dispatcher, "
"IERC20DispatcherTrait};\n"
"    use starknet::{\n"
"        ContractAddress, get_caller_address, get_contract_address, "
"contract_address_const\n"
"    };\n"
"    use integer::u256_sqrt;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        token0: IERC20Dispatcher,\n"
"        token1: IERC20Dispatcher,\n"
"        reserve0: u256,\n"
"        reserve1: u256,\n"
"        total_supply: u256,\n"
"        balance_of: LegacyMap::<ContractAddress, u256>,\n"
"        // Fee 0 - 1000 (0% - 100%, 1 decimal places)\n"
"        // E.g. 3 = 0.3%\n"
"        fee: u16,\n"
"    }\n"
"\n"
"    #[constructor]\n"
"    fn constructor(\n"
"        ref self: ContractState, token0: ContractAddress, token1: "
"ContractAddress, fee: u16\n"
"    ) {\n"
"        // assert(fee <= 1000, 'fee > 1000');\n"
"        self.token0.write(IERC20Dispatcher { contract_address: token0 });\n"
"        self.token1.write(IERC20Dispatcher { contract_address: token1 });\n"
"        self.fee.write(fee);\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl PrivateFunctions of PrivateFunctionsTrait {\n"
"        fn _mint(ref self: ContractState, to: ContractAddress, amount: u256) "
"{\n"
"            self.balance_of.write(to, self.balance_of.read(to) + amount);\n"
"            self.total_supply.write(self.total_supply.read() + amount);\n"
"        }\n"
"\n"
"        fn _burn(ref self: ContractState, from: ContractAddress, amount: "
"u256) {\n"
"            self.balance_of.write(from, self.balance_of.read(from) - "
"amount);\n"
"            self.total_supply.write(self.total_supply.read() - amount);\n"
"        }\n"
"\n"
"        fn _update(ref self: ContractState, reserve0: u256, reserve1: u256) "
"{\n"
"            self.reserve0.write(reserve0);\n"
"            self.reserve1.write(reserve1);\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn select_token(self: @ContractState, token: ContractAddress) -> "
"bool {\n"
"            assert(\n"
"                token == self.token0.read().contract_address\n"
"                    || token == self.token1.read().contract_address,\n"
"                'invalid token'\n"
"            );\n"
"            token == self.token0.read().contract_address\n"
"        }\n"
"\n"
"        #[inline(always)]\n"
"        fn min(x: u256, y: u256) -> u256 {\n"
"            if (x <= y) {\n"
"                x\n"
"            } else {\n"
"                y\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ConstantProductAmm of super::IConstantProductAmm<ContractState> {\n"
"        fn swap(ref self: ContractState, token_in: ContractAddress, "
"amount_in: u256) -> u256 {\n"
"            assert(amount_in > 0, 'amount in = 0');\n"
"            let is_token0: bool = self.select_token(token_in);\n"
"\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"            let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), "
"self.reserve1.read());\n"
"            let (\n"
"                token_in, token_out, reserve_in, reserve_out\n"
"            ): (IERC20Dispatcher, IERC20Dispatcher, u256, u256) =\n"
"                if (is_token0) {\n"
"                (token0, token1, reserve0, reserve1)\n"
"            } else {\n"
"                (token1, token0, reserve1, reserve0)\n"
"            };\n"
"\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            token_in.transfer_from(caller, this, amount_in);\n"
"\n"
"            // How much dy for dx?\n"
"            // xy = k\n"
"            // (x + dx)(y - dy) = k\n"
"            // y - dy = k / (x + dx)\n"
"            // y - k / (x + dx) = dy\n"
"            // y - xy / (x + dx) = dy\n"
"            // (yx + ydx - xy) / (x + dx) = dy\n"
"            // ydx / (x + dx) = dy\n"
"\n"
"            let amount_in_with_fee = (amount_in * (1000 - self.fee.read()."
"into()) / 1000);\n"
"            let amount_out = (reserve_out * amount_in_with_fee) / "
"(reserve_in + amount_in_with_fee);\n"
"\n"
"            token_out.transfer(caller, amount_out);\n"
"\n"
"            self._update(self.token0.read().balance_of(this), self.token1."
"read().balance_of(this));\n"
"            amount_out\n"
"        }\n"
"\n"
"        fn add_liquidity(ref self: ContractState, amount0: u256, amount1: "
"u256) -> u256 {\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"\n"
"            token0.transfer_from(caller, this, amount0);\n"
"            token1.transfer_from(caller, this, amount1);\n"
"\n"
"            // How much dx, dy to add?\n"
"            //\n"
"            // xy = k\n"
"            // (x + dx)(y + dy) = k'\n"
"            //\n"
"            // No price change, before and after adding liquidity\n"
"            // x / y = (x + dx) / (y + dy)\n"
"            //\n"
"            // x(y + dy) = y(x + dx)\n"
"            // x * dy = y * dx\n"
"            //\n"
"            // x / y = dx / dy\n"
"            // dy = y / x * dx\n"
"\n"
"            let (reserve0, reserve1): (u256, u256) = (self.reserve0.read(), "
"self.reserve1.read());\n"
"            if (reserve0 > 0 || reserve1 > 0) {\n"
"                assert(reserve0 * amount1 == reserve1 * amount0, 'x / y != "
"dx / dy');\n"
"            }\n"
"\n"
"            // How much shares to mint?\n"
"            //\n"
"            // f(x, y) = value of liquidity\n"
"            // We will define f(x, y) = sqrt(xy)\n"
"            //\n"
"            // L0 = f(x, y)\n"
"            // L1 = f(x + dx, y + dy)\n"
"            // T = total shares\n"
"            // s = shares to mint\n"
"            //\n"
"            // Total shares should increase proportional to increase in "
"liquidity\n"
"            // L1 / L0 = (T + s) / T\n"
"            //\n"
"            // L1 * T = L0 * (T + s)\n"
"            //\n"
"            // (L1 - L0) * T / L0 = s\n"
"\n"
"            // Claim\n"
"            // (L1 - L0) / L0 = dx / x = dy / y\n"
"            //\n"
"            // Proof\n"
"            // --- Equation 1 ---\n"
"            // (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / "
"sqrt(xy)\n"
"            //\n"
"            // dx / dy = x / y so replace dy = dx * y / x\n"
"            //\n"
"            // --- Equation 2 ---\n"
"            // Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / "
"sqrt(xy)\n"
"            //\n"
"            // Multiply by sqrt(x) / sqrt(x)\n"
"            // Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - sqrt(x^2y)) / "
"sqrt(x^2y)\n"
"            //            = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
"(sqrt(y)sqrt(x^2))\n"
"            // sqrt(y) on top and bottom cancels out\n"
"            //\n"
"            // --- Equation 3 ---\n"
"            // Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
"(sqrt(x^2)\n"
"            // = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n"
"            // = ((x + dx) - x) / x\n"
"            // = dx / x\n"
"            // Since dx / dy = x / y,\n"
"            // dx / x = dy / y\n"
"            //\n"
"            // Finally\n"
"            // (L1 - L0) / L0 = dx / x = dy / y\n"
"\n"
"            let total_supply = self.total_supply.read();\n"
"            let shares = if (total_supply == 0) {\n"
"                u256_sqrt(amount0 * amount1).into()\n"
"            } else {\n"
"                PrivateFunctions::min(\n"
"                    amount0 * total_supply / reserve0, amount1 * "
"total_supply / reserve1\n"
"                )\n"
"            };\n"
"            assert(shares > 0, 'shares = 0');\n"
"            self._mint(caller, shares);\n"
"\n"
"            self._update(self.token0.read().balance_of(this), self.token1."
"read().balance_of(this));\n"
"            shares\n"
"        }\n"
"\n"
"        fn remove_liquidity(ref self: ContractState, shares: u256) -> (u256, "
"u256) {\n"
"            let caller = get_caller_address();\n"
"            let this = get_contract_address();\n"
"            let (token0, token1): (IERC20Dispatcher, IERC20Dispatcher) = (\n"
"                self.token0.read(), self.token1.read()\n"
"            );\n"
"\n"
"            // Claim\n"
"            // dx, dy = amount of liquidity to remove\n"
"            // dx = s / T * x\n"
"            // dy = s / T * y\n"
"            //\n"
"            // Proof\n"
"            // Let's find dx, dy such that\n"
"            // v / L = s / T\n"
"            //\n"
"            // where\n"
"            // v = f(dx, dy) = sqrt(dxdy)\n"
"            // L = total liquidity = sqrt(xy)\n"
"            // s = shares\n"
"            // T = total supply\n"
"            //\n"
"            // --- Equation 1 ---\n"
"            // v = s / T * L\n"
"            // sqrt(dxdy) = s / T * sqrt(xy)\n"
"            //\n"
"            // Amount of liquidity to remove must not change price so\n"
"            // dx / dy = x / y\n"
"            //\n"
"            // replace dy = dx * y / x\n"
"            // sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n"
"            //\n"
"            // Divide both sides of Equation 1 with sqrt(y / x)\n"
"            // dx = s / T * sqrt(xy) / sqrt(y / x)\n"
"            // = s / T * sqrt(x^2) = s / T * x\n"
"            //\n"
"            // Likewise\n"
"            // dy = s / T * y\n"
"\n"
"            // bal0 >= reserve0\n"
"            // bal1 >= reserve1\n"
"            let (bal0, bal1): (u256, u256) = (token0.balance_of(this), "
"token1.balance_of(this));\n"
"\n"
"            let total_supply = self.total_supply.read();\n"
"            let (amount0, amount1): (u256, u256) = (\n"
"                (shares * bal0) / total_supply, (shares * bal1) / "
"total_supply\n"
"            );\n"
"            assert(amount0 > 0 && amount1 > 0, 'amount0 or amount1 = 0');\n"
"\n"
"            self._burn(caller, shares);\n"
"            self._update(bal0 - amount0, bal1 - amount1);\n"
"\n"
"            token0.transfer(caller, amount0);\n"
"            token1.transfer(caller, amount1);\n"
"            (amount0, amount1)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch01/constant-product-amm.md:274
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/constant_product_amm/src/"
"constant_product_amm.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/applications/constant_product_amm/src/"
"constant_product_amm.cairo)."

#: src/ch02/write_to_any_slot.md:1
msgid "# Writing to any storage slot"
msgstr "# Escribir en cualquier ranura de almacenamiento"

#: src/ch02/write_to_any_slot.md:3
msgid ""
"On Starknet, a contract's storage is a map with 2^251 slots, where each slot "
"is a felt which is initialized to 0.\n"
"The address of storage variables is computed at compile time using the "
"formula: `storage variable address := pedersen(keccak(variable name), "
"keys)`. Interactions with storage variables are commonly performed using the "
"`self.var.read()` and `self.var.write()` functions."
msgstr ""
"En Starknet, el almacenamiento de un contrato es un mapa con 2^251 ranuras, "
"donde cada ranura es un fieltro que se inicializa a 0.\n"
"La dirección de las variables de almacenamiento se calcula en tiempo de "
"compilación mediante la fórmula `dirección de variable de almacenamiento := "
"pedersen(keccak(nombre de variable), keys)`. Las interacciones con las "
"variables de almacenamiento se realizan normalmente utilizando las funciones "
"`self.var.read()` y `self.var.write()`."

#: src/ch02/write_to_any_slot.md:6
msgid ""
"Nevertheless, we can use the `storage_write_syscall` and "
"`storage_read_syscall` syscalls, to write to and read from any storage "
"slot.\n"
"This is useful when writing to storage variables that are not known at "
"compile time, or to ensure that even if the contract is upgraded and the "
"computation method of storage variable addresses changes, they remain "
"accessible."
msgstr ""
"Sin embargo, podemos usar las llamadas al sistema `storage_write_syscall` y "
"`storage_read_syscall`, para escribir y leer desde cualquier ranura de "
"almacenamiento.\n"
"Esto es útil cuando se escribe en variables de almacenamiento que no se "
"conocen en tiempo de compilación, o para asegurarse de que incluso si el "
"contrato se actualiza y el método de cálculo de las direcciones de las "
"variables de almacenamiento cambia, siguen siendo accesibles."

#: src/ch02/write_to_any_slot.md:9
msgid ""
"In the following example, we use the Poseidon hash function to compute the "
"address of a storage variable. Poseidon is a ZK-friendly hash function that "
"is cheaper and faster than Pedersen, making it an excellent choice for "
"onchain computations. Once the address is computed, we use the storage "
"syscalls to interact with it."
msgstr ""
"En el siguiente ejemplo, utilizamos la función hash Poseidon para calcular "
"la dirección de una variable de almacenamiento. Poseidon es una función hash "
"compatible con ZK que es más barata y rápida que Pedersen, lo que la "
"convierte en una excelente elección para cálculos en cadena. Una vez "
"calculada la dirección, utilizamos las llamadas al sistema de almacenamiento "
"para interactuar con ella."

#: src/ch02/write_to_any_slot.md:11
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IWriteToAnySlots<TContractState> {\n"
"    fn write_slot(ref self: TContractState, value: u32);\n"
"    fn read_slot(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod WriteToAnySlot {\n"
"    use starknet::syscalls::{storage_read_syscall, storage_write_syscall};\n"
"    use starknet::SyscallResultTrait;\n"
"    use poseidon::poseidon_hash_span;\n"
"    use starknet::storage_access::Felt252TryIntoStorageAddress;\n"
"    use starknet::StorageAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    const SLOT_NAME: felt252 = 'test_slot';\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl WriteToAnySlot of super::IWriteToAnySlots<ContractState> {\n"
"        fn write_slot(ref self: ContractState, value: u32) {\n"
"            storage_write_syscall(0, get_address_from_name(SLOT_NAME), value."
"into());\n"
"        }\n"
"\n"
"        fn read_slot(self: @ContractState) -> u32 {\n"
"            storage_read_syscall(0, get_address_from_name(SLOT_NAME))\n"
"                .unwrap_syscall()\n"
"                .try_into()\n"
"                .unwrap()\n"
"        }\n"
"    }\n"
"    fn get_address_from_name(variable_name: felt252) -> StorageAddress {\n"
"        let mut data: Array<felt252> = ArrayTrait::new();\n"
"        data.append(variable_name);\n"
"        let hashed_name: felt252 = poseidon_hash_span(data.span());\n"
"        let MASK_250: u256 = "
"0x03ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n"
"        // By taking the 250 least significant bits of the hash output, we "
"get a valid 250bits storage address.\n"
"        let result: felt252 = (hashed_name.into() & MASK_250).try_into()."
"unwrap();\n"
"        let result: StorageAddress = result.try_into().unwrap();\n"
"        result\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IWriteToAnySlots<TContractState> {\n"
"    fn write_slot(ref self: TContractState, value: u32);\n"
"    fn read_slot(self: @TContractState) -> u32;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod WriteToAnySlot {\n"
"    use starknet::syscalls::{storage_read_syscall, storage_write_syscall};\n"
"    use starknet::SyscallResultTrait;\n"
"    use poseidon::poseidon_hash_span;\n"
"    use starknet::storage_access::Felt252TryIntoStorageAddress;\n"
"    use starknet::StorageAddress;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    const SLOT_NAME: felt252 = 'test_slot';\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl WriteToAnySlot of super::IWriteToAnySlots<ContractState> {\n"
"        fn write_slot(ref self: ContractState, value: u32) {\n"
"            storage_write_syscall(0, get_address_from_name(SLOT_NAME), value."
"into());\n"
"        }\n"
"\n"
"        fn read_slot(self: @ContractState) -> u32 {\n"
"            storage_read_syscall(0, get_address_from_name(SLOT_NAME))\n"
"                .unwrap_syscall()\n"
"                .try_into()\n"
"                .unwrap()\n"
"        }\n"
"    }\n"
"    fn get_address_from_name(variable_name: felt252) -> StorageAddress {\n"
"        let mut data: Array<felt252> = ArrayTrait::new();\n"
"        data.append(variable_name);\n"
"        let hashed_name: felt252 = poseidon_hash_span(data.span());\n"
"        let MASK_250: u256 = "
"0x03ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n"
"        // By taking the 250 least significant bits of the hash output, we "
"get a valid 250bits storage address.\n"
"        let result: felt252 = (hashed_name.into() & MASK_250).try_into()."
"unwrap();\n"
"        let result: StorageAddress = result.try_into().unwrap();\n"
"        result\n"
"    }\n"
"}\n"
"```"

#: src/ch02/write_to_any_slot.md:56
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x033943CB781A4E63C9dcE0A1A09eAa3b617AA43CC61637C08c043a67f3fe0087) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/write_to_any_slot/src/contract.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x033943CB781A4E63C9dcE0A1A09eAa3b617AA43CC61637C08c043a67f3fe0087) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/write_to_any_slot/src/contract.cairo)."

#: src/ch02/storing_arrays.md:1
msgid "# Storing Arrays"
msgstr "# Almacenamiento de Arrays"

#: src/ch02/storing_arrays.md:3
msgid ""
"On Starknet, complex values (e.g., tuples or structs), are stored in a "
"continuous segment starting from the address of the storage variable. There "
"is a 256 field elements limitation to the maximal size of a complex storage "
"value, meaning that to store arrays of more than 255 elements in storage, we "
"would need to split it into segments of size `n <= 255` and store these "
"segments in multiple storage addresses. There is currently no native support "
"for storing arrays in Cairo, so you will need to write your own "
"implementation of the `Store` trait for the type of array you wish to store."
msgstr ""
"En Starknet, los valores complejos (por ejemplo, tuplas o structs), se "
"almacenan en un segmento continuo a partir de la dirección de la variable de "
"almacenamiento. Hay una limitación de 256 elementos de campo para el tamaño "
"máximo de un valor de almacenamiento complejo, lo que significa que para "
"almacenar matrices de más de 255 elementos en el almacenamiento, "
"necesitaríamos dividirlo en segmentos de tamaño `n <= 255` y almacenar estos "
"segmentos en múltiples direcciones de almacenamiento. Actualmente no hay "
"soporte nativo para almacenar arrays en Cairo, por lo que necesitarás "
"escribir tu propia implementación del rasgo `Store` para el tipo de array "
"que desees almacenar."

#: src/ch02/storing_arrays.md:5
msgid ""
"> Note: While storing arrays in storage is possible, it is not always "
"recommended, as the read and write operations can get very costly. For "
"example, reading an array of size `n` requires `n` storage reads, and "
"writing to an array of size `n` requires `n` storage writes. If you only "
"need to access a single element of the array at a time, it is recommended to "
"use a `LegacyMap` and store the length in another variable instead."
msgstr ""
"> Nota: Aunque es posible almacenar arrays, no siempre es recomendable, ya "
"que las operaciones de lectura y escritura pueden ser muy costosas. Por "
"ejemplo, leer un array de tamaño `n` requiere `n` lecturas de "
"almacenamiento, y escribir en un array de tamaño `n` requiere `n` escrituras "
"de almacenamiento. Si sólo necesitas acceder a un único elemento del array "
"cada vez, se recomienda utilizar un `LegacyMap` y almacenar la longitud en "
"otra variable."

#: src/ch02/storing_arrays.md:7
msgid ""
"The following example demonstrates how to write a simple implementation of "
"the `StorageAccess` trait for the `Array<felt252>` type, allowing us to "
"store arrays of up to 255 `felt252` elements."
msgstr ""
"El siguiente ejemplo muestra cómo escribir una implementación sencilla del "
"trait `StorageAccess` para el tipo `Array<felt252>`, permitiéndonos "
"almacenar arrays de hasta 255 elementos `felt252`."

#: src/ch02/storing_arrays.md:9
msgid ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> "
"SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: "
"Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"\n"
"        // Read the stored array's length. If the length is superior to 255, "
"the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, "
"offset)\n"
"            .expect('Storage Span too large');\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the "
"array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, "
"base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"\n"
"        // Return the array.\n"
"        Result::Ok(arr)\n"
"    }\n"
"\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut "
"value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot.\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too "
"large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, "
"offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None(_) => { break Result::Ok(()); }\n"
"            };\n"
"        }\n"
"    }\n"
"\n"
"    fn size() -> u8 {\n"
"        255 * Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> "
"SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: "
"Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"\n"
"        // Read the stored array's length. If the length is superior to 255, "
"the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, "
"offset)\n"
"            .expect('Storage Span too large');\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the "
"array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, "
"base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"\n"
"        // Return the array.\n"
"        Result::Ok(arr)\n"
"    }\n"
"\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut "
"value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot.\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too "
"large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, "
"offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None(_) => { break Result::Ok(()); }\n"
"            };\n"
"        }\n"
"    }\n"
"\n"
"    fn size() -> u8 {\n"
"        255 * Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"

#: src/ch02/storing_arrays.md:73
msgid ""
"You can then import this implementation in your contract and use it to store "
"arrays in storage:"
msgstr ""
"A continuación, puede importar esta implementación en su contrato y "
"utilizarla para almacenar arrays en el almacenamiento:"

#: src/ch02/storing_arrays.md:75
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStoreArrayContract<TContractState> {\n"
"    fn store_array(ref self: TContractState, arr: Array<felt252>);\n"
"    fn read_array(self: @TContractState) -> Array<felt252>;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod StoreArrayContract {\n"
"    use super::StoreFelt252Array;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        arr: Array<felt252>\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StoreArrayImpl of super::IStoreArrayContract<ContractState> {\n"
"        fn store_array(ref self: ContractState, arr: Array<felt252>) {\n"
"            self.arr.write(arr);\n"
"        }\n"
"\n"
"        fn read_array(self: @ContractState) -> Array<felt252> {\n"
"            self.arr.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IStoreArrayContract<TContractState> {\n"
"    fn store_array(ref self: TContractState, arr: Array<felt252>);\n"
"    fn read_array(self: @TContractState) -> Array<felt252>;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod StoreArrayContract {\n"
"    use super::StoreFelt252Array;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        arr: Array<felt252>\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl StoreArrayImpl of super::IStoreArrayContract<ContractState> {\n"
"        fn store_array(ref self: ContractState, arr: Array<felt252>) {\n"
"            self.arr.write(arr);\n"
"        }\n"
"\n"
"        fn read_array(self: @ContractState) -> Array<felt252> {\n"
"            self.arr.read()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02/storing_arrays.md:103
msgid ""
"Visit contract on [Voyager](https://goerli.voyager.online/"
"contract/0x008F8069a3Fcd7691Db46Dc3b6F9D2C0436f9200E861330957Fd780A3595da86) "
"or play with it in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/storing_arrays/src/contract.cairo)."
msgstr ""
"Visita el contrato en [Voyager](https://goerli.voyager.online/"
"contract/0x008F8069a3Fcd7691Db46Dc3b6F9D2C0436f9200E861330957Fd780A3595da86) "
"o juega con él en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/storing_arrays/src/contract.cairo)."

#: src/ch02/struct-mapping-key.md:1
msgid "# Structs as mapping keys"
msgstr "# Estructuras como mapping keys"

#: src/ch02/struct-mapping-key.md:3
msgid ""
"In order to use structs as mapping keys, you can use `#[derive(Hash)]` on "
"the struct definition. This will automatically generate a hash function for "
"the struct that can be used to represent the struct as a key in a "
"`LegacyMap`."
msgstr ""
"Para utilizar estructuras como mapping keys, puede utilizar "
"`#[derive(Hash)]` en la definición de la estructura. Esto generará "
"automáticamente una función hash para la estructura que se puede utilizar "
"para representar la estructura como una key en un `LegacyMap`."

#: src/ch02/struct-mapping-key.md:5
msgid ""
"Consider the following example in which we would like to use an object of\n"
"type `Pet` as a key in a `LegacyMap`. The `Pet` struct has three fields: "
"`name`, `age` and `owner`. We consider that the combination of these three "
"fields uniquely identifies a pet."
msgstr ""
"Consideremos el siguiente ejemplo en el que queremos utilizar un objeto de "
"tipo `Pet` como clave en un `LegacyMap`. La estructura `Pet` tiene tres "
"campos: `nombre`, `edad` y `propietario`. Consideramos que la combinación de "
"estos tres campos identifica de forma única a una mascota."

#: src/ch02/struct-mapping-key.md:8
msgid ""
"```rust\n"
"#[derive(Copy, Drop, Serde, Hash)]\n"
"struct Pet {\n"
"    name: felt252,\n"
"    age: u8,\n"
"    owner: felt252,\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IPetRegistry<TContractState> {\n"
"    fn register_pet(ref self: TContractState, key: Pet, timestamp: u64);\n"
"    fn get_registration_date(self: @TContractState, key: Pet) -> u64;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod PetRegistry {\n"
"    use hash::{HashStateTrait, Hash};\n"
"    use super::Pet;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        registration_time: LegacyMap::<Pet, u64>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl PetRegistry of super::IPetRegistry<ContractState> {\n"
"        fn register_pet(ref self: ContractState, key: Pet, timestamp: u64) "
"{\n"
"            self.registration_time.write(key, timestamp);\n"
"        }\n"
"\n"
"        fn get_registration_date(self: @ContractState, key: Pet) -> u64 {\n"
"            self.registration_time.read(key)\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[derive(Copy, Drop, Serde, Hash)]\n"
"struct Pet {\n"
"    name: felt252,\n"
"    age: u8,\n"
"    owner: felt252,\n"
"}\n"
"\n"
"#[starknet::interface]\n"
"trait IPetRegistry<TContractState> {\n"
"    fn register_pet(ref self: TContractState, key: Pet, timestamp: u64);\n"
"    fn get_registration_date(self: @TContractState, key: Pet) -> u64;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod PetRegistry {\n"
"    use hash::{HashStateTrait, Hash};\n"
"    use super::Pet;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        registration_time: LegacyMap::<Pet, u64>,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl PetRegistry of super::IPetRegistry<ContractState> {\n"
"        fn register_pet(ref self: ContractState, key: Pet, timestamp: u64) "
"{\n"
"            self.registration_time.write(key, timestamp);\n"
"        }\n"
"\n"
"        fn get_registration_date(self: @ContractState, key: Pet) -> u64 {\n"
"            self.registration_time.read(key)\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02/struct-mapping-key.md:45
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/struct_as_mapping_key/src/contract."
"cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/struct_as_mapping_key/src/contract."
"cairo)."

#: src/ch02/hashing.md:1
msgid "# Hashing"
msgstr "# Hashing"

#: src/ch02/hashing.md:3
msgid ""
"Hashing is a cryptographic technique that allows you to transform a variable "
"length input into a fixed length output.\n"
"The resulting output is called a hash and it's completely different from the "
"input.\n"
"Hash functions are deterministic, meaning that the same input will always "
"produce the same output."
msgstr ""
"El hash es una técnica criptográfica que permite transformar una entrada de "
"longitud variable en una salida de longitud fija.\n"
"La salida resultante se llama hash y es completamente diferente de la "
"entrada.\n"
"Las funciones hash son deterministas, lo que significa que la misma entrada "
"siempre producirá la misma salida."

#: src/ch02/hashing.md:7
msgid ""
"The two hash functions provided by the Cairo library are `Poseidon` and "
"`Pedersen`.\n"
"Pedersen hashes were used in the past (but still used in some scenario for "
"backward compatibility) while Poseidon hashes are the standard nowadays "
"since they were designed to be very efficient for Zero Knowledge proof "
"systems."
msgstr ""
"Las dos funciones hash proporcionadas por la librería Cairo son `Poseidon` y "
"`Pedersen`.\n"
"Los hashes Pedersen se usaban en el pasado (pero todavía se usan en algunos "
"escenarios por compatibilidad con versiones anteriores) mientras que los "
"hashes Poseidon son el estándar hoy en día ya que fueron diseñados para ser "
"muy eficientes para sistemas de Zero Knowledge proof."

#: src/ch02/hashing.md:10
msgid ""
"In Cairo it's possible to hash all the types that can be converted to "
"`felt252` since they implement natively the `Hash` trait. It's also possible "
"to hash more complex types like structs by deriving the Hash trait with the "
"attribute `#[derive(Hash)]` but only if all the struct's fields are "
"themselves hashable."
msgstr ""
"En Cairo es posible hacer hash de todos los tipos que se pueden convertir a "
"`felt252` ya que implementan nativamente el trait `Hash`. También es posible "
"hacer hash de tipos más complejos como structs derivando el rasgo Hash con "
"el atributo `#[derive(Hash)]` pero sólo si todos los campos del struct son a "
"su vez hashables."

#: src/ch02/hashing.md:12
msgid ""
"You first need to initialize a hash state with the `new` method of the "
"`HashStateTrait` and then you can update it with the `update` method. You "
"can accumulate multiple updates. Then, the `finalize` method returns the "
"final hash value as a `felt252`."
msgstr ""
"Primero necesitas inicializar un estado hash con el método `new` del "
"`HashStateTrait` y luego puedes actualizarlo con el método `update`. Puedes "
"acumular múltiples actualizaciones. A continuación, el método `finalize` "
"devuelve el valor hash final como un `felt252`."

#: src/ch02/hashing.md:14
msgid ""
"```rust\n"
"# #[starknet::interface]\n"
"# trait IHashTrait<T> {\n"
"#     fn save_user_with_poseidon(\n"
"#         ref self: T, id: felt252, username: felt252, password: felt252\n"
"#     ) -> felt252;\n"
"#     fn save_user_with_pedersen(\n"
"#         ref self: T, id: felt252, username: felt252, password: felt252\n"
"#     ) -> felt252;\n"
"# }\n"
"# \n"
"#[starknet::contract]\n"
"mod HashTraits {\n"
"    use core::hash::{HashStateTrait, HashStateExTrait};\n"
"    use core::{pedersen::PedersenTrait, poseidon::PoseidonTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        user_hash_poseidon: felt252,\n"
"        user_hash_pedersen: felt252,\n"
"    }\n"
"\n"
"    #[derive(Drop, Hash)]\n"
"    struct LoginDetails {\n"
"        username: felt252,\n"
"        password: felt252,\n"
"    }\n"
"\n"
"    #[derive(Drop, Hash)]\n"
"    struct UserDetails {\n"
"        id: felt252,\n"
"        login: LoginDetails,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl HashTrait of super::IHashTrait<ContractState> {\n"
"        fn save_user_with_poseidon(\n"
"            ref self: ContractState, id: felt252, username: felt252, "
"password: felt252\n"
"        ) -> felt252 {\n"
"            let login = LoginDetails { username, password };\n"
"            let user = UserDetails { id, login };\n"
"\n"
"            let poseidon_hash = PoseidonTrait::new().update_with(user)."
"finalize();\n"
"\n"
"            self.user_hash_poseidon.write(poseidon_hash);\n"
"            poseidon_hash\n"
"        }\n"
"\n"
"        fn save_user_with_pedersen(\n"
"            ref self: ContractState, id: felt252, username: felt252, "
"password: felt252\n"
"        ) -> felt252 {\n"
"            let login = LoginDetails { username, password };\n"
"            let user = UserDetails { id, login };\n"
"\n"
"            let pedersen_hash = PedersenTrait::new(0).update_with(user)."
"finalize();\n"
"\n"
"            self.user_hash_pedersen.write(pedersen_hash);\n"
"            pedersen_hash\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::{HashTraits, IHashTraitDispatcher, "
"IHashTraitDispatcherTrait};\n"
"# \n"
"#     use core::hash::{HashStateTrait, HashStateExTrait};\n"
"#     use core::{pedersen::PedersenTrait, poseidon::PoseidonTrait};\n"
"#     use starknet::{deploy_syscall};\n"
"# \n"
"#     use debug::PrintTrait;\n"
"# \n"
"#     fn deploy() -> IHashTraitDispatcher {\n"
"#         let mut calldata = ArrayTrait::new();\n"
"#         let (address, _) = deploy_syscall(\n"
"#             HashTraits::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata."
"span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"#         IHashTraitDispatcher { contract_address: address }\n"
"#     }\n"
"# \n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(20000000)]\n"
"#     fn test_pedersen_hash() {\n"
"#         let mut contract = deploy();\n"
"# \n"
"#         let id = 0x1;\n"
"#         let username = 'A.stark';\n"
"#         let password = 'password.stark';\n"
"#         let test_hash = contract.save_user_with_pedersen(id, username, "
"password);\n"
"# \n"
"#         assert(\n"
"#             test_hash == "
"0x6da4b4d0489989f5483d179643dafb3405b0e3b883a6c8efe5beb824ba9055a,\n"
"#             'Incorrect hash output'\n"
"#         );\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(20000000)]\n"
"#     fn test_poseidon_hash() {\n"
"#         let mut contract = deploy();\n"
"# \n"
"#         let id = 0x1;\n"
"#         let username = 'A.stark';\n"
"#         let password = 'password.stark';\n"
"# \n"
"#         let test_hash = contract.save_user_with_poseidon(id, username, "
"password);\n"
"# \n"
"#         test_hash.print();\n"
"# \n"
"#         assert(\n"
"#             test_hash == "
"0x4d165e1d398ae4864854518d3c58c3d7a21ed9c1f8f3618fbb0031d208aab7b,\n"
"#             'Incorrect hash output'\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"
msgstr ""
"```rust\n"
"# #[starknet::interface]\n"
"# trait IHashTrait<T> {\n"
"#     fn save_user_with_poseidon(\n"
"#         ref self: T, id: felt252, username: felt252, password: felt252\n"
"#     ) -> felt252;\n"
"#     fn save_user_with_pedersen(\n"
"#         ref self: T, id: felt252, username: felt252, password: felt252\n"
"#     ) -> felt252;\n"
"# }\n"
"# \n"
"#[starknet::contract]\n"
"mod HashTraits {\n"
"    use core::hash::{HashStateTrait, HashStateExTrait};\n"
"    use core::{pedersen::PedersenTrait, poseidon::PoseidonTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        user_hash_poseidon: felt252,\n"
"        user_hash_pedersen: felt252,\n"
"    }\n"
"\n"
"    #[derive(Drop, Hash)]\n"
"    struct LoginDetails {\n"
"        username: felt252,\n"
"        password: felt252,\n"
"    }\n"
"\n"
"    #[derive(Drop, Hash)]\n"
"    struct UserDetails {\n"
"        id: felt252,\n"
"        login: LoginDetails,\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl HashTrait of super::IHashTrait<ContractState> {\n"
"        fn save_user_with_poseidon(\n"
"            ref self: ContractState, id: felt252, username: felt252, "
"password: felt252\n"
"        ) -> felt252 {\n"
"            let login = LoginDetails { username, password };\n"
"            let user = UserDetails { id, login };\n"
"\n"
"            let poseidon_hash = PoseidonTrait::new().update_with(user)."
"finalize();\n"
"\n"
"            self.user_hash_poseidon.write(poseidon_hash);\n"
"            poseidon_hash\n"
"        }\n"
"\n"
"        fn save_user_with_pedersen(\n"
"            ref self: ContractState, id: felt252, username: felt252, "
"password: felt252\n"
"        ) -> felt252 {\n"
"            let login = LoginDetails { username, password };\n"
"            let user = UserDetails { id, login };\n"
"\n"
"            let pedersen_hash = PedersenTrait::new(0).update_with(user)."
"finalize();\n"
"\n"
"            self.user_hash_pedersen.write(pedersen_hash);\n"
"            pedersen_hash\n"
"        }\n"
"    }\n"
"}\n"
"# \n"
"# #[cfg(test)]\n"
"# mod tests {\n"
"#     use super::{HashTraits, IHashTraitDispatcher, "
"IHashTraitDispatcherTrait};\n"
"# \n"
"#     use core::hash::{HashStateTrait, HashStateExTrait};\n"
"#     use core::{pedersen::PedersenTrait, poseidon::PoseidonTrait};\n"
"#     use starknet::{deploy_syscall};\n"
"# \n"
"#     use debug::PrintTrait;\n"
"# \n"
"#     fn deploy() -> IHashTraitDispatcher {\n"
"#         let mut calldata = ArrayTrait::new();\n"
"#         let (address, _) = deploy_syscall(\n"
"#             HashTraits::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata."
"span(), false\n"
"#         )\n"
"#             .unwrap();\n"
"#         IHashTraitDispatcher { contract_address: address }\n"
"#     }\n"
"# \n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(20000000)]\n"
"#     fn test_pedersen_hash() {\n"
"#         let mut contract = deploy();\n"
"# \n"
"#         let id = 0x1;\n"
"#         let username = 'A.stark';\n"
"#         let password = 'password.stark';\n"
"#         let test_hash = contract.save_user_with_pedersen(id, username, "
"password);\n"
"# \n"
"#         assert(\n"
"#             test_hash == "
"0x6da4b4d0489989f5483d179643dafb3405b0e3b883a6c8efe5beb824ba9055a,\n"
"#             'Incorrect hash output'\n"
"#         );\n"
"#     }\n"
"# \n"
"#     #[test]\n"
"#     #[available_gas(20000000)]\n"
"#     fn test_poseidon_hash() {\n"
"#         let mut contract = deploy();\n"
"# \n"
"#         let id = 0x1;\n"
"#         let username = 'A.stark';\n"
"#         let password = 'password.stark';\n"
"# \n"
"#         let test_hash = contract.save_user_with_poseidon(id, username, "
"password);\n"
"# \n"
"#         test_hash.print();\n"
"# \n"
"#         assert(\n"
"#             test_hash == "
"0x4d165e1d398ae4864854518d3c58c3d7a21ed9c1f8f3618fbb0031d208aab7b,\n"
"#             'Incorrect hash output'\n"
"#         );\n"
"#     }\n"
"# }\n"
"```"

#: src/ch02/hash-solidity-compatible.md:1
msgid "# Hash Solidity Compatible"
msgstr "# Hash compatible con Solidity"

#: src/ch02/hash-solidity-compatible.md:3
msgid ""
"This contract demonstrates Keccak hashing in Cairo to match Solidity's "
"keccak256. While both use Keccak, their endianness differs: Cairo is little-"
"endian, Solidity big-endian. The contract achieves compatibility by hashing "
"in big-endian using `keccak_u256s_be_inputs`, and reversing the bytes of the "
"result with `u128_byte_reverse`."
msgstr ""
"Este contrato demuestra el hashing Keccak en Cairo para que coincida con el "
"keccak256 de Solidity. Mientras que ambos usan Keccak, su endianness "
"difiere: Cairo es little-endian, Solidity big-endian. El contrato consigue "
"la compatibilidad haciendo hashing en big-endian usando "
"`keccak_u256s_be_inputs`, e invirtiendo los bytes del resultado con "
"`u128_byte_reverse`."

#: src/ch02/hash-solidity-compatible.md:7
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISolidityHashExample<TContractState> {\n"
"    fn hash_data(ref self: TContractState, input_data: Span<u256>) -> u256;\n"
"}\n"
"\n"
"\n"
"#[starknet::contract]\n"
"mod SolidityHashExample {\n"
"    use keccak::{keccak_u256s_be_inputs};\n"
"    use array::Span;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SolidityHashExample of super::ISolidityHashExample<ContractState> "
"{\n"
"        fn hash_data(ref self: ContractState, input_data: Span<u256>) -> "
"u256 {\n"
"            let hashed = keccak_u256s_be_inputs(input_data);\n"
"\n"
"            // Split the hashed value into two 128-bit segments\n"
"            let low: u128 = hashed.low;\n"
"            let high: u128 = hashed.high;\n"
"\n"
"            // Reverse each 128-bit segment\n"
"            let reversed_low = integer::u128_byte_reverse(low);\n"
"            let reversed_high = integer::u128_byte_reverse(high);\n"
"\n"
"            // Reverse merge the reversed segments back into a u256 value\n"
"            let compatible_hash = u256 { low: reversed_high, high: "
"reversed_low };\n"
"\n"
"            compatible_hash\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ISolidityHashExample<TContractState> {\n"
"    fn hash_data(ref self: TContractState, input_data: Span<u256>) -> u256;\n"
"}\n"
"\n"
"\n"
"#[starknet::contract]\n"
"mod SolidityHashExample {\n"
"    use keccak::{keccak_u256s_be_inputs};\n"
"    use array::Span;\n"
"\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl SolidityHashExample of super::ISolidityHashExample<ContractState> "
"{\n"
"        fn hash_data(ref self: ContractState, input_data: Span<u256>) -> "
"u256 {\n"
"            let hashed = keccak_u256s_be_inputs(input_data);\n"
"\n"
"            // Split the hashed value into two 128-bit segments\n"
"            let low: u128 = hashed.low;\n"
"            let high: u128 = hashed.high;\n"
"\n"
"            // Reverse each 128-bit segment\n"
"            let reversed_low = integer::u128_byte_reverse(low);\n"
"            let reversed_high = integer::u128_byte_reverse(high);\n"
"\n"
"            // Reverse merge the reversed segments back into a u256 value\n"
"            let compatible_hash = u256 { low: reversed_high, high: "
"reversed_low };\n"
"\n"
"            compatible_hash\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02/hash-solidity-compatible.md:44
msgid ""
"Play with the contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/hash_solidity_compatible/src/contract."
"cairo)."
msgstr ""
"Juega con el contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet&url=https://github.com/NethermindEth/StarknetByExample/"
"blob/main/listings/advanced-concepts/hash_solidity_compatible/src/contract."
"cairo)."

#: src/ch02/optimisations/optimisations.md:1
msgid "# Optimisations "
msgstr "# Optimizaciones "

#: src/ch02/optimisations/optimisations.md:3
msgid "A collection of optimisation patterns to save gas and steps."
msgstr "Una colección de patrones de optimización para ahorrar gas y pasos."

#: src/ch02/optimisations/store_using_packing.md:1
msgid "# Storage optimisation "
msgstr "# Optimización del Storage "

#: src/ch02/optimisations/store_using_packing.md:3
msgid ""
"A smart contract has a limited amount of **storage slots**. Each slot can "
"store a single `felt252` value.\n"
"Writing to a storage slot has a cost, so we want to use as few storage slots "
"as possible."
msgstr ""
"Un contrato inteligente tiene una cantidad limitada de **ranuras de "
"almacenamiento**. Cada ranura puede almacenar un único valor `felt252`. \n"
"Escribir en una ranura de almacenamiento tiene un coste, por lo que queremos "
"utilizar el menor número posible de ranuras de almacenamiento."

#: src/ch02/optimisations/store_using_packing.md:6
msgid ""
"In Cairo, every type is derived from the `felt252` type, which uses 252 bits "
"to store a value.\n"
"This design is quite simple, but it does have a drawback: it is not storage "
"efficient. For example, if we want to store a `u8` value, we need to use an "
"entire slot, even though we only need 8 bits."
msgstr ""
"En Cairo, cada tipo deriva del tipo `felt252`, que utiliza 252 bits para "
"almacenar un valor.\n"
"Este diseño es bastante simple, pero tiene un inconveniente: no es eficiente "
"en almacenamiento. Por ejemplo, si queremos almacenar un valor `u8`, "
"necesitamos usar un slot entero, aunque sólo necesitemos 8 bits."

#: src/ch02/optimisations/store_using_packing.md:9
msgid "## Packing"
msgstr "## Packing"

#: src/ch02/optimisations/store_using_packing.md:11
msgid ""
"When storing multiple values, we can use a technique called **packing**. "
"Packing is a technique that allows us to store multiple values in a single "
"felt value. This is done by using the bits of the felt value to store "
"multiple values."
msgstr ""
"Cuando almacenamos múltiples valores, podemos utilizar una técnica llamada "
"**packing**. El empaquetado es una técnica que nos permite almacenar "
"múltiples valores en un único valor de felt. Esto se hace utilizando los "
"bits del valor de felt para almacenar múltiples valores."

#: src/ch02/optimisations/store_using_packing.md:13
msgid ""
"For example, if we want to store two `u8` values, we can use the first 8 "
"bits of the felt value to store the first `u8` value, and the last 8 bits to "
"store the second `u8` value. This way, we can store two `u8` values in a "
"single felt value."
msgstr ""
"Por ejemplo, si queremos almacenar dos valores `u8`, podemos utilizar los "
"primeros 8 bits del valor de felt para almacenar el primer valor `u8`, y los "
"últimos 8 bits para almacenar el segundo valor `u8`. De esta forma, podemos "
"almacenar dos valores `u8` en un único valor de felt."

#: src/ch02/optimisations/store_using_packing.md:15
msgid ""
"Cairo provides a built-in store using packing that you can use with the "
"`StorePacking` trait."
msgstr ""
"Cairo proporciona un almacén incorporado que usa empaquetado que puedes usar "
"con el trait `StorePacking`."

#: src/ch02/optimisations/store_using_packing.md:17
msgid ""
"```rust\n"
"trait StorePacking<T, PackedT> {\n"
"    fn pack(value: T) -> PackedT;\n"
"    fn unpack(value: PackedT) -> T;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait StorePacking<T, PackedT> {\n"
"    fn pack(value: T) -> PackedT;\n"
"    fn unpack(value: PackedT) -> T;\n"
"}\n"
"```"

#: src/ch02/optimisations/store_using_packing.md:24
msgid ""
"This allows to store the type `T` by first packing it into the type "
"`PackedT` with the `pack` function, and then storing the `PackedT` value "
"with it's `Store` implementation. When reading the value, we first retrieve "
"the `PackedT` value, and then unpack it into the type `T` using the `unpack` "
"function."
msgstr ""
"Esto permite almacenar el tipo `T` empaquetándolo primero en el tipo "
"`PackedT` con la función `pack`, y luego almacenando el valor `PackedT` con "
"su implementación `Store`. Al leer el valor, primero recuperamos el valor "
"`PackedT`, y luego lo desempaquetamos en el tipo `T` utilizando la función "
"`unpack`."

#: src/ch02/optimisations/store_using_packing.md:26
msgid ""
"Here's an example of storing a `Time` struct with two `u8` values using the "
"`StorePacking` trait:"
msgstr ""
"He aquí un ejemplo de almacenamiento de una estructura `Time` con dos "
"valores `u8` utilizando el trait `StorePacking`:"

#: src/ch02/optimisations/store_using_packing.md:28
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait ITime<TContractState> {\n"
"    fn set(ref self: TContractState, value: TimeContract::Time);\n"
"    fn get(self: @TContractState) -> TimeContract::Time;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod TimeContract {\n"
"    use starknet::storage_access::StorePacking;\n"
"    use integer::{\n"
"        U8IntoFelt252, Felt252TryIntoU16, U16DivRem, u16_as_non_zero, "
"U16IntoFelt252,\n"
"        Felt252TryIntoU8\n"
"    };\n"
"    use traits::{Into, TryInto, DivRem};\n"
"    use option::OptionTrait;\n"
"    use serde::Serde;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        time: Time\n"
"    }\n"
"\n"
"    #[derive(Copy, Serde, Drop)]\n"
"    struct Time {\n"
"        hour: u8,\n"
"        minute: u8\n"
"    }\n"
"\n"
"    impl TimePackable of StorePacking<Time, felt252> {\n"
"        fn pack(value: Time) -> felt252 {\n"
"            let msb: felt252 = 256 * value.hour.into();\n"
"            let lsb: felt252 = value.minute.into();\n"
"            return msb + lsb;\n"
"        }\n"
"        fn unpack(value: felt252) -> Time {\n"
"            let value: u16 = value.try_into().unwrap();\n"
"            let (q, r) = U16DivRem::div_rem(value, u16_as_non_zero(256));\n"
"            let hour: u8 = Into::<u16, felt252>::into(q).try_into()."
"unwrap();\n"
"            let minute: u8 = Into::<u16, felt252>::into(r).try_into()."
"unwrap();\n"
"            return Time { hour, minute };\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl TimeContract of super::ITime<ContractState> {\n"
"        fn set(ref self: ContractState, value: Time) {\n"
"            // This will call the pack method of the TimePackable trait\n"
"            // and store the resulting felt252\n"
"            self.time.write(value);\n"
"        }\n"
"        fn get(self: @ContractState) -> Time {\n"
"            // This will read the felt252 value from storage\n"
"            // and return the result of the unpack method of the "
"TimePackable trait\n"
"            return self.time.read();\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait ITime<TContractState> {\n"
"    fn set(ref self: TContractState, value: TimeContract::Time);\n"
"    fn get(self: @TContractState) -> TimeContract::Time;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod TimeContract {\n"
"    use starknet::storage_access::StorePacking;\n"
"    use integer::{\n"
"        U8IntoFelt252, Felt252TryIntoU16, U16DivRem, u16_as_non_zero, "
"U16IntoFelt252,\n"
"        Felt252TryIntoU8\n"
"    };\n"
"    use traits::{Into, TryInto, DivRem};\n"
"    use option::OptionTrait;\n"
"    use serde::Serde;\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        time: Time\n"
"    }\n"
"\n"
"    #[derive(Copy, Serde, Drop)]\n"
"    struct Time {\n"
"        hour: u8,\n"
"        minute: u8\n"
"    }\n"
"\n"
"    impl TimePackable of StorePacking<Time, felt252> {\n"
"        fn pack(value: Time) -> felt252 {\n"
"            let msb: felt252 = 256 * value.hour.into();\n"
"            let lsb: felt252 = value.minute.into();\n"
"            return msb + lsb;\n"
"        }\n"
"        fn unpack(value: felt252) -> Time {\n"
"            let value: u16 = value.try_into().unwrap();\n"
"            let (q, r) = U16DivRem::div_rem(value, u16_as_non_zero(256));\n"
"            let hour: u8 = Into::<u16, felt252>::into(q).try_into()."
"unwrap();\n"
"            let minute: u8 = Into::<u16, felt252>::into(r).try_into()."
"unwrap();\n"
"            return Time { hour, minute };\n"
"        }\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl TimeContract of super::ITime<ContractState> {\n"
"        fn set(ref self: ContractState, value: Time) {\n"
"            // This will call the pack method of the TimePackable trait\n"
"            // and store the resulting felt252\n"
"            self.time.write(value);\n"
"        }\n"
"        fn get(self: @ContractState) -> Time {\n"
"            // This will read the felt252 value from storage\n"
"            // and return the result of the unpack method of the "
"TimePackable trait\n"
"            return self.time.read();\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/ch02/optimisations/store_using_packing.md:88
msgid ""
"Play with this contract in [Remix](https://remix.ethereum.org/?"
"#activate=Starknet-cairo1-compiler&url=https://github.com/NethermindEth/"
"StarknetByExample/blob/main/listings/advanced-concepts/store_using_packing/"
"src/contract.cairo)."
msgstr ""
"Juega con este contrato en [Remix](https://remix.ethereum.org/?"
"#activate=Starknet-cairo1-compiler&url=https://github.com/NethermindEth/"
"StarknetByExample/blob/main/listings/advanced-concepts/store_using_packing/"
"src/contract.cairo)."

#: src/ch02/list.md:1
msgid "# List"
msgstr "# Lista"

#: src/ch02/list.md:3
msgid ""
"By default, there is no list type supported in Cairo, but you can use "
"Alexandria. You can refer to the [Alexandria documentation](https://github."
"com/keep-starknet-strange/alexandria/tree/main/src/storage) for more details."
msgstr ""
"Por defecto, no hay ningún tipo de lista soportado en Cairo, pero puedes "
"usar Alexandria. Puede consultar la [documentación de Alexandria](https://"
"github.com/keep-starknet-strange/alexandria/tree/main/src/storage) para más "
"detalles."

#: src/ch02/list.md:5
msgid "## What is `List`?"
msgstr "## ¿Qué es `List`?"

#: src/ch02/list.md:7
msgid "An ordered sequence of values that can be used in Starknet storage:"
msgstr ""
"Una secuencia ordenada de valores que puede utilizarse en el storage de "
"Starknet:"

#: src/ch02/list.md:9
msgid ""
"```rust\n"
"#[storage]\n"
"stuct Storage {\n"
"  amounts: List<u128>\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[storage]\n"
"stuct Storage {\n"
"  amounts: List<u128>\n"
"}\n"
"```"

#: src/ch02/list.md:16
msgid "### Interface"
msgstr "### Interface"

#: src/ch02/list.md:18
msgid ""
"```rust\n"
"trait ListTrait<T> {\n"
"  fn len(self: @List<T>) -> u32;\n"
"  fn is_empty(self: @List<T>) -> bool;\n"
"  fn append(ref self: List<T>, value: T) -> u32;\n"
"  fn get(self: @List<T>, index: u32) -> Option<T>;\n"
"  fn set(ref self: List<T>, index: u32, value: T);\n"
"  fn pop_front(ref self: List<T>) -> Option<T>;\n"
"  fn array(self: @List<T>) -> Array<T>;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"trait ListTrait<T> {\n"
"  fn len(self: @List<T>) -> u32;\n"
"  fn is_empty(self: @List<T>) -> bool;\n"
"  fn append(ref self: List<T>, value: T) -> u32;\n"
"  fn get(self: @List<T>, index: u32) -> Option<T>;\n"
"  fn set(ref self: List<T>, index: u32, value: T);\n"
"  fn pop_front(ref self: List<T>) -> Option<T>;\n"
"  fn array(self: @List<T>) -> Array<T>;\n"
"}\n"
"```"

#: src/ch02/list.md:30
msgid ""
"`List` also implements `IndexView` so you can use the familiar bracket "
"notation to access its members:"
msgstr ""
"`List` también implementa `IndexView` para que puedas utilizar la notación "
"familiar de corchetes para acceder a sus miembros:"

#: src/ch02/list.md:32
msgid ""
"```rust\n"
"let second = self.amounts.read()[1];\n"
"```"
msgstr ""
"```rust\n"
"let second = self.amounts.read()[1];\n"
"```"

#: src/ch02/list.md:36
msgid ""
"Note that unlike `get`, using this bracket notation panics when accessing an "
"out of bounds index."
msgstr ""
"Tenga en cuenta que, a diferencia de `get`, el uso de esta notación de "
"corchetes entra en pánico cuando se accede a un índice fuera de los límites."

#: src/ch02/list.md:38
msgid "### Support for custom types"
msgstr "### Compatibilidad con tipos personalizados"

#: src/ch02/list.md:40
msgid ""
"`List` supports most of the corelib types out of the box. If you want to "
"store a your own custom type in a `List`, it has to implement the `Store` "
"trait. You can have the compiler derive it for you using the "
"`#[derive(starknet::Store)]` attribute."
msgstr ""
"`List` soporta la mayoría de los tipos de corelib. Si quieres almacenar un "
"tipo personalizado en una `List`, tiene que implementar el trait `Store`. "
"Puedes hacer que el compilador lo derive por ti usando el atributo "
"`#[derive(starknet::Store)]`."

#: src/ch02/list.md:42
msgid "### Caveats"
msgstr "### Advertencias"

#: src/ch02/list.md:44
msgid "There are two idiosyncacies you should be aware of when using `List`"
msgstr "Hay dos particularidades que debe tener en cuenta al utilizar `List`"

#: src/ch02/list.md:46
msgid ""
"1. The `append` operation costs 2 storage writes - one for the value itself "
"and another one for updating the List's length\n"
"2. Due to a compiler limitation, it is not possible to use mutating "
"operations with a single inline statement. For example, `self.amounts.read()."
"append(42);` will not work. You have to do it in 2 steps:"
msgstr ""
"1. La operación `append` cuesta 2 escrituras de almacenamiento - una para el "
"valor en sí y otra para actualizar la longitud de la Lista\n"
"2. Debido a una limitación del compilador, no es posible utilizar "
"operaciones de mutación con una única sentencia inline. Por ejemplo, `self."
"amounts.read().append(42);` no funcionará. Tienes que hacerlo en 2 pasos:"

#: src/ch02/list.md:49
msgid ""
"```rust\n"
"let mut amounts = self.amounts.read();\n"
"amounts.append(42);\n"
"```"
msgstr ""
"```rust\n"
"let mut amounts = self.amounts.read();\n"
"amounts.append(42);\n"
"```"

#: src/ch02/list.md:54
msgid "### Dependencies"
msgstr "### Dependencias"

#: src/ch02/list.md:56
msgid "Update your project dependencies by in the `Scarb.toml` file:"
msgstr "Actualice las dependencias de su proyecto en el archivo `Scarb.toml`:"

#: src/ch02/list.md:57
msgid ""
"```rust\n"
"[dependencies]\n"
"(...)\n"
"alexandria_storage = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\" }\n"
"```"
msgstr ""
"```rust\n"
"[dependencies]\n"
"(...)\n"
"alexandria_storage = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\" }\n"
"```"

#: src/ch02/list.md:63
msgid ""
"For example, let's use `List` to create a contract that tracks a list of "
"amounts and tasks:"
msgstr ""
"Por ejemplo, utilicemos `List` para crear un contrato que realice el "
"seguimiento de una lista de importes y tareas:"

#: src/ch02/list.md:65
msgid ""
"```rust\n"
"#[starknet::interface]\n"
"trait IListExample<TContractState> {\n"
"    fn add_in_amount(ref self: TContractState, number: u128);\n"
"    fn add_in_task(ref self: TContractState, description: felt252, status: "
"felt252);\n"
"    fn is_empty_list(self: @TContractState) -> bool;\n"
"    fn list_length(self: @TContractState) -> u32;\n"
"    fn get_from_index(self: @TContractState, index: u32) -> u128;\n"
"    fn set_from_index(ref self: TContractState, index: u32, number: u128);\n"
"    fn pop_front_list(ref self: TContractState);\n"
"    fn array_conversion(self: @TContractState) -> Array<u128>;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ListExample {\n"
"    use alexandria_storage::list::{List, ListTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        amount: List<u128>,\n"
"        tasks: List<Task>\n"
"    }\n"
"\n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Task {\n"
"        description: felt252,\n"
"        status: felt252\n"
"    }\n"
"\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ListExample of super::IListExample<ContractState> {\n"
"        fn add_in_amount(ref self: ContractState, number: u128) {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.append(number);\n"
"        }\n"
"\n"
"        fn add_in_task(ref self: ContractState, description: felt252, "
"status: felt252) {\n"
"            let new_task = Task { description: description, status: "
"status };\n"
"            let mut current_tasks_list = self.tasks.read();\n"
"            current_tasks_list.append(new_task);\n"
"        }\n"
"\n"
"        fn is_empty_list(self: @ContractState) -> bool {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.is_empty()\n"
"        }\n"
"\n"
"        fn list_length(self: @ContractState) -> u32 {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.len()\n"
"        }\n"
"\n"
"        fn get_from_index(self: @ContractState, index: u32) -> u128 {\n"
"            self.amount.read()[index]\n"
"        }\n"
"\n"
"        fn set_from_index(ref self: ContractState, index: u32, number: u128) "
"{\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.set(index, number);\n"
"        }\n"
"\n"
"        fn pop_front_list(ref self: ContractState) {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.pop_front();\n"
"        }\n"
"\n"
"        fn array_conversion(self: @ContractState) -> Array<u128> {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.array()\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::interface]\n"
"trait IListExample<TContractState> {\n"
"    fn add_in_amount(ref self: TContractState, number: u128);\n"
"    fn add_in_task(ref self: TContractState, description: felt252, status: "
"felt252);\n"
"    fn is_empty_list(self: @TContractState) -> bool;\n"
"    fn list_length(self: @TContractState) -> u32;\n"
"    fn get_from_index(self: @TContractState, index: u32) -> u128;\n"
"    fn set_from_index(ref self: TContractState, index: u32, number: u128);\n"
"    fn pop_front_list(ref self: TContractState);\n"
"    fn array_conversion(self: @TContractState) -> Array<u128>;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ListExample {\n"
"    use alexandria_storage::list::{List, ListTrait};\n"
"\n"
"    #[storage]\n"
"    struct Storage {\n"
"        amount: List<u128>,\n"
"        tasks: List<Task>\n"
"    }\n"
"\n"
"    #[derive(Copy, Drop, Serde, starknet::Store)]\n"
"    struct Task {\n"
"        description: felt252,\n"
"        status: felt252\n"
"    }\n"
"\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl ListExample of super::IListExample<ContractState> {\n"
"        fn add_in_amount(ref self: ContractState, number: u128) {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.append(number);\n"
"        }\n"
"\n"
"        fn add_in_task(ref self: ContractState, description: felt252, "
"status: felt252) {\n"
"            let new_task = Task { description: description, status: "
"status };\n"
"            let mut current_tasks_list = self.tasks.read();\n"
"            current_tasks_list.append(new_task);\n"
"        }\n"
"\n"
"        fn is_empty_list(self: @ContractState) -> bool {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.is_empty()\n"
"        }\n"
"\n"
"        fn list_length(self: @ContractState) -> u32 {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.len()\n"
"        }\n"
"\n"
"        fn get_from_index(self: @ContractState, index: u32) -> u128 {\n"
"            self.amount.read()[index]\n"
"        }\n"
"\n"
"        fn set_from_index(ref self: ContractState, index: u32, number: u128) "
"{\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.set(index, number);\n"
"        }\n"
"\n"
"        fn pop_front_list(ref self: ContractState) {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.pop_front();\n"
"        }\n"
"\n"
"        fn array_conversion(self: @ContractState) -> Array<u128> {\n"
"            let mut current_amount_list = self.amount.read();\n"
"            current_amount_list.array()\n"
"        }\n"
"    }\n"
"}\n"
"```"

#~ msgid "Summary"
#~ msgstr "Resumen"

#~ msgid ""
#~ "// The constructor is decorated with a `#[constructor]` attribute.\n"
#~ "    // It is not inside an `impl` block.\n"
#~ msgstr ""
#~ "// The constructor is decorated with a `#[constructor]` attribute.\n"
#~ "    // It is not inside an `impl` block.\n"

#~ msgid "Local"
#~ msgstr "Local"

#~ msgid "declared inside a function"
#~ msgstr "declarado dentro de una función"

#~ msgid "not stored on the blockchain"
#~ msgstr "no almacenado en la blockchain"

#~ msgid "declared in the [Storage](./storage.md) of a contract"
#~ msgstr "declarado en el [Storage](./storage.md) de un contrato"

#~ msgid "can be accessed from one execution to another"
#~ msgstr "se puede acceder de una ejecución a otra"

#~ msgid "Global"
#~ msgstr "Global"

#~ msgid "provides information about the blockchain"
#~ msgstr "proporciona información sobre la blockchain"

#~ msgid "accessed anywhere, even within library functions"
#~ msgstr ""
#~ "se puede acceder desde cualquier lugar, incluso dentro de las funciones "
#~ "de la librería"

#~ msgid ""
#~ "// This variable is local to the current block. It can't be accessed once "
#~ "it goes out of scope.\n"
#~ msgstr ""
#~ "// This variable is local to the current block. It can't be accessed once "
#~ "it goes out of scope.\n"

#~ msgid ""
#~ "// The scope of a code block allows for local variable declaration\n"
#~ "                // We can access variables defined in higher scopes.\n"
#~ msgstr ""
#~ "// The scope of a code block allows for local variable declaration\n"
#~ "                // We can access variables defined in higher scopes.\n"

#~ msgid ""
#~ "// All storage variables are contained in a struct called Storage\n"
#~ "    // annotated with the `#[storage]` attribute\n"
#~ msgstr ""
#~ "// All storage variables are contained in a struct called Storage\n"
#~ "    // annotated with the `#[storage]` attribute\n"

#~ msgid "// Storage variable holding a number\n"
#~ msgstr "// Storage variable holding a number\n"

#~ msgid ""
#~ "// Write to storage variables by sending a transaction that calls an "
#~ "external function\n"
#~ msgstr ""
#~ "// Write to storage variables by sending a transaction that calls an "
#~ "external function\n"

#~ msgid "// Read from storage variables without sending transactions\n"
#~ msgstr "// Read from storage variables without sending transactions\n"

#~ msgid "// import the required functions from the starknet core library\n"
#~ msgstr "// import the required functions from the starknet core library\n"

#~ msgid "// Call the get_caller_address function to get the sender address\n"
#~ msgstr "// Call the get_caller_address function to get the sender address\n"

#~ msgid "// ...\n"
#~ msgstr "// ...\n"

#~ msgid ""
#~ "Functions that are accessible externally and can be called by anyone."
#~ msgstr ""
#~ "Funciones a las que se puede acceder externamente y que cualquiera puede "
#~ "llamar."

#~ msgid ""
#~ "If we want our function to be able to mutate the state of the contract, "
#~ "we pass it by reference like this: `ref self: ContractState`."
#~ msgstr ""
#~ "Si queremos que nuestra función pueda mutar el estado del contrato, lo "
#~ "pasamos por referencia así: `ref self: ContractState`."

#~ msgid ""
#~ "// The `abi(embed_v0)` attribute indicates that all the functions in this "
#~ "implementation can be called externally.\n"
#~ "    // Omitting this attribute would make all the functions in this "
#~ "implementation internal.\n"
#~ msgstr ""
#~ "// The `abi(embed_v0)` attribute indicates that all the functions in this "
#~ "implementation can be called externally.\n"
#~ "    // Omitting this attribute would make all the functions in this "
#~ "implementation internal.\n"

#~ msgid ""
#~ "// The `set` function can be called externally because it is written "
#~ "inside an implementation marked as `#[external]`.\n"
#~ "        // It can modify the contract's state as it is passed as a "
#~ "reference.\n"
#~ msgstr ""
#~ "// The `set` function can be called externally because it is written "
#~ "inside an implementation marked as `#[external]`.\n"
#~ "        // It can modify the contract's state as it is passed as a "
#~ "reference.\n"

#~ msgid ""
#~ "// The `get` function can be called externally because it is written "
#~ "inside an implementation marked as `#[external]`.\n"
#~ "        // However, it can't modify the contract's state is passed as a "
#~ "snapshot: it is only a \"view\" function.\n"
#~ msgstr ""
#~ "// The `get` function can be called externally because it is written "
#~ "inside an implementation marked as `#[external]`.\n"
#~ "        // However, it can't modify the contract's state is passed as a "
#~ "snapshot: it is only a \"view\" function.\n"

#~ msgid ""
#~ "// We can call an internal function from any functions within the "
#~ "contract\n"
#~ msgstr ""
#~ "// We can call an internal function from any functions within the "
#~ "contract\n"

#~ msgid ""
#~ "// The lack of the `external` attribute indicates that all the functions "
#~ "in this implementation can only be called internally.\n"
#~ "    // We name the trait `PrivateFunctionsTrait` to indicate that it is "
#~ "an internal trait allowing us to call internal functions.\n"
#~ msgstr ""
#~ "// The lack of the `external` attribute indicates that all the functions "
#~ "in this implementation can only be called internally.\n"
#~ "    // We name the trait `PrivateFunctionsTrait` to indicate that it is "
#~ "an internal trait allowing us to call internal functions.\n"

#~ msgid ""
#~ "// The `_read_value` function is outside the implementation that is "
#~ "marked as `#[abi(embed_v0)]`, so it's an _internal_ function\n"
#~ "        // and can only be called from within the contract.\n"
#~ "        // However, it can't modify the contract's state is passed as a "
#~ "snapshot: it is only a \"view\" function.\n"
#~ msgstr ""
#~ "// The `_read_value` function is outside the implementation that is "
#~ "marked as `#[abi(embed_v0)]`, so it's an _internal_ function\n"
#~ "        // and can only be called from within the contract.\n"
#~ "        // However, it can't modify the contract's state is passed as a "
#~ "snapshot: it is only a \"view\" function.\n"

#~ msgid ""
#~ "The contract has a state variable called 'counter' that is initialized to "
#~ "0."
#~ msgstr ""
#~ "El contrato tiene una variable de estado llamada 'counter' que se "
#~ "inicializa a 0."

#~ msgid ""
#~ "When a user calls 'increment', the contract increments the counter by 1."
#~ msgstr ""
#~ "Cuando un usuario llama a 'increment', el contrato incrementa el contador "
#~ "en 1."

#~ msgid ""
#~ "When a user calls 'decrement', the contract decrements the counter by 1."
#~ msgstr ""
#~ "Cuando un usuario llama a 'decrement', el contrato disminuye el contador "
#~ "en 1."

#~ msgid "// Counter variable\n"
#~ msgstr "// Counter variable\n"

#~ msgid "// Store initial value\n"
#~ msgstr "// Store initial value\n"

#~ msgid "// Store counter value + 1\n"
#~ msgstr "// Store counter value + 1\n"

#~ msgid "// Store counter value - 1\n"
#~ msgstr "// Store counter value - 1\n"

#~ msgid ""
#~ "More complex key-value mappings are possible, for example we could use "
#~ "`LegacyMap::<(ContractAddress, ContractAddress), felt252>` to create an "
#~ "allowance on an ERC20 token contract."
#~ msgstr ""
#~ "Son posibles asignaciones de key-value más complejas; por ejemplo, "
#~ "podríamos usar `LegacyMap::<(ContractAddress, ContractAddress), Felt252>` "
#~ "para crear una asignación en un contrato de token ERC20."

#~ msgid ""
#~ "// The `LegacyMap` type is only available inside the `Storage` struct.\n"
#~ msgstr ""
#~ "// The `LegacyMap` type is only available inside the `Storage` struct.\n"

#~ msgid ""
#~ "`assert` is used to validate conditions. If the check fails, an error is "
#~ "thrown along with a specified value, often a message. It's similar to the "
#~ "`require` statement in Solidity."
#~ msgstr ""
#~ "`assert` se utiliza para validar condiciones. Si la verificación falla, "
#~ "se genera un error junto con un valor específico, a menudo un mensaje. Es "
#~ "similar a la declaración `require` en Solidity."

#~ msgid ""
#~ "// Assert used to validate a condition\n"
#~ "            // and abort execution if the condition is not met\n"
#~ msgstr ""
#~ "// Assert used to validate a condition\n"
#~ "            // and abort execution if the condition is not met\n"

#~ msgid "// Panic used to abort execution directly\n"
#~ msgstr "// Panic used to abort execution directly\n"

#~ msgid "// you can define more errors here\n"
#~ msgstr "// you can define more errors here\n"

#~ msgid "// Or using panic:\n"
#~ msgstr "// Or using panic:\n"

#~ msgid "// Counter value\n"
#~ msgstr "// Counter value\n"

#~ msgid ""
#~ "// The event enum must be annotated with the `#[event]` attribute.\n"
#~ "    // It must also derive the `Drop` and `starknet::Event` traits.\n"
#~ msgstr ""
#~ "// The event enum must be annotated with the `#[event]` attribute.\n"
#~ "    // It must also derive the `Drop` and `starknet::Event` traits.\n"

#~ msgid ""
#~ "// By deriving the `starknet::Event` trait, we indicate to the compiler "
#~ "that\n"
#~ "    // this struct will be used when emitting events.\n"
#~ msgstr ""
#~ "// By deriving the `starknet::Event` trait, we indicate to the compiler "
#~ "that\n"
#~ "    // this struct will be used when emitting events.\n"

#~ msgid ""
#~ "// The `#[key]` attribute indicates that this event will be indexed.\n"
#~ msgstr ""
#~ "// The `#[key]` attribute indicates that this event will be indexed.\n"

#~ msgid ""
#~ "// Deriving the starknet::Store trait\n"
#~ "// allows us to store the `Person` struct in the contract's storage.\n"
#~ msgstr ""
#~ "// Deriving the starknet::Store trait\n"
#~ "// allows us to store the `Person` struct in the contract's storage.\n"

#~ msgid ""
#~ "// Deriving the `Serde` trait allows us to use\n"
#~ "    // the Person type as an entrypoint parameter and return value\n"
#~ msgstr ""
#~ "// Deriving the `Serde` trait allows us to use\n"
#~ "    // the Person type as an entrypoint parameter and return value\n"

#~ msgid ""
#~ "Explicitly, by defining a trait annoted with `#[starknet::interface]`"
#~ msgstr ""
#~ "Explícitamente, definiendo un trait anotado con `#[starknet::interface]`"

#~ msgid ""
#~ "// We need to have the interface of the callee contract defined\n"
#~ "// so that we can import the Dispatcher.\n"
#~ msgstr ""
#~ "// We need to have the interface of the callee contract defined\n"
#~ "// so that we can import the Dispatcher.\n"

#~ msgid "// We import the Dispatcher of the called contract\n"
#~ msgstr "// We import the Dispatcher of the called contract\n"

#~ msgid "/// Create a new counter contract from stored arguments\n"
#~ msgstr "/// Create a new counter contract from stored arguments\n"

#~ msgid "/// Create a new counter contract from the given arguments\n"
#~ msgstr "/// Create a new counter contract from the given arguments\n"

#~ msgid "/// Update the argument\n"
#~ msgstr "/// Update the argument\n"

#~ msgid ""
#~ "/// Update the class hash of the Counter contract to deploy when creating "
#~ "a new counter\n"
#~ msgstr ""
#~ "/// Update the class hash of the Counter contract to deploy when creating "
#~ "a new counter\n"

#~ msgid "/// Store the constructor arguments of the contract to deploy\n"
#~ msgstr "/// Store the constructor arguments of the contract to deploy\n"

#~ msgid "/// Store the class hash of the contract to deploy\n"
#~ msgstr "/// Store the class hash of the contract to deploy\n"

#~ msgid "// Contructor arguments\n"
#~ msgstr "// Contructor arguments\n"

#~ msgid "// Contract deployment\n"
#~ msgstr "// Contract deployment\n"

#~ msgid ""
#~ "// Import the interface and dispatcher to be able to interact with the "
#~ "contract.\n"
#~ msgstr ""
#~ "// Import the interface and dispatcher to be able to interact with the "
#~ "contract.\n"

#~ msgid "// Import the deploy syscall to be able to deploy the contract.\n"
#~ msgstr "// Import the deploy syscall to be able to deploy the contract.\n"

#~ msgid "// Use starknet test utils to fake the transaction context.\n"
#~ msgstr "// Use starknet test utils to fake the transaction context.\n"

#~ msgid "// Deploy the contract and return its dispatcher.\n"
#~ msgstr "// Deploy the contract and return its dispatcher.\n"

#~ msgid "// Set up constructor arguments.\n"
#~ msgstr "// Set up constructor arguments.\n"

#~ msgid "// Declare and deploy\n"
#~ msgstr "// Declare and deploy\n"

#~ msgid ""
#~ "// Return the dispatcher.\n"
#~ "        // The dispatcher allows to interact with the contract based on "
#~ "its interface.\n"
#~ msgstr ""
#~ "// Return the dispatcher.\n"
#~ "        // The dispatcher allows to interact with the contract based on "
#~ "its interface.\n"

#~ msgid "// Fake the caller address to address 1\n"
#~ msgstr "// Fake the caller address to address 1\n"

#~ msgid "// Fake the contract address to address 1\n"
#~ msgstr "// Fake the contract address to address 1\n"

#~ msgid "Use the `deploy` function logic to declare and deploy your contract."
#~ msgstr ""
#~ "Utilice la lógica de la función `deploy` para declarar y desplegar su "
#~ "contrato."

#~ msgid "`set_caller_address(address: ContractAddress)`"
#~ msgstr "`set_caller_address(address: ContractAddress)`"

#~ msgid "`set_contract_address(address: ContractAddress)`"
#~ msgstr "`set_contract_address(address: ContractAddress)`"

#~ msgid "`set_block_timestamp(block_timestamp: u64)`"
#~ msgstr "`set_block_timestamp(block_timestamp: u64)`"

#~ msgid "`set_account_contract_address(address: ContractAddress)`"
#~ msgstr "`set_account_contract_address(address: ContractAddress)`"

#~ msgid "`set_max_fee(fee: u128)`"
#~ msgstr "`set_max_fee(fee: u128)`"

#~ msgid "`get_caller_address() -> ContractAddress`"
#~ msgstr "`get_caller_address() -> ContractAddress`"

#~ msgid "`get_contract_address() -> ContractAddress`"
#~ msgstr "`get_contract_address() -> ContractAddress`"

#~ msgid "`get_block_info() -> Box<BlockInfo>`"
#~ msgstr "`get_block_info() -> Box<BlockInfo>`"

#~ msgid "`get_tx_info() -> Box<TxInfo>`"
#~ msgstr "`get_tx_info() -> Box<TxInfo>`"

#~ msgid "`get_block_timestamp() -> u64`"
#~ msgstr "`get_block_timestamp() -> u64`"

#~ msgid "`get_block_number() -> u64`"
#~ msgstr "`get_block_number() -> u64`"

#~ msgid ""
#~ "// for a 2D mapping its important to take note of the amount of brackets "
#~ "being used.\n"
#~ msgstr ""
#~ "// for a 2D mapping its important to take note of the amount of brackets "
#~ "being used.\n"

#~ msgid "// Returns true if an array is empty, then false if it isn't.\n"
#~ msgstr "// Returns true if an array is empty, then false if it isn't.\n"

#~ msgid "// Same as ~ while (i < 10) arr.append(i++);\n"
#~ msgstr "// Same as ~ while (i < 10) arr.append(i++);\n"

#~ msgid "\"0x000\""
#~ msgstr "\"0x000\""

#~ msgid "// Create tuple\n"
#~ msgstr "// Create tuple\n"

#~ msgid "// Access tuple\n"
#~ msgstr "// Access tuple\n"

#~ msgid ""
#~ "// With Store, you can store Data's structs in the storage part of "
#~ "contracts.\n"
#~ msgstr ""
#~ "// With Store, you can store Data's structs in the storage part of "
#~ "contracts.\n"

#~ msgid ""
#~ "// Since a u32 might not fit in a u8 and a u16, we need to use try_into,\n"
#~ "    // then unwrap the Option<T> type thats returned.\n"
#~ msgstr ""
#~ "// Since a u32 might not fit in a u8 and a u16, we need to use try_into,\n"
#~ "    // then unwrap the Option<T> type thats returned.\n"

#~ msgid ""
#~ "// since new_u32 is the of the same type (u32) as rand_number, we can "
#~ "directly assign them,\n"
#~ "    // or use the .into() method.\n"
#~ msgstr ""
#~ "// since new_u32 is the of the same type (u32) as rand_number, we can "
#~ "directly assign them,\n"
#~ "    // or use the .into() method.\n"

#~ msgid ""
#~ "// When typecasting from a smaller size to an equal or larger size we use "
#~ "the .into() method.\n"
#~ "    // Note: u64 and u128 are larger than u32, so a u32 type will always "
#~ "fit into them.\n"
#~ msgstr ""
#~ "// When typecasting from a smaller size to an equal or larger size we use "
#~ "the .into() method.\n"
#~ "    // Note: u64 and u128 are larger than u32, so a u32 type will always "
#~ "fit into them.\n"

#~ msgid ""
#~ "// Since a felt252 is smaller than a u256, we can use the into() method\n"
#~ msgstr ""
#~ "// Since a felt252 is smaller than a u256, we can use the into() method\n"

#~ msgid "//note a usize is smaller than a felt so we use the try_into\n"
#~ msgstr "//note a usize is smaller than a felt so we use the try_into\n"

#~ msgid "Modularity: Easily pluggable into multiple contracts."
#~ msgstr "Modularidad: Fácilmente conectable a múltiples contratos."

#~ msgid "Reusable Logic: Encapsulates specific functionalities."
#~ msgstr "Lógica Reutilizable: Encapsula funcionalidades específicas."

#~ msgid "Not Standalone: Cannot be declared or deployed independently."
#~ msgstr ""
#~ "No independiente: No se puede declarar ni implementar de forma "
#~ "independiente."

#~ msgid "A Storage struct"
#~ msgstr "Una struct de Storage"

#~ msgid ""
#~ "// This is needed to be able to use internal functions of the switch "
#~ "component.\n"
#~ msgstr ""
#~ "// This is needed to be able to use internal functions of the switch "
#~ "component.\n"

#~ msgid ""
#~ "When a user deposits a token, the contract calculates the amount of "
#~ "shares to mint."
#~ msgstr ""
#~ "Cuando un usuario deposita un token, el contrato calcula la cantidad de "
#~ "acciones a acuñar."

#~ msgid ""
#~ "// In order to make contract calls within our Vault,\n"
#~ "// we need to have the interface of the remote ERC20 contract defined to "
#~ "import the Dispatcher.\n"
#~ msgstr ""
#~ "// In order to make contract calls within our Vault,\n"
#~ "// we need to have the interface of the remote ERC20 contract defined to "
#~ "import the Dispatcher.\n"

#~ msgid ""
#~ "// a = amount\n"
#~ "            // B = balance of token before deposit\n"
#~ "            // T = total supply\n"
#~ "            // s = shares to mint\n"
#~ "            //\n"
#~ "            // (T + s) / T = (a + B) / B \n"
#~ "            //\n"
#~ "            // s = aT / B\n"
#~ msgstr ""
#~ "// a = amount\n"
#~ "            // B = balance of token before deposit\n"
#~ "            // T = total supply\n"
#~ "            // s = shares to mint\n"
#~ "            //\n"
#~ "            // (T + s) / T = (a + B) / B \n"
#~ "            //\n"
#~ "            // s = aT / B\n"

#~ msgid ""
#~ "// a = amount\n"
#~ "            // B = balance of token before withdraw\n"
#~ "            // T = total supply\n"
#~ "            // s = shares to burn\n"
#~ "            //\n"
#~ "            // (T - s) / T = (B - a) / B \n"
#~ "            //\n"
#~ "            // a = sB / T\n"
#~ msgstr ""
#~ "// a = amount\n"
#~ "            // B = balance of token before withdraw\n"
#~ "            // T = total supply\n"
#~ "            // s = shares to burn\n"
#~ "            //\n"
#~ "            // (T - s) / T = (B - a) / B \n"
#~ "            //\n"
#~ "            // a = sB / T\n"

#~ msgid "// What can go wrong here?\n"
#~ msgstr "// What can go wrong here?\n"

#~ msgid ""
#~ "// Fee 0 - 1000 (0% - 100%, 1 decimal places)\n"
#~ "        // E.g. 3 = 0.3%\n"
#~ msgstr ""
#~ "// Fee 0 - 1000 (0% - 100%, 1 decimal places)\n"
#~ "        // E.g. 3 = 0.3%\n"

#~ msgid "// assert(fee <= 1000, 'fee > 1000');\n"
#~ msgstr "// assert(fee <= 1000, 'fee > 1000');\n"

#~ msgid ""
#~ "// How much dy for dx?\n"
#~ "            // xy = k\n"
#~ "            // (x + dx)(y - dy) = k\n"
#~ "            // y - dy = k / (x + dx)\n"
#~ "            // y - k / (x + dx) = dy\n"
#~ "            // y - xy / (x + dx) = dy\n"
#~ "            // (yx + ydx - xy) / (x + dx) = dy\n"
#~ "            // ydx / (x + dx) = dy\n"
#~ msgstr ""
#~ "// How much dy for dx?\n"
#~ "            // xy = k\n"
#~ "            // (x + dx)(y - dy) = k\n"
#~ "            // y - dy = k / (x + dx)\n"
#~ "            // y - k / (x + dx) = dy\n"
#~ "            // y - xy / (x + dx) = dy\n"
#~ "            // (yx + ydx - xy) / (x + dx) = dy\n"
#~ "            // ydx / (x + dx) = dy\n"

#~ msgid ""
#~ "// How much dx, dy to add?\n"
#~ "            //\n"
#~ "            // xy = k\n"
#~ "            // (x + dx)(y + dy) = k'\n"
#~ "            //\n"
#~ "            // No price change, before and after adding liquidity\n"
#~ "            // x / y = (x + dx) / (y + dy)\n"
#~ "            //\n"
#~ "            // x(y + dy) = y(x + dx)\n"
#~ "            // x * dy = y * dx\n"
#~ "            //\n"
#~ "            // x / y = dx / dy\n"
#~ "            // dy = y / x * dx\n"
#~ msgstr ""
#~ "// How much dx, dy to add?\n"
#~ "            //\n"
#~ "            // xy = k\n"
#~ "            // (x + dx)(y + dy) = k'\n"
#~ "            //\n"
#~ "            // No price change, before and after adding liquidity\n"
#~ "            // x / y = (x + dx) / (y + dy)\n"
#~ "            //\n"
#~ "            // x(y + dy) = y(x + dx)\n"
#~ "            // x * dy = y * dx\n"
#~ "            //\n"
#~ "            // x / y = dx / dy\n"
#~ "            // dy = y / x * dx\n"

#~ msgid ""
#~ "// How much shares to mint?\n"
#~ "            //\n"
#~ "            // f(x, y) = value of liquidity\n"
#~ "            // We will define f(x, y) = sqrt(xy)\n"
#~ "            //\n"
#~ "            // L0 = f(x, y)\n"
#~ "            // L1 = f(x + dx, y + dy)\n"
#~ "            // T = total shares\n"
#~ "            // s = shares to mint\n"
#~ "            //\n"
#~ "            // Total shares should increase proportional to increase in "
#~ "liquidity\n"
#~ "            // L1 / L0 = (T + s) / T\n"
#~ "            //\n"
#~ "            // L1 * T = L0 * (T + s)\n"
#~ "            //\n"
#~ "            // (L1 - L0) * T / L0 = s\n"
#~ msgstr ""
#~ "// How much shares to mint?\n"
#~ "            //\n"
#~ "            // f(x, y) = value of liquidity\n"
#~ "            // We will define f(x, y) = sqrt(xy)\n"
#~ "            //\n"
#~ "            // L0 = f(x, y)\n"
#~ "            // L1 = f(x + dx, y + dy)\n"
#~ "            // T = total shares\n"
#~ "            // s = shares to mint\n"
#~ "            //\n"
#~ "            // Total shares should increase proportional to increase in "
#~ "liquidity\n"
#~ "            // L1 / L0 = (T + s) / T\n"
#~ "            //\n"
#~ "            // L1 * T = L0 * (T + s)\n"
#~ "            //\n"
#~ "            // (L1 - L0) * T / L0 = s\n"

#~ msgid ""
#~ "// Claim\n"
#~ "            // (L1 - L0) / L0 = dx / x = dy / y\n"
#~ "            //\n"
#~ "            // Proof\n"
#~ "            // --- Equation 1 ---\n"
#~ "            // (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / "
#~ "sqrt(xy)\n"
#~ "            //\n"
#~ "            // dx / dy = x / y so replace dy = dx * y / x\n"
#~ "            //\n"
#~ "            // --- Equation 2 ---\n"
#~ "            // Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / "
#~ "sqrt(xy)\n"
#~ "            //\n"
#~ "            // Multiply by sqrt(x) / sqrt(x)\n"
#~ "            // Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - "
#~ "sqrt(x^2y)) / sqrt(x^2y)\n"
#~ "            //            = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - "
#~ "sqrt(x^2)) / (sqrt(y)sqrt(x^2))\n"
#~ "            // sqrt(y) on top and bottom cancels out\n"
#~ "            //\n"
#~ "            // --- Equation 3 ---\n"
#~ "            // Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
#~ "(sqrt(x^2)\n"
#~ "            // = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n"
#~ "            // = ((x + dx) - x) / x\n"
#~ "            // = dx / x\n"
#~ "            // Since dx / dy = x / y,\n"
#~ "            // dx / x = dy / y\n"
#~ "            //\n"
#~ "            // Finally\n"
#~ "            // (L1 - L0) / L0 = dx / x = dy / y\n"
#~ msgstr ""
#~ "// Claim\n"
#~ "            // (L1 - L0) / L0 = dx / x = dy / y\n"
#~ "            //\n"
#~ "            // Proof\n"
#~ "            // --- Equation 1 ---\n"
#~ "            // (L1 - L0) / L0 = (sqrt((x + dx)(y + dy)) - sqrt(xy)) / "
#~ "sqrt(xy)\n"
#~ "            //\n"
#~ "            // dx / dy = x / y so replace dy = dx * y / x\n"
#~ "            //\n"
#~ "            // --- Equation 2 ---\n"
#~ "            // Equation 1 = (sqrt(xy + 2ydx + dx^2 * y / x) - sqrt(xy)) / "
#~ "sqrt(xy)\n"
#~ "            //\n"
#~ "            // Multiply by sqrt(x) / sqrt(x)\n"
#~ "            // Equation 2 = (sqrt(x^2y + 2xydx + dx^2 * y) - "
#~ "sqrt(x^2y)) / sqrt(x^2y)\n"
#~ "            //            = (sqrt(y)(sqrt(x^2 + 2xdx + dx^2) - "
#~ "sqrt(x^2)) / (sqrt(y)sqrt(x^2))\n"
#~ "            // sqrt(y) on top and bottom cancels out\n"
#~ "            //\n"
#~ "            // --- Equation 3 ---\n"
#~ "            // Equation 2 = (sqrt(x^2 + 2xdx + dx^2) - sqrt(x^2)) / "
#~ "(sqrt(x^2)\n"
#~ "            // = (sqrt((x + dx)^2) - sqrt(x^2)) / sqrt(x^2)\n"
#~ "            // = ((x + dx) - x) / x\n"
#~ "            // = dx / x\n"
#~ "            // Since dx / dy = x / y,\n"
#~ "            // dx / x = dy / y\n"
#~ "            //\n"
#~ "            // Finally\n"
#~ "            // (L1 - L0) / L0 = dx / x = dy / y\n"

#~ msgid ""
#~ "// Claim\n"
#~ "            // dx, dy = amount of liquidity to remove\n"
#~ "            // dx = s / T * x\n"
#~ "            // dy = s / T * y\n"
#~ "            //\n"
#~ "            // Proof\n"
#~ "            // Let's find dx, dy such that\n"
#~ "            // v / L = s / T\n"
#~ "            //\n"
#~ "            // where\n"
#~ "            // v = f(dx, dy) = sqrt(dxdy)\n"
#~ "            // L = total liquidity = sqrt(xy)\n"
#~ "            // s = shares\n"
#~ "            // T = total supply\n"
#~ "            //\n"
#~ "            // --- Equation 1 ---\n"
#~ "            // v = s / T * L\n"
#~ "            // sqrt(dxdy) = s / T * sqrt(xy)\n"
#~ "            //\n"
#~ "            // Amount of liquidity to remove must not change price so\n"
#~ "            // dx / dy = x / y\n"
#~ "            //\n"
#~ "            // replace dy = dx * y / x\n"
#~ "            // sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n"
#~ "            //\n"
#~ "            // Divide both sides of Equation 1 with sqrt(y / x)\n"
#~ "            // dx = s / T * sqrt(xy) / sqrt(y / x)\n"
#~ "            // = s / T * sqrt(x^2) = s / T * x\n"
#~ "            //\n"
#~ "            // Likewise\n"
#~ "            // dy = s / T * y\n"
#~ msgstr ""
#~ "// Claim\n"
#~ "            // dx, dy = amount of liquidity to remove\n"
#~ "            // dx = s / T * x\n"
#~ "            // dy = s / T * y\n"
#~ "            //\n"
#~ "            // Proof\n"
#~ "            // Let's find dx, dy such that\n"
#~ "            // v / L = s / T\n"
#~ "            //\n"
#~ "            // where\n"
#~ "            // v = f(dx, dy) = sqrt(dxdy)\n"
#~ "            // L = total liquidity = sqrt(xy)\n"
#~ "            // s = shares\n"
#~ "            // T = total supply\n"
#~ "            //\n"
#~ "            // --- Equation 1 ---\n"
#~ "            // v = s / T * L\n"
#~ "            // sqrt(dxdy) = s / T * sqrt(xy)\n"
#~ "            //\n"
#~ "            // Amount of liquidity to remove must not change price so\n"
#~ "            // dx / dy = x / y\n"
#~ "            //\n"
#~ "            // replace dy = dx * y / x\n"
#~ "            // sqrt(dxdy) = sqrt(dx * dx * y / x) = dx * sqrt(y / x)\n"
#~ "            //\n"
#~ "            // Divide both sides of Equation 1 with sqrt(y / x)\n"
#~ "            // dx = s / T * sqrt(xy) / sqrt(y / x)\n"
#~ "            // = s / T * sqrt(x^2) = s / T * x\n"
#~ "            //\n"
#~ "            // Likewise\n"
#~ "            // dy = s / T * y\n"

#~ msgid ""
#~ "// bal0 >= reserve0\n"
#~ "            // bal1 >= reserve1\n"
#~ msgstr ""
#~ "// bal0 >= reserve0\n"
#~ "            // bal1 >= reserve1\n"

#~ msgid ""
#~ "// By taking the 250 least significant bits of the hash output, we get a "
#~ "valid 250bits storage address.\n"
#~ msgstr ""
#~ "// By taking the 250 least significant bits of the hash output, we get a "
#~ "valid 250bits storage address.\n"

#~ msgid ""
#~ "// Read the stored array's length. If the length is superior to 255, the "
#~ "read will fail.\n"
#~ msgstr ""
#~ "// Read the stored array's length. If the length is superior to 255, the "
#~ "read will fail.\n"

#~ msgid ""
#~ "// Sequentially read all stored elements and append them to the array.\n"
#~ msgstr ""
#~ "// Sequentially read all stored elements and append them to the array.\n"

#~ msgid "// Return the array.\n"
#~ msgstr "// Return the array.\n"

#~ msgid "// // Store the length of the array in the first storage slot.\n"
#~ msgstr "// // Store the length of the array in the first storage slot.\n"

#~ msgid "// Store the array elements sequentially\n"
#~ msgstr "// Store the array elements sequentially\n"

#~ msgid "// Split the hashed value into two 128-bit segments\n"
#~ msgstr "// Split the hashed value into two 128-bit segments\n"

#~ msgid "// Reverse each 128-bit segment\n"
#~ msgstr "// Reverse each 128-bit segment\n"

#~ msgid "// Reverse merge the reversed segments back into a u256 value\n"
#~ msgstr "// Reverse merge the reversed segments back into a u256 value\n"

#~ msgid ""
#~ "// This will call the pack method of the TimePackable trait\n"
#~ "            // and store the resulting felt252\n"
#~ msgstr ""
#~ "// This will call the pack method of the TimePackable trait\n"
#~ "            // and store the resulting felt252\n"

#~ msgid ""
#~ "// This will read the felt252 value from storage\n"
#~ "            // and return the result of the unpack method of the "
#~ "TimePackable trait\n"
#~ msgstr ""
#~ "// This will read the felt252 value from storage\n"
#~ "            // and return the result of the unpack method of the "
#~ "TimePackable trait\n"

#~ msgid ""
#~ "The `append` operation costs 2 storage writes - one for the value itself "
#~ "and another one for updating the List's length"
#~ msgstr ""
#~ "La operación `append` cuesta 2 escrituras de storage - una para el valor "
#~ "en sí y otra para actualizar la longitud de la Lista"

#~ msgid "Here's a list of other resources that you might find useful:"
#~ msgstr "Aquí hay una lista de otros recursos que pueden resultarle útiles:"

#~ msgid ""
#~ "[Starklings](https://github.com/shramee/starklings-cairo1): An "
#~ "interactive tutorial to get you up and running with Cairo v1 and Starknet "
#~ msgstr ""
#~ "[Starklings](https://github.com/shramee/starklings-cairo1): Un tutorial "
#~ "interactivo para empezar a utilizar Cairo v1 y Starknet "

#~ msgid ""
#~ "[Cairopractice](https://cairopractice.com/): A blog with a series of "
#~ "articles about Cairo and Starknet"
#~ msgstr ""
#~ "[Cairopractice](https://cairopractice.com/): Un blog con una serie de "
#~ "artículos sobre Cairo y Starknet"

#~ msgid ""
#~ "[Cairo by example](https://cairo-by-example.com/): An introduction to "
#~ "Cairo, with simple examples"
#~ msgstr ""
#~ "[Cairo by example](https://cairo-by-example.com/): Una introducción a "
#~ "Cairo, con ejemplos sencillos"
